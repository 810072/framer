import { a as of, b as Ne, c as I } from "./chunk-ELYU6EKT.mjs"; var Ct = {}; of(Ct, { Children: () => qn, Component: () => Ee, Fragment: () => mr, Profiler: () => DT, PureComponent: () => AT, StrictMode: () => VT, Suspense: () => ps, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => BT, cloneElement: () => gr, createContext: () => ke, createElement: () => dl, createFactory: () => zT, createRef: () => oo, default: () => x, forwardRef: () => Ve, isValidElement: () => Nt, lazy: () => $T, memo: () => NT, startTransition: () => vr, unstable_act: () => HT, useCallback: () => se, useContext: () => V, useDebugValue: () => jT, useDeferredValue: () => WT, useEffect: () => N, useId: () => Ti, useImperativeHandle: () => UT, useInsertionEffect: () => st, useLayoutEffect: () => et, useMemo: () => ae, useReducer: () => GT, useRef: () => A, useState: () => Qe, useSyncExternalStore: () => Bg, useTransition: () => qT, version: () => XT }); var x = {}, hs = Symbol.for("react.element"), xT = Symbol.for("react.portal"), wT = Symbol.for("react.fragment"), ST = Symbol.for("react.strict_mode"), kT = Symbol.for("react.profiler"), CT = Symbol.for("react.provider"), TT = Symbol.for("react.context"), ET = Symbol.for("react.forward_ref"), RT = Symbol.for("react.suspense"), PT = Symbol.for("react.memo"), _T = Symbol.for("react.lazy"), Pg = Symbol.iterator; function FT(e) { return e === null || typeof e != "object" ? null : (e = Pg && e[Pg] || e["@@iterator"], typeof e == "function" ? e : null) } var Ig = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Lg = Object.assign, Mg = {}; function io(e, t, n) { this.props = e, this.context = t, this.refs = Mg, this.updater = n || Ig } io.prototype.isReactComponent = {}; io.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; io.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function Og() { } Og.prototype = io.prototype; function af(e, t, n) { this.props = e, this.context = t, this.refs = Mg, this.updater = n || Ig } var lf = af.prototype = new Og; lf.constructor = af; Lg(lf, io.prototype); lf.isPureReactComponent = !0; var _g = Array.isArray, Dg = Object.prototype.hasOwnProperty, cf = { current: null }, Ag = { key: !0, ref: !0, __self: !0, __source: !0 }; function Vg(e, t, n) { var r, i = {}, o = null, s = null; if (t != null) for (r in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (o = "" + t.key), t) Dg.call(t, r) && !Ag.hasOwnProperty(r) && (i[r] = t[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; i.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: hs, type: e, key: o, ref: s, props: i, _owner: cf.current } } function IT(e, t) { return { $$typeof: hs, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function uf(e) { return typeof e == "object" && e !== null && e.$$typeof === hs } function LT(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var Fg = /\/+/g; function sf(e, t) { return typeof e == "object" && e !== null && e.key != null ? LT("" + e.key) : t.toString(36) } function ul(e, t, n, r, i) { var o = typeof e; o !== "undefined" && o !== "boolean" || (e = null); var s = !1; if (e === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (e.$$typeof) { case hs: case xT: s = !0 } }if (s) return s = e, i = i(s), e = r === "" ? "." + sf(s, 0) : r, _g(i) ? (n = "", e != null && (n = e.replace(Fg, "$&/") + "/"), ul(i, t, n, "", function (c) { return c })) : i != null && (uf(i) && (i = IT(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(Fg, "$&/") + "/") + e)), t.push(i)), 1; if (s = 0, r = r === "" ? "." : r + ":", _g(e)) for (var a = 0; a < e.length; a++) { o = e[a]; var l = r + sf(o, a); s += ul(o, t, n, l, i) } else if (l = FT(e), typeof l == "function") for (e = l.call(e), a = 0; !(o = e.next()).done;)o = o.value, l = r + sf(o, a++), s += ul(o, t, n, l, i); else if (o === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return s } function cl(e, t, n) { if (e == null) return e; var r = [], i = 0; return ul(e, r, "", "", function (o) { return t.call(n, o, i++) }), r } function MT(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { e._status !== 0 && e._status !== -1 || (e._status = 1, e._result = n) }, function (n) { e._status !== 0 && e._status !== -1 || (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var Ot = { current: null }, fl = { transition: null }, OT = { ReactCurrentDispatcher: Ot, ReactCurrentBatchConfig: fl, ReactCurrentOwner: cf }; x.Children = { map: cl, forEach: function (e, t, n) { cl(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return cl(e, function () { t++ }), t }, toArray: function (e) { return cl(e, function (t) { return t }) || [] }, only: function (e) { if (!uf(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; x.Component = io; x.Fragment = wT; x.Profiler = kT; x.PureComponent = af; x.StrictMode = ST; x.Suspense = RT; x.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = OT; x.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = Lg({}, e.props), i = e.key, o = e.ref, s = e._owner; if (t != null) { if (t.ref !== void 0 && (o = t.ref, s = cf.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) Dg.call(t, l) && !Ag.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; r.children = a } return { $$typeof: hs, type: e.type, key: i, ref: o, props: r, _owner: s } }; x.createContext = function (e) { return e = { $$typeof: TT, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: CT, _context: e }, e.Consumer = e }; x.createElement = Vg; x.createFactory = function (e) { var t = Vg.bind(null, e); return t.type = e, t }; x.createRef = function () { return { current: null } }; x.forwardRef = function (e) { return { $$typeof: ET, render: e } }; x.isValidElement = uf; x.lazy = function (e) { return { $$typeof: _T, _payload: { _status: -1, _result: e }, _init: MT } }; x.memo = function (e, t) { return { $$typeof: PT, type: e, compare: t === void 0 ? null : t } }; x.startTransition = function (e) { var t = fl.transition; fl.transition = {}; try { e() } finally { fl.transition = t } }; x.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; x.useCallback = function (e, t) { return Ot.current.useCallback(e, t) }; x.useContext = function (e) { return Ot.current.useContext(e) }; x.useDebugValue = function () { }; x.useDeferredValue = function (e) { return Ot.current.useDeferredValue(e) }; x.useEffect = function (e, t) { return Ot.current.useEffect(e, t) }; x.useId = function () { return Ot.current.useId() }; x.useImperativeHandle = function (e, t, n) { return Ot.current.useImperativeHandle(e, t, n) }; x.useInsertionEffect = function (e, t) { return Ot.current.useInsertionEffect(e, t) }; x.useLayoutEffect = function (e, t) { return Ot.current.useLayoutEffect(e, t) }; x.useMemo = function (e, t) { return Ot.current.useMemo(e, t) }; x.useReducer = function (e, t, n) { return Ot.current.useReducer(e, t, n) }; x.useRef = function (e) { return Ot.current.useRef(e) }; x.useState = function (e) { return Ot.current.useState(e) }; x.useSyncExternalStore = function (e, t, n) { return Ot.current.useSyncExternalStore(e, t, n) }; x.useTransition = function () { return Ot.current.useTransition() }; x.version = "18.2.0"; var qn = x.Children, Ee = x.Component, mr = x.Fragment, DT = x.Profiler, AT = x.PureComponent, VT = x.StrictMode, ps = x.Suspense, BT = x.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, gr = x.cloneElement, ke = x.createContext, dl = x.createElement, zT = x.createFactory, oo = x.createRef, Ve = x.forwardRef, Nt = x.isValidElement, $T = x.lazy, NT = x.memo, vr = x.startTransition, HT = x.unstable_act, se = x.useCallback, V = x.useContext, jT = x.useDebugValue, WT = x.useDeferredValue, N = x.useEffect, Ti = x.useId, UT = x.useImperativeHandle, st = x.useInsertionEffect, et = x.useLayoutEffect, ae = x.useMemo, GT = x.useReducer, A = x.useRef, Qe = x.useState, Bg = x.useSyncExternalStore, qT = x.useTransition, XT = x.version; var YT = "default" in Ct ? x : Ct, so = {}, KT = YT, QT = Symbol.for("react.element"), ZT = Symbol.for("react.fragment"), JT = Object.prototype.hasOwnProperty, eE = KT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, tE = { key: !0, ref: !0, __self: !0, __source: !0 }; function zg(e, t, n) { var r, i = {}, o = null, s = null; n !== void 0 && (o = "" + n), t.key !== void 0 && (o = "" + t.key), t.ref !== void 0 && (s = t.ref); for (r in t) JT.call(t, r) && !tE.hasOwnProperty(r) && (i[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]); return { $$typeof: QT, type: e, key: o, ref: s, props: i, _owner: eE.current } } so.Fragment = ZT; so.jsx = zg; so.jsxs = zg; var He = so.Fragment, k = so.jsx, ce = so.jsxs; var nE = Object.create, Hf = Object.defineProperty, rE = Object.getOwnPropertyDescriptor, fy = Object.getOwnPropertyNames, iE = Object.getPrototypeOf, oE = Object.prototype.hasOwnProperty, sE = (e, t, n) => t in e ? Hf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, mn = (e, t) => function () { return t || (0, e[fy(e)[0]])((t = { exports: {} }).exports, t), t.exports }, aE = (e, t, n, r) => { if (t && typeof t == "object" || typeof t == "function") for (let i of fy(t)) !oE.call(e, i) && i !== n && Hf(e, i, { get: () => t[i], enumerable: !(r = rE(t, i)) || r.enumerable }); return e }, Zn = (e, t, n) => (n = e != null ? nE(iE(e)) : {}, aE(t || !e || !e.__esModule ? Hf(n, "default", { value: e, enumerable: !0 }) : n, e)), T = (e, t, n) => (sE(e, typeof t != "symbol" ? t + "" : t, n), n), jf = (e, t, n) => { if (!t.has(e)) throw TypeError("Cannot " + n) }, ue = (e, t, n) => (jf(e, t, "read from private field"), n ? n.call(e) : t.get(e)), en = (e, t, n) => { if (t.has(e)) throw TypeError("Cannot add the same private member more than once"); t instanceof WeakSet ? t.add(e) : t.set(e, n) }, Wf = (e, t, n, r) => (jf(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), Wt = (e, t, n) => (jf(e, t, "access private method"), n), lE = mn({ "../../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); function t(n) { var r = {}; return function (i) { return r[i] === void 0 && (r[i] = n(i)), r[i] } } e.default = t } }), cE = mn({ "../../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); function t(o) { return o && typeof o == "object" && "default" in o ? o.default : o } var n = t(lE()), r = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, i = n(function (o) { return r.test(o) || o.charCodeAt(0) === 111 && o.charCodeAt(1) === 110 && o.charCodeAt(2) < 91 }); e.default = i } }), xr = ke({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }), Fs = ke({}), go = ke(null), Pl = typeof I < "u", Gr = Pl ? et : N, _l = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), uE = "framerAppearId", Fl = "data-" + _l(uE), Il = { skipAnimations: !1, useManualTiming: !1 }, Ll = ke({}), Es = ke({}), gt = e => e, vo = gt, Jt = gt, dy = ke({ strict: !1 }); function fE(e) { let t = new Set, n = new Set, r = !1, i = !1, o = new WeakSet, s = { delta: 0, timestamp: 0, isProcessing: !1 }; function a(c) { o.has(c) && (l.schedule(c), e()), c(s) } let l = { schedule: (c, u = !1, f = !1) => { let m = f && r ? t : n; return u && o.add(c), m.has(c) || m.add(c), c }, cancel: c => { n.delete(c), o.delete(c) }, process: c => { if (s = c, r) { i = !0; return } r = !0, [t, n] = [n, t], n.clear(), t.forEach(a), r = !1, i && (i = !1, l.process(c)) } }; return l } var vs = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"], dE = 40; function hy(e, t) { let n = !1, r = !0, i = { delta: 0, timestamp: 0, isProcessing: !1 }, o = () => n = !0, s = vs.reduce((h, p) => (h[p] = fE(o), h), {}), { read: a, resolveKeyframes: l, update: c, preRender: u, render: f, postRender: d } = s, m = () => { let h = Il.useManualTiming ? i.timestamp : performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(h - i.timestamp, dE), 1), i.timestamp = h, i.isProcessing = !0, a.process(i), l.process(i), c.process(i), u.process(i), f.process(i), d.process(i), i.isProcessing = !1, n && t && (r = !1, e(m)) }, y = () => { n = !0, r = !0, i.isProcessing || e(m) }; return { schedule: vs.reduce((h, p) => { let v = s[p]; return h[p] = (w, C = !1, S = !1) => (n || y(), v.schedule(w, C, S)), h }, {}), cancel: h => { for (let p = 0; p < vs.length; p++)s[vs[p]].cancel(h) }, state: i, steps: s } } var { schedule: Uf, cancel: M$ } = hy(queueMicrotask, !1); function ao(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } var $g = !1; function hE(e, t, n, r, i) { var o; let { visualElement: s } = V(Fs), a = V(dy), l = V(go), c = V(xr).reducedMotion, u = A(); r = r || a.renderer, !u.current && r && (u.current = r(e, { visualState: t, parent: s, props: n, presenceContext: l, blockInitialAnimation: l ? l.initial === !1 : !1, reducedMotionConfig: c })); let f = u.current, d = V(Ll); f && !f.projection && i && (f.type === "html" || f.type === "svg") && mE(u.current, n, i, d), st(() => { f && f.update(n, l) }); let m = n[Fl], y = A(!!m && !I.MotionHandoffIsComplete && ((o = I.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(I, m))); return Gr(() => { f && (f.updateFeatures(), Uf.render(f.render), y.current && f.animationState && f.animationState.animateChanges()) }), N(() => { f && (!y.current && f.animationState && f.animationState.animateChanges(), y.current = !1, $g || ($g = !0, queueMicrotask(pE))) }), f } function pE() { I.MotionHandoffIsComplete = !0 } function mE(e, t, n, r) { let { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: l, layoutRoot: c } = t; e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : py(e.parent)), e.projection.setOptions({ layoutId: i, layout: o, alwaysMeasureLayout: !!s || a && ao(a), visualElement: e, animationType: typeof o == "string" ? o : "both", initialPromotionConfig: r, layoutScroll: l, layoutRoot: c }) } function py(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : py(e.parent) } function gE(e, t, n) { return se(r => { r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && (typeof n == "function" ? n(r) : ao(n) && (n.current = r)) }, [t]) } function Rs(e) { return typeof e == "string" || Array.isArray(e) } function Ps(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } var Gf = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], qf = ["initial", ...Gf]; function Ml(e) { return Ps(e.animate) || qf.some(t => Rs(e[t])) } function my(e) { return !!(Ml(e) || e.variants) } function vE(e, t) { if (Ml(e)) { let { initial: n, animate: r } = e; return { initial: n === !1 || Rs(n) ? n : void 0, animate: Rs(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function yE(e) { let { initial: t, animate: n } = vE(e, V(Fs)); return ae(() => ({ initial: t, animate: n }), [Ng(t), Ng(n)]) } function Ng(e) { return Array.isArray(e) ? e.join(" ") : e } var Hg = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, ho = {}; for (let e in Hg) ho[e] = { isEnabled: t => Hg[e].some(n => !!t[n]) }; function bE(e) { for (let t in e) ho[t] = { ...ho[t], ...e[t] } } var Xf = Symbol.for("motionComponentSymbol"); function gy({ preloadedFeatures: e, createVisualElement: t, useRender: n, useVisualState: r, Component: i }) { e && bE(e); function o(a, l) { let c, u = { ...V(xr), ...a, layoutId: xE(a) }, { isStatic: f } = u, d = yE(a), m = r(a, f); if (!f && Pl) { wE(u, e); let y = SE(u); c = y.MeasureLayout, d.visualElement = hE(i, m, u, t, y.ProjectionNode) } return ce(Fs.Provider, { value: d, children: [c && d.visualElement ? k(c, { visualElement: d.visualElement, ...u }) : null, n(i, a, gE(m, d.visualElement, l), m, f, d.visualElement)] }) } let s = Ve(o); return s[Xf] = i, s } function xE({ layoutId: e }) { let t = V(Es).id; return t && e !== void 0 ? t + "-" + e : e } function wE(e, t) { let n = V(dy).strict } function SE(e) { let { drag: t, layout: n } = ho; if (!t && !n) return {}; let r = { ...t, ...n }; return { MeasureLayout: t?.isEnabled(e) || n?.isEnabled(e) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } var wl = {}; function Yf(e) { Object.assign(wl, e) } var Oe = e => !!(e && e.getVelocity), wr = (e, t, n) => n > t ? t : n < e ? e : n, xs = e => Math.round(e * 1e5) / 1e5, Kf = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, kE = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, CE = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function Is(e) { return typeof e == "string" } function TE(e) { return e == null } var Ls = e => ({ test: t => Is(t) && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), jr = Ls("deg"), Xn = Ls("%"), X = Ls("px"), EE = Ls("vh"), RE = Ls("vw"), jg = { ...Xn, parse: e => Xn.parse(e) / 100, transform: e => Xn.transform(e * 100) }, Ms = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], qr = new Set(Ms), vy = (e, t) => t && typeof e == "number" ? t.transform(e) : e, yo = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, ws = { ...yo, transform: e => wr(0, 1, e) }, hl = { ...yo, default: 1 }, Wg = { ...yo, transform: Math.round }, Qf = { borderWidth: X, borderTopWidth: X, borderRightWidth: X, borderBottomWidth: X, borderLeftWidth: X, borderRadius: X, radius: X, borderTopLeftRadius: X, borderTopRightRadius: X, borderBottomRightRadius: X, borderBottomLeftRadius: X, width: X, maxWidth: X, height: X, maxHeight: X, size: X, top: X, right: X, bottom: X, left: X, padding: X, paddingTop: X, paddingRight: X, paddingBottom: X, paddingLeft: X, margin: X, marginTop: X, marginRight: X, marginBottom: X, marginLeft: X, rotate: jr, rotateX: jr, rotateY: jr, rotateZ: jr, scale: hl, scaleX: hl, scaleY: hl, scaleZ: hl, skew: jr, skewX: jr, skewY: jr, distance: X, translateX: X, translateY: X, translateZ: X, x: X, y: X, z: X, perspective: X, transformPerspective: X, opacity: ws, originX: jg, originY: jg, originZ: X, zIndex: Wg, backgroundPositionX: X, backgroundPositionY: X, fillOpacity: ws, strokeOpacity: ws, numOctaves: Wg }, PE = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, _E = Ms.length; function yy(e, t, n) { let r = "", i = !0; for (let o = 0; o < _E; o++) { let s = Ms[o], a = e[s]; if (a === void 0) continue; let l = !0; if (typeof a == "number" ? l = a === (s.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) { let c = vy(a, Qf[s]); if (!l) { i = !1; let u = PE[s] || s; r += `${u}(${c}) ` } n && (t[s] = c) } } return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r } var FE = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function po(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || FE.has(e) } var by = e => !po(e); function xy(e) { e && (by = t => t.startsWith("on") ? !po(t) : e(t)) } try { xy(cE().default) } catch { } function wy(e, t, n) { let r = {}; for (let i in e) i === "values" && typeof e.values == "object" || (by(i) || n === !0 && po(i) || !t && !po(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]); return r } var kf = e => Array.isArray(e), IE = e => !!(e && typeof e == "object" && e.mix && e.toValue), LE = e => kf(e) ? e[e.length - 1] || 0 : e; function Tt(e) { let t = Oe(e) ? e.get() : e; return IE(t) ? t.toValue() : t } function Ug(e) { let t = [{}, {}]; return e?.values.forEach((n, r) => { t[0][r] = n.get(), t[1][r] = n.getVelocity() }), t } function Zf(e, t, n, r) { if (typeof t == "function") { let [i, o] = Ug(r); t = t(n !== void 0 ? n : e.custom, i, o) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { let [i, o] = Ug(r); t = t(n !== void 0 ? n : e.custom, i, o) } return t } function Jn(e) { let t = A(null); return t.current === null && (t.current = e()), t.current } var Sy = new Set(["opacity", "clipPath", "filter", "transform"]); function ky(e) { if (qr.has(e)) return "transform"; if (Sy.has(e)) return _l(e) } function Ol(e, t) { e.indexOf(t) === -1 && e.push(t) } function Os(e, t) { let n = e.indexOf(t); n > -1 && e.splice(n, 1) } function ME([...e], t, n) { let r = t < 0 ? e.length + t : t; if (r >= 0 && r < e.length) { let i = n < 0 ? e.length + n : n, [o] = e.splice(t, 1); e.splice(i, 0, o) } return e } function OE({ applyWillChange: e = !1, scrapeMotionValuesFromProps: t, createRenderState: n, onMount: r }, i, o, s, a) { let l = { latestValues: AE(i, o, s, a ? !1 : e, t), renderState: n() }; return r && (l.mount = c => r(i, c, l)), l } var Dl = e => (t, n) => { let r = V(Fs), i = V(go), o = () => OE(e, t, r, i, n); return n ? o() : Jn(o) }; function DE(e, t) { let n = ky(t); n && Ol(e, n) } function Gg(e, t, n) { let r = Array.isArray(t) ? t : [t]; for (let i = 0; i < r.length; i++) { let o = Zf(e, r[i]); if (o) { let { transitionEnd: s, transition: a, ...l } = o; n(l, s) } } } function AE(e, t, n, r, i) { var o; let s = {}, a = [], l = r && ((o = e.style) === null || o === void 0 ? void 0 : o.willChange) === void 0, c = i(e, {}); for (let b in c) s[b] = Tt(c[b]); let { initial: u, animate: f } = e, d = Ml(e), m = my(e); t && m && !d && e.inherit !== !1 && (u === void 0 && (u = t.initial), f === void 0 && (f = t.animate)); let y = n ? n.initial === !1 : !1; y = y || u === !1; let g = y ? f : u; return g && typeof g != "boolean" && !Ps(g) && Gg(e, g, (b, h) => { for (let p in b) { let v = b[p]; if (Array.isArray(v)) { let w = y ? v.length - 1 : 0; v = v[w] } v !== null && (s[p] = v) } for (let p in h) s[p] = h[p] }), l && (f && u !== !1 && !Ps(f) && Gg(e, f, b => { for (let h in b) DE(a, h) }), a.length && (s.willChange = a.join(","))), s } var { schedule: Y, cancel: Ht, state: We, steps: gl } = hy(typeof requestAnimationFrame < "u" ? requestAnimationFrame : gt, !0), Cy = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1; function Al(e, t = "page") { return { point: { x: e[`${t}X`], y: e[`${t}Y`] } } } var Ty = e => t => Cy(t) && e(t, Al(t)); function yr(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } function Yn(e, t, n, r) { return yr(e, t, Ty(n), r) } var VE = (e, t) => n => t(e(n)), Kn = (...e) => e.reduce(VE); function Ey(e) { let t = null; return () => { let n = () => { t = null }; return t === null ? (t = e, n) : !1 } } var qg = Ey("dragHorizontal"), Xg = Ey("dragVertical"); function Ry(e) { let t = !1; if (e === "y") t = Xg(); else if (e === "x") t = qg(); else { let n = qg(), r = Xg(); n && r ? t = () => { n(), r() } : (n && n(), r && r()) } return t } function Jf() { let e = Ry(!0); return e ? (e(), !1) : !0 } var ed = (e, t) => n => !!(Is(n) && CE.test(n) && n.startsWith(e) || t && !TE(n) && Object.prototype.hasOwnProperty.call(n, t)), Py = (e, t, n) => r => { if (!Is(r)) return r; let [i, o, s, a] = r.match(Kf); return { [e]: parseFloat(i), [t]: parseFloat(o), [n]: parseFloat(s), alpha: a !== void 0 ? parseFloat(a) : 1 } }, BE = e => wr(0, 255, e), ff = { ...yo, transform: e => Math.round(BE(e)) }, _i = { test: ed("rgb", "red"), parse: Py("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + ff.transform(e) + ", " + ff.transform(t) + ", " + ff.transform(n) + ", " + xs(ws.transform(r)) + ")" }; function zE(e) { let t = "", n = "", r = "", i = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } var Cf = { test: ed("#"), parse: zE, transform: _i.transform }, lo = { test: ed("hsl", "hue"), parse: Py("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Xn.transform(xs(t)) + ", " + Xn.transform(xs(n)) + ", " + xs(ws.transform(r)) + ")" }, mt = { test: e => _i.test(e) || Cf.test(e) || lo.test(e), parse: e => _i.test(e) ? _i.parse(e) : lo.test(e) ? lo.parse(e) : Cf.parse(e), transform: e => Is(e) ? e : e.hasOwnProperty("red") ? _i.transform(e) : lo.transform(e) }; function $E(e) { var t, n; return isNaN(e) && Is(e) && (((t = e.match(Kf)) === null || t === void 0 ? void 0 : t.length) || 0) + (((n = e.match(kE)) === null || n === void 0 ? void 0 : n.length) || 0) > 0 } var _y = "number", Fy = "color", NE = "var", HE = "var(", Yg = "${}", jE = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function _s(e) { let t = e.toString(), n = [], r = { color: [], number: [], var: [] }, i = [], o = 0, a = t.replace(jE, l => (mt.test(l) ? (r.color.push(o), i.push(Fy), n.push(mt.parse(l))) : l.startsWith(HE) ? (r.var.push(o), i.push(NE), n.push(l)) : (r.number.push(o), i.push(_y), n.push(parseFloat(l))), ++o, Yg)).split(Yg); return { values: n, split: a, indexes: r, types: i } } function Iy(e) { return _s(e).values } function Ly(e) { let { split: t, types: n } = _s(e), r = t.length; return i => { let o = ""; for (let s = 0; s < r; s++)if (o += t[s], i[s] !== void 0) { let a = n[s]; a === _y ? o += xs(i[s]) : a === Fy ? o += mt.transform(i[s]) : o += i[s] } return o } } var WE = e => typeof e == "number" ? 0 : e; function UE(e) { let t = Iy(e); return Ly(e)(t.map(WE)) } var Sr = { test: $E, parse: Iy, createTransformer: Ly, getAnimatableNone: UE }, Fn = e => e * 1e3, Qn = e => e / 1e3; function td(e, t) { return t ? e * (1e3 / t) : 0 } var GE = 5; function My(e, t, n) { let r = Math.max(t - GE, 0); return td(n - e(r), t - r) } var df = .001, qE = .01, Kg = 10, XE = .05, YE = 1; function KE({ duration: e = 800, bounce: t = .25, velocity: n = 0, mass: r = 1 }) { let i, o; vo(e <= Fn(Kg), "Spring duration must be 10 seconds or less"); let s = 1 - t; s = wr(XE, YE, s), e = wr(qE, Kg, Qn(e)), s < 1 ? (i = c => { let u = c * s, f = u * e, d = u - n, m = Tf(c, s), y = Math.exp(-f); return df - d / m * y }, o = c => { let f = c * s * e, d = f * n + n, m = Math.pow(s, 2) * Math.pow(c, 2) * e, y = Math.exp(-f), g = Tf(Math.pow(c, 2), s); return (-i(c) + df > 0 ? -1 : 1) * ((d - m) * y) / g }) : (i = c => { let u = Math.exp(-c * e), f = (c - n) * e + 1; return -df + u * f }, o = c => { let u = Math.exp(-c * e), f = (n - c) * (e * e); return u * f }); let a = 5 / e, l = ZE(i, o, a); if (e = Fn(e), isNaN(l)) return { stiffness: 100, damping: 10, duration: e }; { let c = Math.pow(l, 2) * r; return { stiffness: c, damping: s * 2 * Math.sqrt(r * c), duration: e } } } var QE = 12; function ZE(e, t, n) { let r = n; for (let i = 1; i < QE; i++)r = r - e(r) / t(r); return r } function Tf(e, t) { return e * Math.sqrt(1 - t * t) } var JE = ["duration", "bounce"], eR = ["stiffness", "damping", "mass"]; function Qg(e, t) { return t.some(n => e[n] !== void 0) } function tR(e) { let t = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...e }; if (!Qg(e, eR) && Qg(e, JE)) { let n = KE(e); t = { ...t, ...n, mass: 1 }, t.isResolvedFromDuration = !0 } return t } function Ds({ keyframes: e, restDelta: t, restSpeed: n, ...r }) { let i = e[0], o = e[e.length - 1], s = { done: !1, value: i }, { stiffness: a, damping: l, mass: c, duration: u, velocity: f, isResolvedFromDuration: d } = tR({ ...r, velocity: -Qn(r.velocity || 0) }), m = f || 0, y = l / (2 * Math.sqrt(a * c)), g = o - i, b = Qn(Math.sqrt(a / c)), h = Math.abs(g) < 5; n || (n = h ? .01 : 2), t || (t = h ? .005 : .5); let p; if (y < 1) { let v = Tf(b, y); p = w => { let C = Math.exp(-y * b * w); return o - C * ((m + y * b * g) / v * Math.sin(v * w) + g * Math.cos(v * w)) } } else if (y === 1) p = v => o - Math.exp(-b * v) * (g + (m + b * g) * v); else { let v = b * Math.sqrt(y * y - 1); p = w => { let C = Math.exp(-y * b * w), S = Math.min(v * w, 300); return o - C * ((m + y * b * g) * Math.sinh(S) + v * g * Math.cosh(S)) / v } } return { calculatedDuration: d && u || null, next: v => { let w = p(v); if (d) s.done = v >= u; else { let C = 0; y < 1 && (C = v === 0 ? Fn(m) : My(p, v, w)); let S = Math.abs(C) <= n, R = Math.abs(o - w) <= t; s.done = S && R } return s.value = s.done ? o : w, s } } } var Oy = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, nR = 1e-7, rR = 12; function iR(e, t, n, r, i) { let o, s, a = 0; do s = t + (n - t) / 2, o = Oy(s, r, i) - e, o > 0 ? n = s : t = s; while (Math.abs(o) > nR && ++a < rR); return s } function bo(e, t, n, r) { if (e === t && n === r) return gt; let i = o => iR(o, 0, 1, e, n); return o => o === 0 || o === 1 ? o : Oy(i(o), t, r) } var Dy = bo(.42, 0, 1, 1), Ay = bo(0, 0, .58, 1), nd = bo(.42, 0, .58, 1), rd = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, id = e => t => 1 - e(1 - t), Vl = e => 1 - Math.sin(Math.acos(e)), od = id(Vl), Vy = rd(Vl), sd = bo(.33, 1.53, .69, .99), Bl = id(sd), By = rd(Bl), zy = e => (e *= 2) < 1 ? .5 * Bl(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), Ur = (e, t, n) => { let r = t - e; return r === 0 ? 1 : (n - e) / r }, Fe = (e, t, n) => e + (t - e) * n; function hf(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function oR({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let i = 0, o = 0, s = 0; if (!t) i = o = s = n; else { let a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; i = hf(l, a, e + 1 / 3), o = hf(l, a, e), s = hf(l, a, e - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(o * 255), blue: Math.round(s * 255), alpha: r } } function Sl(e, t) { return n => n > 0 ? t : e } var pf = (e, t, n) => { let r = e * e, i = n * (t * t - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, sR = [Cf, _i, lo], aR = e => sR.find(t => t.test(e)); function Zg(e) { let t = aR(e); if (vo(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`), !t) return !1; let n = t.parse(e); return t === lo && (n = oR(n)), n } var Jg = (e, t) => { let n = Zg(e), r = Zg(t); if (!n || !r) return Sl(e, t); let i = { ...n }; return o => (i.red = pf(n.red, r.red, o), i.green = pf(n.green, r.green, o), i.blue = pf(n.blue, r.blue, o), i.alpha = Fe(n.alpha, r.alpha, o), _i.transform(i)) }, $y = e => t => typeof t == "string" && t.startsWith(e), Ny = $y("--"), lR = $y("var(--"), ad = e => lR(e) ? cR.test(e.split("/*")[0].trim()) : !1, cR = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Ef = new Set(["none", "hidden"]); function uR(e, t) { return Ef.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e } function fR(e, t) { return n => Fe(e, t, n) } function ld(e) { return typeof e == "number" ? fR : typeof e == "string" ? ad(e) ? Sl : mt.test(e) ? Jg : pR : Array.isArray(e) ? Hy : typeof e == "object" ? mt.test(e) ? Jg : dR : Sl } function Hy(e, t) { let n = [...e], r = n.length, i = e.map((o, s) => ld(o)(o, t[s])); return o => { for (let s = 0; s < r; s++)n[s] = i[s](o); return n } } function dR(e, t) { let n = { ...e, ...t }, r = {}; for (let i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = ld(e[i])(e[i], t[i])); return i => { for (let o in r) n[o] = r[o](i); return n } } function hR(e, t) { var n; let r = [], i = { color: 0, var: 0, number: 0 }; for (let o = 0; o < t.values.length; o++) { let s = t.types[o], a = e.indexes[s][i[s]], l = (n = e.values[a]) !== null && n !== void 0 ? n : 0; r[o] = l, i[s]++ } return r } var pR = (e, t) => { let n = Sr.createTransformer(t), r = _s(e), i = _s(t); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Ef.has(e) && !i.values.length || Ef.has(t) && !r.values.length ? uR(e, t) : Kn(Hy(hR(r, i), i.values), n) : (vo(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), Sl(e, t)) }; function cd(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? Fe(e, t, n) : ld(e)(e, t) } function mR(e, t, n) { let r = [], i = n || cd, o = e.length - 1; for (let s = 0; s < o; s++) { let a = i(e[s], e[s + 1]); if (t) { let l = Array.isArray(t) ? t[s] || gt : t; a = Kn(l, a) } r.push(a) } return r } function xo(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) { let o = e.length; if (Jt(o === t.length, "Both input and output ranges must be the same length"), o === 1) return () => t[0]; if (o === 2 && e[0] === e[1]) return () => t[1]; e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse()); let s = mR(t, r, i), a = s.length, l = c => { let u = 0; if (a > 1) for (; u < e.length - 2 && !(c < e[u + 1]); u++); let f = Ur(e[u], e[u + 1], c); return s[u](f) }; return n ? c => l(wr(e[0], e[o - 1], c)) : l } var gR = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), ev = e => e === yo || e === X, tv = (e, t) => parseFloat(e.split(", ")[t]), nv = (e, t) => (n, { transform: r }) => { if (r === "none" || !r) return 0; let i = r.match(/^matrix3d\((.+)\)$/u); if (i) return tv(i[1], t); { let o = r.match(/^matrix\((.+)\)$/u); return o ? tv(o[1], e) : 0 } }, vR = new Set(["x", "y", "z"]), yR = Ms.filter(e => !vR.has(e)); function bR(e) { let t = []; return yR.forEach(n => { let r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } var mo = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: nv(4, 13), y: nv(5, 14) }; mo.translateX = mo.x; mo.translateY = mo.y; var Fi = new Set, Rf = !1, Pf = !1; function jy() { if (Pf) { let e = Array.from(Fi).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { let i = bR(r); i.length && (n.set(r, i), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); let i = n.get(r); i && i.forEach(([o, s]) => { var a; (a = r.getValue(o)) === null || a === void 0 || a.set(s) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && I.scrollTo(0, r.suspendedScrollY) }) } Pf = !1, Rf = !1, Fi.forEach(e => e.complete()), Fi.clear() } function Wy() { Fi.forEach(e => { e.readKeyframes(), e.needsMeasurement && (Pf = !0) }) } function xR() { Wy(), jy() } var ud = class { constructor(e, t, n, r, i, o = !1) { this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = n, this.motionValue = r, this.element = i, this.isAsync = o } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (Fi.add(this), Rf || (Rf = !0, Y.read(Wy), Y.resolveKeyframes(jy))) : (this.readKeyframes(), this.complete()) } readKeyframes() { let { unresolvedKeyframes: e, name: t, element: n, motionValue: r } = this; for (let i = 0; i < e.length; i++)if (e[i] === null) if (i === 0) { let o = r?.get(), s = e[e.length - 1]; if (o !== void 0) e[0] = o; else if (n && t) { let a = n.readValue(t, s); a != null && (e[0] = a) } e[0] === void 0 && (e[0] = s), r && o === void 0 && r.set(e[0]) } else e[i] = e[i - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Fi.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, Fi.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } }; function rv({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: l, restDelta: c = .5, restSpeed: u }) { let f = e[0], d = { done: !1, value: f }, m = E => a !== void 0 && E < a || l !== void 0 && E > l, y = E => a === void 0 ? l : l === void 0 || Math.abs(a - E) < Math.abs(l - E) ? a : l, g = n * t, b = f + g, h = s === void 0 ? b : s(b); h !== b && (g = h - f); let p = E => -g * Math.exp(-E / r), v = E => h + p(E), w = E => { let L = p(E), F = v(E); d.done = Math.abs(L) <= c, d.value = d.done ? h : F }, C, S, R = E => { m(d.value) && (C = E, S = Ds({ keyframes: [d.value, y(d.value)], velocity: My(v, E, d.value), damping: i, stiffness: o, restDelta: c, restSpeed: u })) }; return R(0), { calculatedDuration: null, next: E => { let L = !1; return !S && C === void 0 && (L = !0, w(E), R(E)), C !== void 0 && E >= C ? S.next(E - C) : (!L && w(E), d) } } } var Uy = e => Array.isArray(e) && typeof e[0] != "number", iv = { linear: gt, easeIn: Dy, easeInOut: nd, easeOut: Ay, circIn: Vl, circInOut: Vy, circOut: od, backIn: Bl, backInOut: By, backOut: sd, anticipate: zy }, _f = e => { if (Array.isArray(e)) { Jt(e.length === 4, "Cubic bezier arrays must contain four numerical values."); let [t, n, r, i] = e; return bo(t, n, r, i) } else if (typeof e == "string") return Jt(iv[e] !== void 0, `Invalid easing type '${e}'`), iv[e]; return e }; function Gy(e, t) { let n = e[e.length - 1]; for (let r = 1; r <= t; r++) { let i = Ur(0, t, r); e.push(Fe(n, 1, i)) } } function fd(e) { let t = [0]; return Gy(t, e.length - 1), t } function wR(e, t) { return e.map(n => n * t) } function SR(e, t) { return e.map(() => t || nd).splice(0, e.length - 1) } function kl({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { let i = Uy(r) ? r.map(_f) : _f(r), o = { done: !1, value: t[0] }, s = wR(n && n.length === t.length ? n : fd(t), e), a = xo(s, t, { ease: Array.isArray(i) ? i : SR(t, i) }); return { calculatedDuration: e, next: l => (o.value = a(l), o.done = l >= e, o) } } var vl; function kR() { vl = void 0 } var br = { now: () => (vl === void 0 && br.set(We.isProcessing || Il.useManualTiming ? We.timestamp : performance.now()), vl), set: e => { vl = e, queueMicrotask(kR) } }, Cl = { current: !1 }, ov = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (Sr.test(e) || e === "0") && !e.startsWith("url(")); function CR(e) { let t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function TR(e, t, n, r) { let i = e[0]; if (i === null) return !1; if (t === "display" || t === "visibility") return !0; let o = e[e.length - 1], s = ov(i, t), a = ov(o, t); return vo(s === a, `You are trying to animate ${t} from "${i}" to "${o}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${o} via the \`style\` property.`), !s || !a ? !1 : CR(e) || n === "spring" && r } var ER = e => e !== null; function zl(e, { repeat: t, repeatType: n = "loop" }, r) { let i = e.filter(ER), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1; return !o || r === void 0 ? i[o] : r } var RR = 40, qy = class { constructor({ autoplay: e = !0, delay: t = 0, type: n = "keyframes", repeat: r = 0, repeatDelay: i = 0, repeatType: o = "loop", ...s }) { this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = br.now(), this.options = { autoplay: e, delay: t, type: n, repeat: r, repeatDelay: i, repeatType: o, ...s }, this.updateFinishedPromise() } calcStartTime() { return this.resolvedAt ? this.resolvedAt - this.createdAt > RR ? this.resolvedAt : this.createdAt : this.createdAt } get resolved() { return !this._resolved && !this.hasAttemptedResolve && xR(), this._resolved } onKeyframesResolved(e, t) { this.resolvedAt = br.now(), this.hasAttemptedResolve = !0; let { name: n, type: r, velocity: i, delay: o, onComplete: s, onUpdate: a, isGenerator: l } = this.options; if (!l && !TR(e, n, r, i)) if (Cl.current || !o) { a?.(zl(e, this.options, t)), s?.(), this.resolveFinishedPromise(); return } else this.options.duration = 0; let c = this.initPlayback(e, t); c !== !1 && (this._resolved = { keyframes: e, finalKeyframe: t, ...c }, this.onPostResolved()) } onPostResolved() { } then(e, t) { return this.currentFinishedPromise.then(e, t) } updateFinishedPromise() { this.currentFinishedPromise = new Promise(e => { this.resolveFinishedPromise = e }) } }, Ff = 2e4; function Xy(e) { let t = 0, n = 50, r = e.next(t); for (; !r.done && t < Ff;)t += n, r = e.next(t); return t >= Ff ? 1 / 0 : t } var PR = e => { let t = ({ timestamp: n }) => e(n); return { start: () => Y.update(t, !0), stop: () => Ht(t), now: () => We.isProcessing ? We.timestamp : br.now() } }, _R = { decay: rv, inertia: rv, tween: kl, keyframes: kl, spring: Ds }, FR = e => e / 100, $l = class extends qy { constructor(e) { super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.teardown(); let { onStop: a } = this.options; a && a() }; let { name: t, motionValue: n, element: r, keyframes: i } = this.options, o = r?.KeyframeResolver || ud, s = (a, l) => this.onKeyframesResolved(a, l); this.resolver = new o(i, s, t, n, r), this.resolver.scheduleResolve() } initPlayback(e) { let { type: t = "keyframes", repeat: n = 0, repeatDelay: r = 0, repeatType: i, velocity: o = 0 } = this.options, s = _R[t] || kl, a, l; s !== kl && typeof e[0] != "number" && (a = Kn(FR, cd(e[0], e[1])), e = [0, 100]); let c = s({ ...this.options, keyframes: e }); i === "mirror" && (l = s({ ...this.options, keyframes: [...e].reverse(), velocity: -o })), c.calculatedDuration === null && (c.calculatedDuration = Xy(c)); let { calculatedDuration: u } = c, f = u + r, d = f * (n + 1) - r; return { generator: c, mirroredGenerator: l, mapPercentToKeyframes: a, calculatedDuration: u, resolvedDuration: f, totalDuration: d } } onPostResolved() { let { autoplay: e = !0 } = this.options; this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState } tick(e, t = !1) { let { resolved: n } = this; if (!n) { let { keyframes: R } = this.options; return { done: !0, value: R[R.length - 1] } } let { finalKeyframe: r, generator: i, mirroredGenerator: o, mapPercentToKeyframes: s, keyframes: a, calculatedDuration: l, totalDuration: c, resolvedDuration: u } = n; if (this.startTime === null) return i.next(0); let { delay: f, repeat: d, repeatType: m, repeatDelay: y, onUpdate: g } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - c / this.speed, this.startTime)), t ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed; let b = this.currentTime - f * (this.speed >= 0 ? 1 : -1), h = this.speed >= 0 ? b < 0 : b > c; this.currentTime = Math.max(b, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = c); let p = this.currentTime, v = i; if (d) { let R = Math.min(this.currentTime, c) / u, E = Math.floor(R), L = R % 1; !L && R >= 1 && (L = 1), L === 1 && E--, E = Math.min(E, d + 1), !!(E % 2) && (m === "reverse" ? (L = 1 - L, y && (L -= y / u)) : m === "mirror" && (v = o)), p = wr(0, 1, L) * u } let w = h ? { done: !1, value: a[0] } : v.next(p); s && (w.value = s(w.value)); let { done: C } = w; !h && l !== null && (C = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0); let S = this.holdTime === null && (this.state === "finished" || this.state === "running" && C); return S && r !== void 0 && (w.value = zl(a, this.options, r)), g && g(w.value), S && this.finish(), w } get duration() { let { resolved: e } = this; return e ? Qn(e.calculatedDuration) : 0 } get time() { return Qn(this.currentTime) } set time(e) { e = Fn(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed) } get speed() { return this.playbackSpeed } set speed(e) { let t = this.playbackSpeed !== e; this.playbackSpeed = e, t && (this.time = Qn(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) { this.pendingPlayState = "running"; return } if (this.isStopped) return; let { driver: e = PR, onPlay: t, startTime: n } = this.options; this.driver || (this.driver = e(i => this.tick(i))), t && t(); let r = this.driver.now(); this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = r) : this.startTime = n ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var e; if (!this._resolved) { this.pendingPlayState = "paused"; return } this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0 } complete() { this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; let { onComplete: e } = this.options; e && e() } cancel() { this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } }; function dd(e) { return new $l(e) } var Yy = e => /^0[^.\s]+$/u.test(e); function IR(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Yy(e) : !0 } var Ky = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), LR = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function MR(e) { let t = LR.exec(e); if (!t) return [,]; let [, n, r, i] = t; return [`--${n ?? r}`, i] } var OR = 4; function Qy(e, t, n = 1) { Jt(n <= OR, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`); let [r, i] = MR(e); if (!r) return; let o = I.getComputedStyle(t).getPropertyValue(r); if (o) { let s = o.trim(); return Ky(s) ? parseFloat(s) : s } return ad(i) ? Qy(i, t, n + 1) : i } var Zy = e => t => t.test(e), DR = { test: e => e === "auto", parse: e => e }, Jy = [yo, X, Xn, jr, RE, EE, DR], sv = e => Jy.find(Zy(e)), AR = new Set(["brightness", "contrast", "saturate", "opacity"]); function VR(e) { let [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; let [r] = n.match(Kf) || []; if (!r) return e; let i = n.replace(r, ""), o = AR.has(t) ? 1 : 0; return r !== n && (o *= 100), t + "(" + o + i + ")" } var BR = /\b([a-z-]*)\(.*?\)/gu, If = { ...Sr, getAnimatableNone: e => { let t = e.match(BR); return t ? t.map(VR).join(" ") : e } }, zR = { ...Qf, color: mt, backgroundColor: mt, outlineColor: mt, fill: mt, stroke: mt, borderColor: mt, borderTopColor: mt, borderRightColor: mt, borderBottomColor: mt, borderLeftColor: mt, filter: If, WebkitFilter: If }, hd = e => zR[e]; function e0(e, t) { let n = hd(e); return n !== If && (n = Sr), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } var $R = new Set(["auto", "none", "0"]); function NR(e, t, n) { let r = 0, i; for (; r < e.length && !i;) { let o = e[r]; typeof o == "string" && !$R.has(o) && _s(o).values.length && (i = e[r]), r++ } if (i && n) for (let o of t) e[o] = e0(n, i) } var t0 = class extends ud { constructor(e, t, n, r, i) { super(e, t, n, r, i, !0) } readKeyframes() { let { unresolvedKeyframes: e, element: t, name: n } = this; if (!t || !t.current) return; super.readKeyframes(); for (let a = 0; a < e.length; a++) { let l = e[a]; if (typeof l == "string" && (l = l.trim(), ad(l))) { let c = Qy(l, t.current); c !== void 0 && (e[a] = c), a === e.length - 1 && (this.finalKeyframe = l) } } if (this.resolveNoneKeyframes(), !gR.has(n) || e.length !== 2) return; let [r, i] = e, o = sv(r), s = sv(i); if (o !== s) if (ev(o) && ev(s)) for (let a = 0; a < e.length; a++) { let l = e[a]; typeof l == "string" && (e[a] = parseFloat(l)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { let { unresolvedKeyframes: e, name: t } = this, n = []; for (let r = 0; r < e.length; r++)IR(e[r]) && n.push(r); n.length && NR(e, n, t) } measureInitialState() { let { element: e, unresolvedKeyframes: t, name: n } = this; if (!e || !e.current) return; n === "height" && (this.suspendedScrollY = I.pageYOffset), this.measuredOrigin = mo[n](e.measureViewportBox(), I.getComputedStyle(e.current)), t[0] = this.measuredOrigin; let r = t[t.length - 1]; r !== void 0 && e.getValue(n, r).jump(r, !1) } measureEndState() { var e; let { element: t, name: n, unresolvedKeyframes: r } = this; if (!t || !t.current) return; let i = t.getValue(n); i && i.jump(this.measuredOrigin, !1); let o = r.length - 1, s = r[o]; r[o] = mo[n](t.measureViewportBox(), I.getComputedStyle(t.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([a, l]) => { t.getValue(a).set(l) }), this.resolveNoneKeyframes() } }; function n0(e) { let t; return () => (t === void 0 && (t = e()), t) } var r0 = e => Array.isArray(e) && typeof e[0] == "number"; function i0(e) { return !!(!e || typeof e == "string" && e in pd || r0(e) || Array.isArray(e) && e.every(i0)) } var ys = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, pd = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: ys([0, .65, .55, 1]), circOut: ys([.55, 0, 1, .45]), backIn: ys([.31, .01, .66, -.59]), backOut: ys([.33, 1.53, .69, .99]) }; function HR(e) { return o0(e) || pd.easeOut } function o0(e) { if (e) return r0(e) ? ys(e) : Array.isArray(e) ? e.map(HR) : pd[e] } function jR(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a, times: l } = {}) { let c = { [t]: n }; l && (c.offset = l); let u = o0(a); return Array.isArray(u) && (c.easing = u), e.animate(c, { delay: r, duration: i, easing: Array.isArray(u) ? "linear" : u, fill: "both", iterations: o + 1, direction: s === "reverse" ? "alternate" : "normal" }) } var WR = n0(() => Object.hasOwnProperty.call(Element.prototype, "animate")), Tl = 10, UR = 2e4; function GR(e) { return e.type === "spring" || !i0(e.ease) } function qR(e, t) { let n = new $l({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }), r = { done: !1, value: e[0] }, i = [], o = 0; for (; !r.done && o < UR;)r = n.sample(o), i.push(r.value), o += Tl; return { times: void 0, keyframes: i, duration: o - Tl, ease: "linear" } } var Lf = class extends qy { constructor(e) { super(e); let { name: t, motionValue: n, element: r, keyframes: i } = this.options; this.resolver = new t0(i, (o, s) => this.onKeyframesResolved(o, s), t, n, r), this.resolver.scheduleResolve() } initPlayback(e, t) { var n; let { duration: r = 300, times: i, ease: o, type: s, motionValue: a, name: l, startTime: c } = this.options; if (!(!((n = a.owner) === null || n === void 0) && n.current)) return !1; if (GR(this.options)) { let { onComplete: f, onUpdate: d, motionValue: m, element: y, ...g } = this.options, b = qR(e, g); e = b.keyframes, e.length === 1 && (e[1] = e[0]), r = b.duration, i = b.times, o = b.ease, s = "keyframes" } let u = jR(a.owner.current, l, e, { ...this.options, duration: r, times: i, ease: o }); return u.startTime = c ?? this.calcStartTime(), this.pendingTimeline ? (u.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : u.onfinish = () => { let { onComplete: f } = this.options; a.set(zl(e, this.options, t)), f && f(), this.cancel(), this.resolveFinishedPromise() }, { animation: u, duration: r, times: i, type: s, ease: o, keyframes: e } } get duration() { let { resolved: e } = this; if (!e) return 0; let { duration: t } = e; return Qn(t) } get time() { let { resolved: e } = this; if (!e) return 0; let { animation: t } = e; return Qn(t.currentTime || 0) } set time(e) { let { resolved: t } = this; if (!t) return; let { animation: n } = t; n.currentTime = Fn(e) } get speed() { let { resolved: e } = this; if (!e) return 1; let { animation: t } = e; return t.playbackRate } set speed(e) { let { resolved: t } = this; if (!t) return; let { animation: n } = t; n.playbackRate = e } get state() { let { resolved: e } = this; if (!e) return "idle"; let { animation: t } = e; return t.playState } get startTime() { let { resolved: e } = this; if (!e) return null; let { animation: t } = e; return t.startTime } attachTimeline(e) { if (!this._resolved) this.pendingTimeline = e; else { let { resolved: t } = this; if (!t) return gt; let { animation: n } = t; n.timeline = e, n.onfinish = null } return gt } play() { if (this.isStopped) return; let { resolved: e } = this; if (!e) return; let { animation: t } = e; t.playState === "finished" && this.updateFinishedPromise(), t.play() } pause() { let { resolved: e } = this; if (!e) return; let { animation: t } = e; t.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return; this.resolveFinishedPromise(), this.updateFinishedPromise(); let { resolved: e } = this; if (!e) return; let { animation: t, keyframes: n, duration: r, type: i, ease: o, times: s } = e; if (t.playState === "idle" || t.playState === "finished") return; if (this.time) { let { motionValue: l, onUpdate: c, onComplete: u, element: f, ...d } = this.options, m = new $l({ ...d, keyframes: n, duration: r, type: i, ease: o, times: s, isGenerator: !0 }), y = Fn(this.time); l.setWithVelocity(m.sample(y - Tl).value, m.sample(y).value, Tl) } let { onStop: a } = this.options; a && a(), this.cancel() } complete() { let { resolved: e } = this; e && e.animation.finish() } cancel() { let { resolved: e } = this; e && e.animation.cancel() } static supports(e) { let { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s } = e; return WR() && n && Sy.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !r && i !== "mirror" && o !== 0 && s !== "inertia" } }, md = class { constructor() { this.subscriptions = [] } add(e) { return Ol(this.subscriptions, e), () => Os(this.subscriptions, e) } notify(e, t, n) { let r = this.subscriptions.length; if (r) if (r === 1) this.subscriptions[0](e, t, n); else for (let i = 0; i < r; i++) { let o = this.subscriptions[i]; o && o(e, t, n) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } }, av = 30, XR = e => !isNaN(parseFloat(e)), Ss = { current: void 0 }, As = class { constructor(e, t = {}) { this.version = "11.3.29", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, r = !0) => { let i = br.now(); this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), r && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.hasAnimated = !1, this.setCurrent(e), this.owner = t.owner } setCurrent(e) { this.current = e, this.updatedAt = br.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = XR(this.current)) } setPrevFrameValue(e = this.current) { this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, t) { this.events[e] || (this.events[e] = new md); let n = this.events[e].add(t); return e === "change" ? () => { n(), Y.read(() => { this.events.change.getSize() || this.stop() }) } : n } clearListeners() { for (let e in this.events) this.events[e].clear() } attach(e, t) { this.passiveEffect = e, this.stopPassiveEffect = t } set(e, t = !0) { !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, t, n) { this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n } jump(e, t = !0) { this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return Ss.current && Ss.current.push(this), this.current } getPrevious() { return this.prev } getVelocity() { let e = br.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > av) return 0; let t = Math.min(this.updatedAt - this.prevUpdatedAt, av); return td(parseFloat(this.current) - parseFloat(this.prevFrameValue), t) } start(e) { return this.stop(), new Promise(t => { this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } }; function Ue(e, t) { return new As(e, t) } function Nl(e, t, n) { let r = e.getProps(); return Zf(r, t, n !== void 0 ? n : r.custom, e) } var YR = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, KR = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), QR = { type: "keyframes", duration: .8 }, ZR = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, JR = (e, { keyframes: t }) => t.length > 2 ? QR : qr.has(e) ? e.startsWith("scale") ? KR(t[1]) : YR : ZR; function eP({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: c, ...u }) { return !!Object.keys(u).length } function gd(e, t) { return e[t] || e.default || e } function tP(e, t) { let n, r = () => { let { currentTime: i } = t, s = (i === null ? 0 : i.value) / 100; n !== s && e(s), n = s }; return Y.update(r, !0), () => Ht(r) } var nP = n0(() => I.ScrollTimeline !== void 0), vd = class { constructor(e) { this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean) } then(e, t) { return Promise.all(this.animations).then(e).catch(t) } getAll(e) { return this.animations[0][e] } setAll(e, t) { for (let n = 0; n < this.animations.length; n++)this.animations[n][e] = t } attachTimeline(e) { let t = this.animations.map(n => { if (nP() && n.attachTimeline) n.attachTimeline(e); else return n.pause(), tP(r => { n.time = n.duration * r }, e) }); return () => { t.forEach((n, r) => { n && n(), this.animations[r].stop() }) } } get time() { return this.getAll("time") } set time(e) { this.setAll("time", e) } get speed() { return this.getAll("speed") } set speed(e) { this.setAll("speed", e) } get startTime() { return this.getAll("startTime") } get duration() { let e = 0; for (let t = 0; t < this.animations.length; t++)e = Math.max(e, this.animations[t].duration); return e } runAll(e) { this.animations.forEach(t => t[e]()) } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } }, yd = (e, t, n, r = {}, i, o, s) => a => { let l = gd(r, e) || {}, c = l.delay || r.delay || 0, { elapsed: u = 0 } = r; u = u - Fn(c); let f = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...l, delay: -u, onUpdate: m => { t.set(m), l.onUpdate && l.onUpdate(m) }, onComplete: () => { a(), l.onComplete && l.onComplete(), s && s() }, onStop: s, name: e, motionValue: t, element: o ? void 0 : i }; eP(l) || (f = { ...f, ...JR(e, f) }), f.duration && (f.duration = Fn(f.duration)), f.repeatDelay && (f.repeatDelay = Fn(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from); let d = !1; if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (f.duration = 0, f.delay === 0 && (d = !0)), (Cl.current || Il.skipAnimations) && (d = !0, f.duration = 0, f.delay = 0), d && !o && t.get() !== void 0) { let m = zl(f.keyframes, l); if (m !== void 0) return Y.update(() => { f.onUpdate(m), f.onComplete() }), new vd([]) } return !o && Lf.supports(f) ? new Lf(f) : new $l(f) }; function rP(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ue(n)) } function bd(e, t) { let n = Nl(e, t), { transitionEnd: r = {}, transition: i = {}, ...o } = n || {}; o = { ...o, ...r }; for (let s in o) { let a = LE(o[s]); rP(e, s, a) } } function s0(e) { return e.getProps()[Fl] } var iP = class extends As { constructor() { super(...arguments), this.output = [], this.counts = new Map } add(e) { let t = ky(e); if (!t) return; let n = this.counts.get(t) || 0; this.counts.set(t, n + 1), n === 0 && (this.output.push(t), this.update()); let r = !1; return () => { if (r) return; r = !0; let i = this.counts.get(t) - 1; this.counts.set(t, i), i === 0 && (Os(this.output, t), this.update()) } } update() { this.set(this.output.length ? this.output.join(", ") : "auto") } }; function oP(e) { return !!(Oe(e) && e.add) } function Mf(e, t) { var n; if (!e.applyWillChange) return; let r = e.getValue("willChange"); if (!r && !(!((n = e.props.style) === null || n === void 0) && n.willChange) && (r = new iP("auto"), e.addValue("willChange", r)), oP(r)) return r.add(t) } function sP({ protectedKeys: e, needsAnimating: t }, n) { let r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function xd(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) { var o; let { transition: s = e.getDefaultTransition(), transitionEnd: a, ...l } = t; r && (s = r); let c = [], u = i && e.animationState && e.animationState.getState()[i]; for (let f in l) { let d = e.getValue(f, (o = e.latestValues[f]) !== null && o !== void 0 ? o : null), m = l[f]; if (m === void 0 || u && sP(u, f)) continue; let y = { delay: n, ...gd(s || {}, f) }, g = !1; if (I.MotionHandoffAnimation) { let h = s0(e); if (h) { let p = I.MotionHandoffAnimation(h, f, Y); p !== null && (y.startTime = p, g = !0) } } d.start(yd(f, d, m, e.shouldReduceMotion && qr.has(f) ? { type: !1 } : y, e, g, Mf(e, f))); let b = d.animation; b && c.push(b) } return a && Promise.all(c).then(() => { Y.update(() => { a && bd(e, a) }) }), c } function Of(e, t, n = {}) { var r; let i = Nl(e, t, n.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0), { transition: o = e.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (o = n.transitionOverride); let s = i ? () => Promise.all(xd(e, i, n)) : () => Promise.resolve(), a = e.variantChildren && e.variantChildren.size ? (c = 0) => { let { delayChildren: u = 0, staggerChildren: f, staggerDirection: d } = o; return aP(e, t, u + c, f, d, n) } : () => Promise.resolve(), { when: l } = o; if (l) { let [c, u] = l === "beforeChildren" ? [s, a] : [a, s]; return c().then(() => u()) } else return Promise.all([s(), a(n.delay)]) } function aP(e, t, n = 0, r = 0, i = 1, o) { let s = [], a = (e.variantChildren.size - 1) * r, l = i === 1 ? (c = 0) => c * r : (c = 0) => a - c * r; return Array.from(e.variantChildren).sort(lP).forEach((c, u) => { c.notify("AnimationStart", t), s.push(Of(c, t, { ...o, delay: n + l(u) }).then(() => c.notify("AnimationComplete", t))) }), Promise.all(s) } function lP(e, t) { return e.sortNodePosition(t) } function wd(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { let i = t.map(o => Of(e, o, n)); r = Promise.all(i) } else if (typeof t == "string") r = Of(e, t, n); else { let i = typeof t == "function" ? Nl(e, t, n.custom) : t; r = Promise.all(xd(e, i, n)) } return r.then(() => { e.notify("AnimationComplete", t) }) } function a0(e, t) { if (!Array.isArray(t)) return !1; let n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } var cP = [...Gf].reverse(), uP = Gf.length; function fP(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => wd(e, n, r))) } function dP(e) { let t = fP(e), n = lv(), r = !0, i = l => (c, u) => { var f; let d = Nl(e, u, l === "exit" ? (f = e.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0); if (d) { let { transition: m, transitionEnd: y, ...g } = d; c = { ...c, ...g, ...y } } return c }; function o(l) { t = l(e) } function s(l) { let c = e.getProps(), u = e.getVariantContext(!0) || {}, f = [], d = new Set, m = {}, y = 1 / 0; for (let b = 0; b < uP; b++) { let h = cP[b], p = n[h], v = c[h] !== void 0 ? c[h] : u[h], w = Rs(v), C = h === l ? p.isActive : null; C === !1 && (y = b); let S = v === u[h] && v !== c[h] && w; if (S && r && e.manuallyAnimateOnMount && (S = !1), p.protectedKeys = { ...m }, !p.isActive && C === null || !v && !p.prevProp || Ps(v) || typeof v == "boolean") continue; let E = hP(p.prevProp, v) || h === l && p.isActive && !S && w || b > y && w, L = !1, F = Array.isArray(v) ? v : [v], z = F.reduce(i(h), {}); C === !1 && (z = {}); let { prevResolvedValues: D = {} } = p, K = { ...D, ...z }, U = $ => { E = !0, d.has($) && (L = !0, d.delete($)), p.needsAnimating[$] = !0; let W = e.getValue($); W && (W.liveStyle = !1) }; for (let $ in K) { let W = z[$], ee = D[$]; if (m.hasOwnProperty($)) continue; let te = !1; kf(W) && kf(ee) ? te = !a0(W, ee) : te = W !== ee, te ? W != null ? U($) : d.add($) : W !== void 0 && d.has($) ? U($) : p.protectedKeys[$] = !0 } p.prevProp = v, p.prevResolvedValues = z, p.isActive && (m = { ...m, ...z }), r && e.blockInitialAnimation && (E = !1), E && (!S || L) && f.push(...F.map($ => ({ animation: $, options: { type: h } }))) } if (d.size) { let b = {}; d.forEach(h => { let p = e.getBaseTarget(h), v = e.getValue(h); v && (v.liveStyle = !0), b[h] = p ?? null }), f.push({ animation: b }) } let g = !!f.length; return r && (c.initial === !1 || c.initial === c.animate) && !e.manuallyAnimateOnMount && (g = !1), r = !1, g ? t(f) : Promise.resolve() } function a(l, c) { var u; if (n[l].isActive === c) return Promise.resolve(); (u = e.variantChildren) === null || u === void 0 || u.forEach(d => { var m; return (m = d.animationState) === null || m === void 0 ? void 0 : m.setActive(l, c) }), n[l].isActive = c; let f = s(l); for (let d in n) n[d].protectedKeys = {}; return f } return { animateChanges: s, setActive: a, setAnimateFunction: o, getState: () => n, reset: () => { n = lv(), r = !0 } } } function hP(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !a0(t, e) : !1 } function Ei(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function lv() { return { animate: Ei(!0), whileInView: Ei(), whileHover: Ei(), whileTap: Ei(), whileDrag: Ei(), whileFocus: Ei(), exit: Ei() } } var Xr = class { constructor(e) { this.isMounted = !1, this.node = e } update() { } }, pP = class extends Xr { constructor(e) { super(e), e.animationState || (e.animationState = dP(e)) } updateAnimationControlsSubscription() { let { animate: e } = this.node.getProps(); Ps(e) && (this.unmountControls = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { let { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {}; e !== t && this.updateAnimationControlsSubscription() } unmount() { var e; this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this) } }, mP = 0, gP = class extends Xr { constructor() { super(...arguments), this.id = mP++ } update() { if (!this.node.presenceContext) return; let { isPresent: e, onExitComplete: t } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === n) return; let r = this.node.animationState.setActive("exit", !e); t && !e && r.then(() => t(this.id)) } mount() { let { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } }, Hl = { animation: { Feature: pP }, exit: { Feature: gP } }, Df = (e, t) => Math.abs(e - t); function l0(e, t) { let n = Df(e.x, t.x), r = Df(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } var c0 = 1e-4, vP = 1 - c0, yP = 1 + c0, u0 = .01, bP = 0 - u0, xP = 0 + u0; function jt(e) { return e.max - e.min } function wP(e, t, n) { return Math.abs(e - t) <= n } function cv(e, t, n, r = .5) { e.origin = r, e.originPoint = Fe(t.min, t.max, e.origin), e.scale = jt(n) / jt(t), e.translate = Fe(n.min, n.max, e.origin) - e.originPoint, (e.scale >= vP && e.scale <= yP || isNaN(e.scale)) && (e.scale = 1), (e.translate >= bP && e.translate <= xP || isNaN(e.translate)) && (e.translate = 0) } function ks(e, t, n, r) { cv(e.x, t.x, n.x, r ? r.originX : void 0), cv(e.y, t.y, n.y, r ? r.originY : void 0) } function uv(e, t, n) { e.min = n.min + t.min, e.max = e.min + jt(t) } function SP(e, t, n) { uv(e.x, t.x, n.x), uv(e.y, t.y, n.y) } function fv(e, t, n) { e.min = t.min - n.min, e.max = e.min + jt(t) } function Cs(e, t, n) { fv(e.x, t.x, n.x), fv(e.y, t.y, n.y) } var dv = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), co = () => ({ x: dv(), y: dv() }), hv = () => ({ min: 0, max: 0 }), je = () => ({ x: hv(), y: hv() }); function Sd() { let e = V(go); if (e === null) return [!0, null]; let { isPresent: t, onExitComplete: n, register: r } = e, i = Ti(); N(() => r(i), []); let o = se(() => n && n(i), [i, n]); return !t && n ? [!1, o] : [!0] } var kP = (e, t) => e.depth - t.depth, f0 = class { constructor() { this.children = [], this.isDirty = !1 } add(e) { Ol(this.children, e), this.isDirty = !0 } remove(e) { Os(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(kP), this.isDirty = !1, this.children.forEach(e) } }; function d0(e, t) { let n = br.now(), r = ({ timestamp: i }) => { let o = i - n; o >= t && (Ht(r), e(o - t)) }; return Y.read(r, !0), () => Ht(r) } var kr = new WeakMap, El = { current: null }, kd = { current: !1 }; function h0() { if (kd.current = !0, !!Pl) if (I.matchMedia) { let e = I.matchMedia("(prefers-reduced-motion)"), t = () => El.current = e.matches; e.addListener(t), t() } else El.current = !1 } function CP(e, t, n) { for (let r in t) { let i = t[r], o = n[r]; if (Oe(i)) e.addValue(r, i); else if (Oe(o)) e.addValue(r, Ue(i, { owner: e })); else if (o !== i) if (e.hasValue(r)) { let s = e.getValue(r); s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i) } else { let s = e.getStaticValue(r); e.addValue(r, Ue(s !== void 0 ? s : i, { owner: e })) } } for (let r in n) t[r] === void 0 && e.removeValue(r); return t } var TP = [...Jy, mt, Sr], EP = e => TP.find(Zy(e)), pv = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], RP = qf.length, p0 = class { scrapeMotionValuesFromProps(e, t, n) { return {} } constructor({ parent: e, props: t, presenceContext: n, reducedMotionConfig: r, blockInitialAnimation: i, visualState: o }, s = {}) { this.applyWillChange = !1, this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = ud, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.isRenderScheduled = !1, this.scheduleRender = () => { this.isRenderScheduled || (this.isRenderScheduled = !0, Y.render(this.render, !1, !0)) }; let { latestValues: a, renderState: l } = o; this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = t.initial ? { ...a } : {}, this.renderState = l, this.parent = e, this.props = t, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = s, this.blockInitialAnimation = !!i, this.isControllingVariants = Ml(t), this.isVariantNode = my(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current); let { willChange: c, ...u } = this.scrapeMotionValuesFromProps(t, {}, this); for (let f in u) { let d = u[f]; a[f] !== void 0 && Oe(d) && d.set(a[f], !1) } } mount(e) { this.current = e, kr.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, n) => this.bindToMotionValue(n, t)), kd.current || h0(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : El.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { kr.delete(this.current), this.projection && this.projection.unmount(), Ht(this.notifyUpdate), Ht(this.render), this.valueSubscriptions.forEach(e => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (let e in this.events) this.events[e].clear(); for (let e in this.features) { let t = this.features[e]; t && (t.unmount(), t.isMounted = !1) } this.current = null } bindToMotionValue(e, t) { let n = qr.has(e), r = t.on("change", o => { this.latestValues[e] = o, this.props.onUpdate && Y.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0) }), i = t.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(e, () => { r(), i(), t.owner && t.stop() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } updateFeatures() { let e = "animation"; for (e in ho) { let t = ho[e]; if (!t) continue; let { isEnabled: n, Feature: r } = t; if (!this.features[e] && r && n(this.props) && (this.features[e] = new r(this)), this.features[e]) { let i = this.features[e]; i.isMounted ? i.update() : (i.mount(), i.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : je() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, t) { this.latestValues[e] = t } update(e, t) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t; for (let n = 0; n < pv.length; n++) { let r = pv[n]; this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]); let i = "on" + r, o = e[i]; o && (this.propEventSubscriptions[r] = this.on(r, o)) } this.prevMotionValues = CP(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(e = !1) { if (e) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { let n = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (n.initial = this.props.initial), n } let t = {}; for (let n = 0; n < RP; n++) { let r = qf[n], i = this.props[r]; (Rs(i) || i === !1) && (t[r] = i) } return t } addVariantChild(e) { let t = this.getClosestVariantNode(); if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e) } addValue(e, t) { let n = this.values.get(e); t !== n && (n && this.removeValue(e), this.bindToMotionValue(e, t), this.values.set(e, t), this.latestValues[e] = t.get()) } removeValue(e) { this.values.delete(e); let t = this.valueSubscriptions.get(e); t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, t) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let n = this.values.get(e); return n === void 0 && t !== void 0 && (n = Ue(t === null ? void 0 : t, { owner: this }), this.addValue(e, n)), n } readValue(e, t) { var n; let r = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options); return r != null && (typeof r == "string" && (Ky(r) || Yy(r)) ? r = parseFloat(r) : !EP(r) && Sr.test(t) && (r = e0(e, t)), this.setBaseTarget(e, Oe(r) ? r.get() : r)), Oe(r) ? r.get() : r } setBaseTarget(e, t) { this.baseTarget[e] = t } getBaseTarget(e) { var t; let { initial: n } = this.props, r; if (typeof n == "string" || typeof n == "object") { let o = Zf(this.props, n, (t = this.presenceContext) === null || t === void 0 ? void 0 : t.custom); o && (r = o[e]) } if (n && r !== void 0) return r; let i = this.getBaseTargetFromProps(this.props, e); return i !== void 0 && !Oe(i) ? i : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e] } on(e, t) { return this.events[e] || (this.events[e] = new md), this.events[e].add(t) } notify(e, ...t) { this.events[e] && this.events[e].notify(...t) } }; function m0(e) { function t(r, i = {}) { return gy(e(r, i)) } if (typeof Proxy > "u") return t; let n = new Map; return new Proxy(t, { get: (r, i) => (n.has(i) || n.set(i, t(i)), n.get(i)) }) } var PP = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Cd(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(PP.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function g0(e, { layout: t, layoutId: n }) { return qr.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!wl[e] || e === "opacity") } function Td(e, t, n) { let { style: r, vars: i, transformOrigin: o } = e, s = !1, a = !1; for (let l in t) { let c = t[l]; if (qr.has(l)) { s = !0; continue } else if (Ny(l)) { i[l] = c; continue } else { let u = vy(c, Qf[l]); l.startsWith("origin") ? (a = !0, o[l] = u) : r[l] = u } } if (t.transform || (s || n ? r.transform = yy(t, e.transform, n) : r.transform && (r.transform = "none")), a) { let { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = o; r.transformOrigin = `${l} ${c} ${u}` } } var Ed = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function v0(e, t, n) { for (let r in t) !Oe(t[r]) && !g0(r, n) && (e[r] = t[r]) } function _P({ transformTemplate: e }, t) { return ae(() => { let n = Ed(); return Td(n, t, e), Object.assign({}, n.vars, n.style) }, [t]) } function FP(e, t) { let n = e.style || {}, r = {}; return v0(r, n, e), Object.assign(r, _P(e, t)), r } function IP(e, t) { let n = {}, r = FP(e, t); return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n } function mv(e, t, n) { return typeof e == "string" ? e : X.transform(t + n * e) } function LP(e, t, n) { let r = mv(t, e.x, e.width), i = mv(n, e.y, e.height); return `${r} ${i}` } var MP = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, OP = { offset: "strokeDashoffset", array: "strokeDasharray" }; function DP(e, t, n = 1, r = 0, i = !0) { e.pathLength = 1; let o = i ? MP : OP; e[o.offset] = X.transform(-r); let s = X.transform(t), a = X.transform(n); e[o.array] = `${s} ${a}` } function Rd(e, { attrX: t, attrY: n, attrScale: r, originX: i, originY: o, pathLength: s, pathSpacing: a = 1, pathOffset: l = 0, ...c }, u, f) { if (Td(e, c, f), u) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; let { attrs: d, style: m, dimensions: y } = e; d.transform && (y && (m.transform = d.transform), delete d.transform), y && (i !== void 0 || o !== void 0 || m.transform) && (m.transformOrigin = LP(y, i !== void 0 ? i : .5, o !== void 0 ? o : .5)), t !== void 0 && (d.x = t), n !== void 0 && (d.y = n), r !== void 0 && (d.scale = r), s !== void 0 && DP(d, s, a, l, !1) } var y0 = () => ({ ...Ed(), attrs: {} }), Pd = e => typeof e == "string" && e.toLowerCase() === "svg"; function AP(e, t, n, r) { let i = ae(() => { let o = y0(); return Rd(o, t, Pd(r), e.transformTemplate), { ...o.attrs, style: { ...o.style } } }, [t]); if (e.style) { let o = {}; v0(o, e.style, e), i.style = { ...o, ...i.style } } return i } function VP(e = !1) { return (n, r, i, { latestValues: o }, s) => { let l = (Cd(n) ? AP : IP)(r, o, s, n), c = wy(r, typeof n == "string", e), u = n !== mr ? { ...c, ...l, ref: i } : {}, { children: f } = r, d = ae(() => Oe(f) ? f.get() : f, [f]); return dl(n, { ...u, children: d }) } } function b0(e, { style: t, vars: n }, r, i) { Object.assign(e.style, t, i && i.getProjectionStyles(r)); for (let o in n) e.style.setProperty(o, n[o]) } var x0 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function w0(e, t, n, r) { b0(e, t, void 0, r); for (let i in t.attrs) e.setAttribute(x0.has(i) ? i : _l(i), t.attrs[i]) } function _d(e, t, n) { var r; let { style: i } = e, o = {}; for (let s in i) (Oe(i[s]) || t.style && Oe(t.style[s]) || g0(s, e) || ((r = n?.getValue(s)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (o[s] = i[s]); return n && i && typeof i.willChange == "string" && (n.applyWillChange = !1), o } function S0(e, t, n) { let r = _d(e, t, n); for (let i in e) if (Oe(e[i]) || Oe(t[i])) { let o = Ms.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[o] = e[i] } return r } var BP = { useVisualState: Dl({ scrapeMotionValuesFromProps: S0, createRenderState: y0, onMount: (e, t, { renderState: n, latestValues: r }) => { Y.read(() => { try { n.dimensions = typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect() } catch { n.dimensions = { x: 0, y: 0, width: 0, height: 0 } } }), Y.render(() => { Rd(n, r, Pd(t.tagName), e.transformTemplate), w0(t, n) }) } }) }, zP = { useVisualState: Dl({ applyWillChange: !0, scrapeMotionValuesFromProps: _d, createRenderState: Ed }) }; function k0(e, { forwardMotionProps: t = !1 }, n, r) { return { ...Cd(e) ? BP : zP, preloadedFeatures: n, useRender: VP(t), createVisualElement: r, Component: e } } function gv(e, t) { let n = t ? "pointerenter" : "pointerleave", r = t ? "onHoverStart" : "onHoverEnd", i = (o, s) => { if (o.pointerType === "touch" || Jf()) return; let a = e.getProps(); e.animationState && a.whileHover && e.animationState.setActive("whileHover", t); let l = a[r]; l && Y.postRender(() => l(o, s)) }; return Yn(e.current, n, i, { passive: !e.getProps()[r] }) } var $P = class extends Xr { mount() { this.unmount = Kn(gv(this.node, !0), gv(this.node, !1)) } unmount() { } }, NP = class extends Xr { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Kn(yr(this.node.current, "focus", () => this.onFocus()), yr(this.node.current, "blur", () => this.onBlur())) } unmount() { } }, C0 = (e, t) => t ? e === t ? !0 : C0(e, t.parentElement) : !1; function mf(e, t) { if (!t) return; let n = new PointerEvent("pointer" + e); t(n, Al(n)) } var HP = class extends Xr { constructor() { super(...arguments), this.removeStartListeners = gt, this.removeEndListeners = gt, this.removeAccessibleListeners = gt, this.startPointerPress = (e, t) => { if (this.isPressing) return; this.removeEndListeners(); let n = this.node.getProps(), i = Yn(I, "pointerup", (s, a) => { if (!this.checkPressEnd()) return; let { onTap: l, onTapCancel: c, globalTapTarget: u } = this.node.getProps(), f = !u && !C0(this.node.current, s.target) ? c : l; f && Y.update(() => f(s, a)) }, { passive: !(n.onTap || n.onPointerUp) }), o = Yn(I, "pointercancel", (s, a) => this.cancelPress(s, a), { passive: !(n.onTapCancel || n.onPointerCancel) }); this.removeEndListeners = Kn(i, o), this.startPress(e, t) }, this.startAccessiblePress = () => { let e = i => { if (i.key !== "Enter" || this.isPressing) return; let o = s => { s.key !== "Enter" || !this.checkPressEnd() || mf("up", (a, l) => { let { onTap: c } = this.node.getProps(); c && Y.postRender(() => c(a, l)) }) }; this.removeEndListeners(), this.removeEndListeners = yr(this.node.current, "keyup", o), mf("down", (s, a) => { this.startPress(s, a) }) }, t = yr(this.node.current, "keydown", e), n = () => { this.isPressing && mf("cancel", (i, o) => this.cancelPress(i, o)) }, r = yr(this.node.current, "blur", n); this.removeAccessibleListeners = Kn(t, r) } } startPress(e, t) { this.isPressing = !0; let { onTapStart: n, whileTap: r } = this.node.getProps(); r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Y.postRender(() => n(e, t)) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !Jf() } cancelPress(e, t) { if (!this.checkPressEnd()) return; let { onTapCancel: n } = this.node.getProps(); n && Y.postRender(() => n(e, t)) } mount() { let e = this.node.getProps(), t = Yn(e.globalTapTarget ? I : this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), n = yr(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = Kn(t, n) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } }, Af = new WeakMap, gf = new WeakMap, jP = e => { let t = Af.get(e.target); t && t(e) }, WP = e => { e.forEach(jP) }; function UP({ root: e, ...t }) { let n = e || document; gf.has(n) || gf.set(n, {}); let r = gf.get(n), i = JSON.stringify(t); return r[i] || (r[i] = new IntersectionObserver(WP, { root: e, ...t })), r[i] } function GP(e, t, n) { let r = UP(t); return Af.set(e, n), r.observe(e), () => { Af.delete(e), r.unobserve(e) } } var qP = { some: 0, all: 1 }, XP = class extends Xr { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); let { viewport: e = {} } = this.node.getProps(), { root: t, margin: n, amount: r = "some", once: i } = e, o = { root: t ? t.current : void 0, rootMargin: n, threshold: typeof r == "number" ? r : qP[r] }, s = a => { let { isIntersecting: l } = a; if (this.isInView === l || (this.isInView = l, i && !l && this.hasEnteredView)) return; l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l); let { onViewportEnter: c, onViewportLeave: u } = this.node.getProps(), f = l ? c : u; f && f(a) }; return GP(this.node.current, o, s) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; let { props: e, prevProps: t } = this.node;["amount", "margin", "root"].some(YP(e, t)) && this.startObserver() } unmount() { } }; function YP({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } var T0 = { inView: { Feature: XP }, tap: { Feature: HP }, focus: { Feature: NP }, hover: { Feature: $P } }, E0 = class { constructor(e, t, { transformPagePoint: n, contextWindow: r, dragSnapToOrigin: i = !1 } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = I, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; let u = yf(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, d = l0(u.offset, { x: 0, y: 0 }) >= 3; if (!f && !d) return; let { point: m } = u, { timestamp: y } = We; this.history.push({ ...m, timestamp: y }); let { onStart: g, onMove: b } = this.handlers; f || (g && g(this.lastMoveEvent, u), this.startEvent = this.lastMoveEvent), b && b(this.lastMoveEvent, u) }, this.handlePointerMove = (u, f) => { this.lastMoveEvent = u, this.lastMoveEventInfo = vf(f, this.transformPagePoint), Y.update(this.updatePoint, !0) }, this.handlePointerUp = (u, f) => { this.end(); let { onEnd: d, onSessionEnd: m, resumeAnimation: y } = this.handlers; if (this.dragSnapToOrigin && y && y(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; let g = yf(u.type === "pointercancel" ? this.lastMoveEventInfo : vf(f, this.transformPagePoint), this.history); this.startEvent && d && d(u, g), m && m(u, g) }, !Cy(e)) return; this.dragSnapToOrigin = i, this.handlers = t, this.transformPagePoint = n, this.contextWindow = r || I; let o = Al(e), s = vf(o, this.transformPagePoint), { point: a } = s, { timestamp: l } = We; this.history = [{ ...a, timestamp: l }]; let { onSessionStart: c } = t; c && c(e, yf(s, this.history)), this.removeListeners = Kn(Yn(this.contextWindow, "pointermove", this.handlePointerMove), Yn(this.contextWindow, "pointerup", this.handlePointerUp), Yn(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), Ht(this.updatePoint) } }; function vf(e, t) { return t ? { point: t(e.point) } : e } function vv(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function yf({ point: e }, t) { return { point: e, delta: vv(e, R0(t)), offset: vv(e, KP(t)), velocity: QP(t, .1) } } function KP(e) { return e[0] } function R0(e) { return e[e.length - 1] } function QP(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null, i = R0(e); for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Fn(t)));)n--; if (!r) return { x: 0, y: 0 }; let o = Qn(i.timestamp - r.timestamp); if (o === 0) return { x: 0, y: 0 }; let s = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }; return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s } function ZP(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? Fe(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? Fe(n, e, r.max) : Math.min(e, n)), e } function yv(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function JP(e, { top: t, left: n, bottom: r, right: i }) { return { x: yv(e.x, n, i), y: yv(e.y, t, r) } } function bv(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function e_(e, t) { return { x: bv(e.x, t.x), y: bv(e.y, t.y) } } function t_(e, t) { let n = .5, r = jt(e), i = jt(t); return i > r ? n = Ur(t.min, t.max - r, e.min) : r > i && (n = Ur(e.min, e.max - i, t.min)), wr(0, 1, n) } function n_(e, t) { let n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } var Vf = .35; function r_(e = Vf) { return e === !1 ? e = 0 : e === !0 && (e = Vf), { x: xv(e, "left", "right"), y: xv(e, "top", "bottom") } } function xv(e, t, n) { return { min: wv(e, t), max: wv(e, n) } } function wv(e, t) { return typeof e == "number" ? e : e[t] || 0 } function pn(e) { return [e("x"), e("y")] } function P0({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function i_({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function o_(e, t) { if (!t) return e; let n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function bf(e) { return e === void 0 || e === 1 } function Bf({ scale: e, scaleX: t, scaleY: n }) { return !bf(e) || !bf(t) || !bf(n) } function Ri(e) { return Bf(e) || _0(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function _0(e) { return Sv(e.x) || Sv(e.y) } function Sv(e) { return e && e !== "0%" } function Rl(e, t, n) { let r = e - n, i = t * r; return n + i } function kv(e, t, n, r, i) { return i !== void 0 && (e = Rl(e, i, r)), Rl(e, n, r) + t } function zf(e, t = 0, n = 1, r, i) { e.min = kv(e.min, t, n, r, i), e.max = kv(e.max, t, n, r, i) } function F0(e, { x: t, y: n }) { zf(e.x, t.translate, t.scale, t.originPoint), zf(e.y, n.translate, n.scale, n.originPoint) } var Cv = .999999999999, Tv = 1.0000000000001; function s_(e, t, n, r = !1) { let i = n.length; if (!i) return; t.x = t.y = 1; let o, s; for (let a = 0; a < i; a++) { o = n[a], s = o.projectionDelta; let { visualElement: l } = o.options; l && l.props.style && l.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && fo(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }), s && (t.x *= s.x.scale, t.y *= s.y.scale, F0(e, s)), r && Ri(o.latestValues) && fo(e, o.latestValues)) } t.x < Tv && t.x > Cv && (t.x = 1), t.y < Tv && t.y > Cv && (t.y = 1) } function uo(e, t) { e.min = e.min + t, e.max = e.max + t } function Ev(e, t, n, r, i = .5) { let o = Fe(e.min, e.max, i); zf(e, t, n, o, r) } function fo(e, t) { Ev(e.x, t.x, t.scaleX, t.scale, t.originX), Ev(e.y, t.y, t.scaleY, t.scale, t.originY) } function I0(e, t) { return P0(o_(e.getBoundingClientRect(), t)) } function a_(e, t, n) { let r = I0(e, n), { scroll: i } = t; return i && (uo(r.x, i.offset.x), uo(r.y, i.offset.y)), r } var L0 = ({ current: e }) => e ? e.ownerDocument.defaultView : null, l_ = new WeakMap, c_ = class { constructor(e) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = je(), this.visualElement = e } start(e, { snapToCursor: t = !1 } = {}) { let { presenceContext: n } = this.visualElement; if (n && n.isPresent === !1) return; let r = c => { let { dragSnapToOrigin: u } = this.getProps(); u ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(Al(c, "page").point) }, i = (c, u) => { var f; let { drag: d, dragPropagation: m, onDragStart: y } = this.getProps(); if (d && !m && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Ry(d), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), pn(b => { let h = this.getAxisMotionValue(b).get() || 0; if (Xn.test(h)) { let { projection: p } = this.visualElement; if (p && p.layout) { let v = p.layout.layoutBox[b]; v && (h = jt(v) * (parseFloat(h) / 100)) } } this.originPoint[b] = h }), y && Y.postRender(() => y(c, u)), (f = this.removeWillChange) === null || f === void 0 || f.call(this), this.removeWillChange = Mf(this.visualElement, "transform"); let { animationState: g } = this.visualElement; g && g.setActive("whileDrag", !0) }, o = (c, u) => { let { dragPropagation: f, dragDirectionLock: d, onDirectionLock: m, onDrag: y } = this.getProps(); if (!f && !this.openGlobalLock) return; let { offset: g } = u; if (d && this.currentDirection === null) { this.currentDirection = u_(g), this.currentDirection !== null && m && m(this.currentDirection); return } this.updateAxis("x", u.point, g), this.updateAxis("y", u.point, g), this.visualElement.render(), y && y(c, u) }, s = (c, u) => this.stop(c, u), a = () => pn(c => { var u; return this.getAnimationState(c) === "paused" && ((u = this.getAxisMotionValue(c).animation) === null || u === void 0 ? void 0 : u.play()) }), { dragSnapToOrigin: l } = this.getProps(); this.panSession = new E0(e, { onSessionStart: r, onStart: i, onMove: o, onSessionEnd: s, resumeAnimation: a }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: l, contextWindow: L0(this.visualElement) }) } stop(e, t) { var n; (n = this.removeWillChange) === null || n === void 0 || n.call(this); let r = this.isDragging; if (this.cancel(), !r) return; let { velocity: i } = t; this.startAnimation(i); let { onDragEnd: o } = this.getProps(); o && Y.postRender(() => o(e, t)) } cancel() { this.isDragging = !1; let { projection: e, animationState: t } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; let { dragPropagation: n } = this.getProps(); !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1) } updateAxis(e, t, n) { let { drag: r } = this.getProps(); if (!n || !pl(e, r, this.currentDirection)) return; let i = this.getAxisMotionValue(e), o = this.originPoint[e] + n[e]; this.constraints && this.constraints[e] && (o = ZP(o, this.constraints[e], this.elastic[e])), i.set(o) } resolveConstraints() { var e; let { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, i = this.constraints; t && ao(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = JP(r.layoutBox, t) : this.constraints = !1, this.elastic = r_(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && pn(o => { this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = n_(r.layoutBox[o], this.constraints[o])) }) } resolveRefConstraints() { let { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps(); if (!e || !ao(e)) return !1; let n = e.current; Jt(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."); let { projection: r } = this.visualElement; if (!r || !r.layout) return !1; let i = a_(n, r.root, this.visualElement.getTransformPagePoint()), o = e_(r.layout.layoutBox, i); if (t) { let s = t(i_(o)); this.hasMutatedConstraints = !!s, s && (o = P0(s)) } return o } startAnimation(e) { let { drag: t, dragMomentum: n, dragElastic: r, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: s } = this.getProps(), a = this.constraints || {}, l = pn(c => { if (!pl(c, t, this.currentDirection)) return; let u = a && a[c] || {}; o && (u = { min: 0, max: 0 }); let f = r ? 200 : 1e6, d = r ? 40 : 1e7, m = { type: "inertia", velocity: n ? e[c] : 0, bounceStiffness: f, bounceDamping: d, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...u }; return this.startAxisValueAnimation(c, m) }); return Promise.all(l).then(s) } startAxisValueAnimation(e, t) { let n = this.getAxisMotionValue(e); return n.start(yd(e, n, 0, t, this.visualElement, !1, Mf(this.visualElement, e))) } stopAnimation() { pn(e => this.getAxisMotionValue(e).stop()) } pauseAnimation() { pn(e => { var t; return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.pause() }) } getAnimationState(e) { var t; return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.state } getAxisMotionValue(e) { let t = `_drag${e.toUpperCase()}`, n = this.visualElement.getProps(), r = n[t]; return r || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0) } snapToCursor(e) { pn(t => { let { drag: n } = this.getProps(); if (!pl(t, n, this.currentDirection)) return; let { projection: r } = this.visualElement, i = this.getAxisMotionValue(t); if (r && r.layout) { let { min: o, max: s } = r.layout.layoutBox[t]; i.set(e[t] - Fe(o, s, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; let { drag: e, dragConstraints: t } = this.getProps(), { projection: n } = this.visualElement; if (!ao(t) || !n || !this.constraints) return; this.stopAnimation(); let r = { x: 0, y: 0 }; pn(o => { let s = this.getAxisMotionValue(o); if (s && this.constraints !== !1) { let a = s.get(); r[o] = t_({ min: a, max: a }, this.constraints[o]) } }); let { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), pn(o => { if (!pl(o, e, null)) return; let s = this.getAxisMotionValue(o), { min: a, max: l } = this.constraints[o]; s.set(Fe(a, l, r[o])) }) } addListeners() { if (!this.visualElement.current) return; l_.set(this.visualElement, this); let e = this.visualElement.current, t = Yn(e, "pointerdown", a => { let { drag: l, dragListener: c = !0 } = this.getProps(); l && c && this.start(a) }), n = () => { let { dragConstraints: a } = this.getProps(); ao(a) && a.current && (this.constraints = this.resolveRefConstraints()) }, { projection: r } = this.visualElement, i = r.addEventListener("measure", n); r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), Y.read(n); let o = yr(I, "resize", () => this.scalePositionWithinConstraints()), s = r.addEventListener("didUpdate", ({ delta: a, hasLayoutChanged: l }) => { this.isDragging && l && (pn(c => { let u = this.getAxisMotionValue(c); u && (this.originPoint[c] += a[c].translate, u.set(u.get() + a[c].translate)) }), this.visualElement.render()) }); return () => { o(), t(), i(), s && s() } } getProps() { let e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: n = !1, dragPropagation: r = !1, dragConstraints: i = !1, dragElastic: o = Vf, dragMomentum: s = !0 } = e; return { ...e, drag: t, dragDirectionLock: n, dragPropagation: r, dragConstraints: i, dragElastic: o, dragMomentum: s } } }; function pl(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function u_(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } var f_ = class extends Xr { constructor(e) { super(e), this.removeGroupControls = gt, this.removeListeners = gt, this.controls = new c_(e) } mount() { let { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || gt } unmount() { this.removeGroupControls(), this.removeListeners() } }, Rv = e => (t, n) => { e && Y.postRender(() => e(t, n)) }, d_ = class extends Xr { constructor() { super(...arguments), this.removePointerDownListener = gt } onPointerDown(e) { this.session = new E0(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: L0(this.node) }) } createPanHandlers() { let { onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r } = this.node.getProps(); return { onSessionStart: Rv(e), onStart: Rv(t), onMove: n, onEnd: (i, o) => { delete this.session, r && Y.postRender(() => r(i, o)) } } } mount() { this.removePointerDownListener = Yn(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } }, yl = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Pv(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } var ms = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (X.test(e)) e = parseFloat(e); else return e; let n = Pv(e, t.target.x), r = Pv(e, t.target.y); return `${n}% ${r}%` } }, h_ = { correct: (e, { treeScale: t, projectionDelta: n }) => { let r = e, i = Sr.parse(e); if (i.length > 5) return r; let o = Sr.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; i[0 + s] /= a, i[1 + s] /= l; let c = Fe(a, l, .5); return typeof i[2 + s] == "number" && (i[2 + s] /= c), typeof i[3 + s] == "number" && (i[3 + s] /= c), o(i) } }, p_ = class extends Ee { componentDidMount() { let { visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r } = this.props, { projection: i } = e; Yf(m_), i && (t.group && t.group.add(i), n && n.register && r && n.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", () => { this.safeToRemove() }), i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })), yl.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { let { layoutDependency: t, visualElement: n, drag: r, isPresent: i } = this.props, o = n.projection; return o && (o.isPresent = i, r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== i && (i ? o.promote() : o.relegate() || Y.postRender(() => { let s = o.getStack(); (!s || !s.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { let { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), Uf.postRender(() => { !e.currentAnimation && e.isLead() && this.safeToRemove() })) } componentWillUnmount() { let { visualElement: e, layoutGroup: t, switchLayoutGroup: n } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), n && n.deregister && n.deregister(r)) } safeToRemove() { let { safeToRemove: e } = this.props; e && e() } render() { return null } }; function M0(e) { let [t, n] = Sd(), r = V(Es); return k(p_, { ...e, layoutGroup: r, switchLayoutGroup: V(Ll), isPresent: t, safeToRemove: n }) } var m_ = { borderRadius: { ...ms, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: ms, borderTopRightRadius: ms, borderBottomLeftRadius: ms, borderBottomRightRadius: ms, boxShadow: h_ }, O0 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], g_ = O0.length, _v = e => typeof e == "string" ? parseFloat(e) : e, Fv = e => typeof e == "number" || X.test(e); function v_(e, t, n, r, i, o) { i ? (e.opacity = Fe(0, n.opacity !== void 0 ? n.opacity : 1, y_(r)), e.opacityExit = Fe(t.opacity !== void 0 ? t.opacity : 1, 0, b_(r))) : o && (e.opacity = Fe(t.opacity !== void 0 ? t.opacity : 1, n.opacity !== void 0 ? n.opacity : 1, r)); for (let s = 0; s < g_; s++) { let a = `border${O0[s]}Radius`, l = Iv(t, a), c = Iv(n, a); if (l === void 0 && c === void 0) continue; l || (l = 0), c || (c = 0), l === 0 || c === 0 || Fv(l) === Fv(c) ? (e[a] = Math.max(Fe(_v(l), _v(c), r), 0), (Xn.test(c) || Xn.test(l)) && (e[a] += "%")) : e[a] = c } (t.rotate || n.rotate) && (e.rotate = Fe(t.rotate || 0, n.rotate || 0, r)) } function Iv(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } var y_ = D0(0, .5, od), b_ = D0(.5, .95, gt); function D0(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(Ur(e, t, r)) } function Lv(e, t) { e.min = t.min, e.max = t.max } function hn(e, t) { Lv(e.x, t.x), Lv(e.y, t.y) } function Mv(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } function Ov(e, t, n, r, i) { return e -= t, e = Rl(e, 1 / n, r), i !== void 0 && (e = Rl(e, 1 / i, r)), e } function x_(e, t = 0, n = 1, r = .5, i, o = e, s = e) { if (Xn.test(t) && (t = parseFloat(t), t = Fe(s.min, s.max, t / 100) - s.min), typeof t != "number") return; let a = Fe(o.min, o.max, r); e === o && (a -= t), e.min = Ov(e.min, t, n, a, i), e.max = Ov(e.max, t, n, a, i) } function Dv(e, t, [n, r, i], o, s) { x_(e, t[n], t[r], t[i], t.scale, o, s) } var w_ = ["x", "scaleX", "originX"], S_ = ["y", "scaleY", "originY"]; function Av(e, t, n, r) { Dv(e.x, t, w_, n ? n.x : void 0, r ? r.x : void 0), Dv(e.y, t, S_, n ? n.y : void 0, r ? r.y : void 0) } function Vv(e) { return e.translate === 0 && e.scale === 1 } function A0(e) { return Vv(e.x) && Vv(e.y) } function Bv(e, t) { return e.min === t.min && e.max === t.max } function k_(e, t) { return Bv(e.x, t.x) && Bv(e.y, t.y) } function zv(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function V0(e, t) { return zv(e.x, t.x) && zv(e.y, t.y) } function $v(e) { return jt(e.x) / jt(e.y) } function Nv(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } var C_ = class { constructor() { this.members = [] } add(e) { Ol(this.members, e), e.scheduleRender() } remove(e) { if (Os(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { let t = this.members[this.members.length - 1]; t && this.promote(t) } } relegate(e) { let t = this.members.findIndex(r => e === r); if (t === 0) return !1; let n; for (let r = t; r >= 0; r--) { let i = this.members[r]; if (i.isPresent !== !1) { n = i; break } } return n ? (this.promote(n), !0) : !1 } promote(e, t) { let n = this.lead; if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) { n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, t && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); let { crossfade: r } = e.options; r === !1 && n.hide() } } exitAnimationComplete() { this.members.forEach(e => { let { options: t, resumingFrom: n } = e; t.onExitComplete && t.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } }; function T_(e, t, n) { let r = "", i = e.x.translate / t.x, o = e.y.translate / t.y, s = n?.z || 0; if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { let { transformPerspective: c, rotate: u, rotateX: f, rotateY: d, skewX: m, skewY: y } = n; c && (r = `perspective(${c}px) ${r}`), u && (r += `rotate(${u}deg) `), f && (r += `rotateX(${f}deg) `), d && (r += `rotateY(${d}deg) `), m && (r += `skewX(${m}deg) `), y && (r += `skewY(${y}deg) `) } let a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } function B0(e) { return e instanceof SVGElement && e.tagName !== "svg" } function Fd(e, t, n) { let r = Oe(e) ? e : Ue(e); return r.start(yd("", r, t, n)), r.animation } var Pi = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, bs = typeof I < "u" && I.MotionDebug !== void 0, xf = ["", "X", "Y", "Z"], E_ = { visibility: "hidden" }, Hv = 1e3, R_ = 0; function wf(e, t, n, r) { let { latestValues: i } = t; i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function z0(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; let { visualElement: t } = e.options; if (!t) return; let n = s0(t); I.MotionHasOptimisedTransformAnimation(n) && I.MotionCancelOptimisedTransform(n); let { parent: r } = e; r && !r.hasCheckedOptimisedAppear && z0(r) } function $0({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(s = {}, a = t?.()) { this.id = R_++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, bs && (Pi.totalNodes = Pi.resolvedTargetDeltas = Pi.recalculatedProjection = 0), this.nodes.forEach(F_), this.nodes.forEach(D_), this.nodes.forEach(A_), this.nodes.forEach(I_), bs && I.MotionDebug.record(Pi) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new f0) } addEventListener(s, a) { return this.eventHandlers.has(s) || this.eventHandlers.set(s, new md), this.eventHandlers.get(s).add(a) } notifyListeners(s, ...a) { let l = this.eventHandlers.get(s); l && l.notify(...a) } hasListeners(s) { return this.eventHandlers.has(s) } mount(s, a = this.root.hasTreeAnimated) { if (this.instance) return; this.isSVG = B0(s), this.instance = s; let { layoutId: l, layout: c, visualElement: u } = this.options; if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), e) { let f, d = () => this.root.updateBlockedByResize = !1; e(s, () => { this.root.updateBlockedByResize = !0, f && f(), f = d0(d, 250), yl.hasAnimatedSinceResize && (yl.hasAnimatedSinceResize = !1, this.nodes.forEach(Wv)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({ delta: f, hasLayoutChanged: d, hasRelativeTargetChanged: m, layout: y }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } let g = this.options.transition || u.getDefaultTransition() || N_, { onLayoutAnimationStart: b, onLayoutAnimationComplete: h } = u.getProps(), p = !this.targetLayout || !V0(this.targetLayout, y) || m, v = !d && m; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || v || d && (p || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(f, v); let w = { ...gd(g, "layout"), onPlay: b, onComplete: h }; (u.shouldReduceMotion || this.options.layoutRoot) && (w.delay = 0, w.type = !1), this.startAnimation(w) } else d || Wv(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = y }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); let s = this.getStack(); s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Ht(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(V_), this.animationId++) } getTransformTemplate() { let { visualElement: s } = this.options; return s && s.getProps().transformTemplate } willUpdate(s = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (I.MotionCancelOptimisedTransform && !this.hasCheckedOptimisedAppear && z0(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let u = 0; u < this.path.length; u++) { let f = this.path[u]; f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1) } let { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; let c = this.getTransformTemplate(); this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(jv); return } this.isUpdating || this.nodes.forEach(M_), this.isUpdating = !1, this.nodes.forEach(O_), this.nodes.forEach(P_), this.nodes.forEach(__), this.clearAllSnapshots(); let a = br.now(); We.delta = wr(0, 1e3 / 60, a - We.timestamp), We.timestamp = a, We.isProcessing = !0, gl.update.process(We), gl.preRender.process(We), gl.render.process(We), We.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Uf.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(L_), this.sharedNodes.forEach(B_) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Y.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Y.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); let s = this.layout; this.layout = this.measure(!1), this.layoutCorrected = je(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); let { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0) } updateScroll(s = "measure") { let a = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a) { let l = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: s, isRoot: l, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : l } } } resetTransform() { if (!i) return; let s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !A0(this.projectionDelta), l = this.getTransformTemplate(), c = l ? l(this.latestValues, "") : void 0, u = c !== this.prevTransformTemplateValue; s && (a || Ri(this.latestValues) || u) && (i(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender()) } measure(s = !0) { let a = this.measurePageBox(), l = this.removeElementScroll(a); return s && (l = this.removeTransform(l)), H_(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { var s; let { visualElement: a } = this.options; if (!a) return je(); let l = a.measureViewportBox(); if (!(((s = this.scroll) === null || s === void 0 ? void 0 : s.wasRoot) || this.path.some(j_))) { let { scroll: u } = this.root; u && (uo(l.x, u.offset.x), uo(l.y, u.offset.y)) } return l } removeElementScroll(s) { var a; let l = je(); if (hn(l, s), !((a = this.scroll) === null || a === void 0) && a.wasRoot) return l; for (let c = 0; c < this.path.length; c++) { let u = this.path[c], { scroll: f, options: d } = u; u !== this.root && f && d.layoutScroll && (f.wasRoot && hn(l, s), uo(l.x, f.offset.x), uo(l.y, f.offset.y)) } return l } applyTransform(s, a = !1) { let l = je(); hn(l, s); for (let c = 0; c < this.path.length; c++) { let u = this.path[c]; !a && u.options.layoutScroll && u.scroll && u !== u.root && fo(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }), Ri(u.latestValues) && fo(l, u.latestValues) } return Ri(this.latestValues) && fo(l, this.latestValues), l } removeTransform(s) { let a = je(); hn(a, s); for (let l = 0; l < this.path.length; l++) { let c = this.path[l]; if (!c.instance || !Ri(c.latestValues)) continue; Bf(c.latestValues) && c.updateSnapshot(); let u = je(), f = c.measurePageBox(); hn(u, f), Av(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u) } return Ri(this.latestValues) && Av(a, this.latestValues), a } setTargetDelta(s) { this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(s) { this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== We.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(s = !1) { var a; let l = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty); let c = !!this.resumingFrom || this !== l; if (!(s || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; let { layout: f, layoutId: d } = this.options; if (!(!this.layout || !(f || d))) { if (this.resolvedRelativeTargetAt = We.timestamp, !this.targetDelta && !this.relativeTarget) { let m = this.getClosestProjectingParent(); m && m.layout && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = je(), this.relativeTargetOrigin = je(), Cs(this.relativeTargetOrigin, this.layout.layoutBox, m.layout.layoutBox), hn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = je(), this.targetWithTransforms = je()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), SP(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : hn(this.target, this.layout.layoutBox), F0(this.target, this.targetDelta)) : hn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; let m = this.getClosestProjectingParent(); m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = je(), this.relativeTargetOrigin = je(), Cs(this.relativeTargetOrigin, this.target, m.target), hn(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } bs && Pi.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || Bf(this.parent.latestValues) || _0(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var s; let a = this.getLead(), l = !!this.resumingFrom || this !== a, c = !0; if ((this.isProjectionDirty || !((s = this.parent) === null || s === void 0) && s.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === We.timestamp && (c = !1), c) return; let { layout: u, layoutId: f } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || f)) return; hn(this.layoutCorrected, this.layout.layoutBox); let d = this.treeScale.x, m = this.treeScale.y; s_(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = je()); let { target: y } = a; if (!y) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Mv(this.prevProjectionDelta.x, this.projectionDelta.x), Mv(this.prevProjectionDelta.y, this.projectionDelta.y)), ks(this.projectionDelta, this.layoutCorrected, y, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== m || !Nv(this.projectionDelta.x, this.prevProjectionDelta.x) || !Nv(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", y)), bs && Pi.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(s = !0) { var a; if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), s) { let l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = co(), this.projectionDelta = co(), this.projectionDeltaWithTransform = co() } setAnimationOrigin(s, a = !1) { let l = this.snapshot, c = l ? l.latestValues : {}, u = { ...this.latestValues }, f = co(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; let d = je(), m = l ? l.source : void 0, y = this.layout ? this.layout.source : void 0, g = m !== y, b = this.getStack(), h = !b || b.members.length <= 1, p = !!(g && !h && this.options.crossfade === !0 && !this.path.some($_)); this.animationProgress = 0; let v; this.mixTargetDelta = w => { let C = w / 1e3; Uv(f.x, s.x, C), Uv(f.y, s.y, C), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Cs(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), z_(this.relativeTarget, this.relativeTargetOrigin, d, C), v && k_(this.relativeTarget, v) && (this.isProjectionDirty = !1), v || (v = je()), hn(v, this.relativeTarget)), g && (this.animationValues = u, v_(u, c, this.latestValues, C, p, h)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(s) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Ht(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Y.update(() => { yl.hasAnimatedSinceResize = !0, this.currentAnimation = Fd(0, Hv, { ...s, onUpdate: a => { this.mixTargetDelta(a), s.onUpdate && s.onUpdate(a) }, onComplete: () => { s.onComplete && s.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); let s = this.getStack(); s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Hv), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { let s = this.getLead(), { targetWithTransforms: a, target: l, layout: c, latestValues: u } = s; if (!(!a || !l || !c)) { if (this !== s && this.layout && c && N0(this.options.animationType, this.layout.layoutBox, c.layoutBox)) { l = this.target || je(); let f = jt(this.layout.layoutBox.x); l.x.min = s.target.x.min, l.x.max = l.x.min + f; let d = jt(this.layout.layoutBox.y); l.y.min = s.target.y.min, l.y.max = l.y.min + d } hn(a, l), fo(a, u), ks(this.projectionDeltaWithTransform, this.layoutCorrected, a, u) } } registerSharedNode(s, a) { this.sharedNodes.has(s) || this.sharedNodes.set(s, new C_), this.sharedNodes.get(s).add(a); let c = a.options.initialPromotionConfig; a.promote({ transition: c ? c.transition : void 0, preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { let s = this.getStack(); return s ? s.lead === this : !0 } getLead() { var s; let { layoutId: a } = this.options; return a ? ((s = this.getStack()) === null || s === void 0 ? void 0 : s.lead) || this : this } getPrevLead() { var s; let { layoutId: a } = this.options; return a ? (s = this.getStack()) === null || s === void 0 ? void 0 : s.prevLead : void 0 } getStack() { let { layoutId: s } = this.options; if (s) return this.root.sharedNodes.get(s) } promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) { let c = this.getStack(); c && c.promote(this, l), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { let s = this.getStack(); return s ? s.relegate(this) : !1 } resetSkewAndRotation() { let { visualElement: s } = this.options; if (!s) return; let a = !1, { latestValues: l } = s; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; let c = {}; l.z && wf("z", s, c, this.animationValues); for (let u = 0; u < xf.length; u++)wf(`rotate${xf[u]}`, s, c, this.animationValues), wf(`skew${xf[u]}`, s, c, this.animationValues); s.render(); for (let u in c) s.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]); s.scheduleRender() } getProjectionStyles(s) { var a, l; if (!this.instance || this.isSVG) return; if (!this.isVisible) return E_; let c = { visibility: "" }, u = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, c.opacity = "", c.pointerEvents = Tt(s?.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c; let f = this.getLead(); if (!this.projectionDelta || !this.layout || !f.target) { let g = {}; return this.options.layoutId && (g.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, g.pointerEvents = Tt(s?.pointerEvents) || ""), this.hasProjected && !Ri(this.latestValues) && (g.transform = u ? u({}, "") : "none", this.hasProjected = !1), g } let d = f.animationValues || f.latestValues; this.applyTransformsToTarget(), c.transform = T_(this.projectionDeltaWithTransform, this.treeScale, d), u && (c.transform = u(d, c.transform)); let { x: m, y } = this.projectionDelta; c.transformOrigin = `${m.origin * 100}% ${y.origin * 100}% 0`, f.animationValues ? c.opacity = f === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0; for (let g in wl) { if (d[g] === void 0) continue; let { correct: b, applyTo: h } = wl[g], p = c.transform === "none" ? d[g] : b(d[g], f); if (h) { let v = h.length; for (let w = 0; w < v; w++)c[h[w]] = p } else c[g] = p } return this.options.layoutId && (c.pointerEvents = f === this ? Tt(s?.pointerEvents) || "" : "none"), c } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(s => { var a; return (a = s.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(jv), this.root.sharedNodes.clear() } } } function P_(e) { e.updateLayout() } function __(e) { var t; let n = ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) { let { layoutBox: r, measuredBox: i } = e.layout, { animationType: o } = e.options, s = n.source !== e.layout.source; o === "size" ? pn(f => { let d = s ? n.measuredBox[f] : n.layoutBox[f], m = jt(d); d.min = r[f].min, d.max = d.min + m }) : N0(o, n.layoutBox, r) && pn(f => { let d = s ? n.measuredBox[f] : n.layoutBox[f], m = jt(r[f]); d.max = d.min + m, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + m) }); let a = co(); ks(a, r, n.layoutBox); let l = co(); s ? ks(l, e.applyTransform(i, !0), n.measuredBox) : ks(l, r, n.layoutBox); let c = !A0(a), u = !1; if (!e.resumeFrom) { let f = e.getClosestProjectingParent(); if (f && !f.resumeFrom) { let { snapshot: d, layout: m } = f; if (d && m) { let y = je(); Cs(y, n.layoutBox, d.layoutBox); let g = je(); Cs(g, r, m.layoutBox), V0(y, g) || (u = !0), f.options.layoutRoot && (e.relativeTarget = g, e.relativeTargetOrigin = y, e.relativeParent = f) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: n, delta: l, layoutDelta: a, hasLayoutChanged: c, hasRelativeTargetChanged: u }) } else if (e.isLead()) { let { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function F_(e) { bs && Pi.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function I_(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function L_(e) { e.clearSnapshot() } function jv(e) { e.clearMeasurements() } function M_(e) { e.isLayoutDirty = !1 } function O_(e) { let { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function Wv(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function D_(e) { e.resolveTargetDelta() } function A_(e) { e.calcProjection() } function V_(e) { e.resetSkewAndRotation() } function B_(e) { e.removeLeadSnapshot() } function Uv(e, t, n) { e.translate = Fe(t.translate, 0, n), e.scale = Fe(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function Gv(e, t, n, r) { e.min = Fe(t.min, n.min, r), e.max = Fe(t.max, n.max, r) } function z_(e, t, n, r) { Gv(e.x, t.x, n.x, r), Gv(e.y, t.y, n.y, r) } function $_(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } var N_ = { duration: .45, ease: [.4, 0, .1, 1] }, qv = e => typeof Ne < "u" && Ne.userAgent && Ne.userAgent.toLowerCase().includes(e), Xv = qv("applewebkit/") && !qv("chrome/") ? Math.round : gt; function Yv(e) { e.min = Xv(e.min), e.max = Xv(e.max) } function H_(e) { Yv(e.x), Yv(e.y) } function N0(e, t, n) { return e === "position" || e === "preserve-aspect" && !wP($v(t), $v(n), .2) } function j_(e) { var t; return e !== e.root && ((t = e.scroll) === null || t === void 0 ? void 0 : t.wasRoot) } var W_ = $0({ attachResizeListener: (e, t) => yr(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Ii = { current: void 0 }, H0 = $0({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Ii.current) { let e = new W_({}); e.mount(I), e.setOptions({ layoutScroll: !0 }), Ii.current = e } return Ii.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => I.getComputedStyle(e).position === "fixed" }), j0 = { pan: { Feature: d_ }, drag: { Feature: f_, ProjectionNode: H0, MeasureLayout: M0 } }, W0 = class extends p0 { constructor() { super(...arguments), this.KeyframeResolver = t0 } sortInstanceNodePosition(e, t) { return e.compareDocumentPosition(t) & 2 ? 1 : -1 } getBaseTargetFromProps(e, t) { return e.style ? e.style[t] : void 0 } removeValueFromRenderState(e, { vars: t, style: n }) { delete t[e], delete n[e] } }; function U_(e) { return I.getComputedStyle(e) } var U0 = class extends W0 { constructor() { super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = b0 } readValueFromInstance(e, t) { if (qr.has(t)) { let n = hd(t); return n && n.default || 0 } else { let n = U_(e), r = (Ny(t) ? n.getPropertyValue(t) : n[t]) || 0; return typeof r == "string" ? r.trim() : r } } measureInstanceViewportBox(e, { transformPagePoint: t }) { return I0(e, t) } build(e, t, n) { Td(e, t, n.transformTemplate) } scrapeMotionValuesFromProps(e, t, n) { return _d(e, t, n) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); let { children: e } = this.props; Oe(e) && (this.childSubscription = e.on("change", t => { this.current && (this.current.textContent = `${t}`) })) } }, G0 = class extends W0 { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = je } getBaseTargetFromProps(e, t) { return e[t] } readValueFromInstance(e, t) { if (qr.has(t)) { let n = hd(t); return n && n.default || 0 } return t = x0.has(t) ? t : _l(t), e.getAttribute(t) } scrapeMotionValuesFromProps(e, t, n) { return S0(e, t, n) } build(e, t, n) { Rd(e, t, this.isSVGTag, n.transformTemplate) } renderInstance(e, t, n, r) { w0(e, t, n, r) } mount(e) { this.isSVGTag = Pd(e.tagName), super.mount(e) } }, Id = (e, t) => Cd(e) ? new G0(t) : new U0(t, { allowProjection: e !== mr }), q0 = { layout: { ProjectionNode: H0, MeasureLayout: M0 } }, G_ = { ...Hl, ...T0, ...j0, ...q0 }, gn = m0((e, t) => k0(e, t, G_, Id)); var q_ = m0(k0), X_ = class extends Ee { getSnapshotBeforeUpdate(e) { let t = this.props.childRef.current; if (t && e.isPresent && !this.props.isPresent) { let n = this.props.sizeRef.current; n.height = t.offsetHeight || 0, n.width = t.offsetWidth || 0, n.top = t.offsetTop, n.left = t.offsetLeft } return null } componentDidUpdate() { } render() { return this.props.children } }; function Y_({ children: e, isPresent: t }) {
    let n = Ti(), r = A(null), i = A({ width: 0, height: 0, top: 0, left: 0 }), { nonce: o } = V(xr); return st(() => {
        let { width: s, height: a, top: l, left: c } = i.current; if (t || !r.current || !s || !a) return; r.current.dataset.motionPopId = n; let u = document.createElement("style"); return o && (u.nonce = o), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${s}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `), () => { document.head.removeChild(u) }
    }, [t]), k(X_, { isPresent: t, childRef: r, sizeRef: i, children: gr(e, { ref: r }) })
} var K_ = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s }) => { let a = Jn(Q_), l = Ti(), c = ae(() => ({ id: l, initial: t, isPresent: n, custom: i, onExitComplete: u => { a.set(u, !0); for (let f of a.values()) if (!f) return; r && r() }, register: u => (a.set(u, !1), () => a.delete(u)) }), o ? [Math.random()] : [n]); return ae(() => { a.forEach((u, f) => a.set(f, !1)) }, [n]), N(() => { !n && !a.size && r && r() }, [n]), s === "popLayout" && (e = k(Y_, { isPresent: n, children: e })), k(go.Provider, { value: c, children: e }) }; function Q_() { return new Map } var ml = e => e.key || ""; function Kv(e) { let t = []; return qn.forEach(e, n => { Nt(n) && t.push(n) }), t } var Ld = ({ children: e, exitBeforeEnter: t, custom: n, initial: r = !0, onExitComplete: i, presenceAffectsLayout: o = !0, mode: s = "sync" }) => { Jt(!t, "Replace exitBeforeEnter with mode='wait'"); let a = ae(() => Kv(e), [e]), l = a.map(ml), c = A(!0), u = A(a), f = Jn(() => new Map), [d, m] = Qe(a), [y, g] = Qe(a); Gr(() => { c.current = !1, u.current = a; for (let p = 0; p < y.length; p++) { let v = ml(y[p]); l.includes(v) ? f.delete(v) : f.get(v) !== !0 && f.set(v, !1) } }, [y, l.length, l.join("-")]); let b = []; if (a !== d) { let p = [...a]; for (let v = 0; v < y.length; v++) { let w = y[v], C = ml(w); l.includes(C) || (p.splice(v, 0, w), b.push(w)) } s === "wait" && b.length && (p = b), g(Kv(p)), m(a); return } let { forceRender: h } = V(Es); return k(He, { children: y.map(p => { let v = ml(p), w = a === y || l.includes(v), C = () => { if (f.has(v)) f.set(v, !0); else return; let S = !0; f.forEach(R => { R || (S = !1) }), S && (h?.(), g(u.current), i && i()) }; return k(K_, { isPresent: w, initial: !c.current || r ? void 0 : !1, custom: w ? void 0 : n, presenceAffectsLayout: o, mode: s, onExitComplete: w ? void 0 : C, children: p }, v) }) }) }; function X0({ children: e, isValidProp: t, ...n }) { t && xy(t), n = { ...V(xr), ...n }, n.isStatic = Jn(() => n.isStatic); let r = ae(() => n, [JSON.stringify(n.transition), n.transformPagePoint, n.reducedMotion]); return k(xr.Provider, { value: r, children: e }) } var Y0 = ke(null); function Z_() { let e = A(!1); return Gr(() => (e.current = !0, () => { e.current = !1 }), []), e } function Md() { let e = Z_(), [t, n] = Qe(0), r = se(() => { e.current && n(t + 1) }, [t]); return [se(() => Y.postRender(r), [r]), t] } var J_ = e => !e.isLayoutDirty && e.willUpdate(!1); function Qv() { let e = new Set, t = new WeakMap, n = () => e.forEach(J_); return { add: r => { e.add(r), t.set(r, r.addEventListener("willUpdate", n)) }, remove: r => { e.delete(r); let i = t.get(r); i && (i(), t.delete(r)), n() }, dirty: n } } var K0 = e => e === !0, eF = e => K0(e === !0) || e === "id", Q0 = ({ children: e, id: t, inherit: n = !0 }) => { let r = V(Es), i = V(Y0), [o, s] = Md(), a = A(null), l = r.id || i; a.current === null && (eF(n) && l && (t = t ? l + "-" + t : l), a.current = { id: t, group: K0(n) && r.group || Qv() }); let c = ae(() => ({ ...a.current, forceRender: o }), [s]); return k(Es.Provider, { value: c, children: e }) }; function er(e) { let t = Jn(() => Ue(e)), { isStatic: n } = V(xr); if (n) { let [, r] = Qe(e); N(() => t.on("change", r), []) } return t } var tF = e => e && typeof e == "object" && e.mix, nF = e => tF(e) ? e.mix : void 0; function Vs(...e) { let t = !Array.isArray(e[0]), n = t ? 0 : -1, r = e[0 + n], i = e[1 + n], o = e[2 + n], s = e[3 + n], a = xo(i, o, { mixer: nF(o[0]), ...s }); return t ? a(r) : a } function Z0(e, t) { let n = er(t()), r = () => n.set(t()); return r(), Gr(() => { let i = () => Y.preRender(r, !1, !0), o = e.map(s => s.on("change", i)); return () => { o.forEach(s => s()), Ht(r) } }), n } function rF(e) { Ss.current = [], e(); let t = Z0(Ss.current, e); return Ss.current = void 0, t } function Dt(e, t, n, r) { if (typeof e == "function") return rF(e); let i = typeof t == "function" ? t : Vs(t, n, r); return Array.isArray(e) ? Zv(e, i) : Zv([e], ([o]) => i(o)) } function Zv(e, t) { let n = Jn(() => []); return Z0(e, () => { n.length = 0; let r = e.length; for (let i = 0; i < r; i++)n[i] = e[i].get(); return t(n) }) } var J0 = ke(null); function iF(e, t, n, r) { if (!r) return e; let i = e.findIndex(u => u.value === t); if (i === -1) return e; let o = r > 0 ? 1 : -1, s = e[i + o]; if (!s) return e; let a = e[i], l = s.layout, c = Fe(l.min, l.max, .5); return o === 1 && a.layout.max + n > c || o === -1 && a.layout.min + n < c ? ME(e, i, i + o) : e } function oF({ children: e, as: t = "ul", axis: n = "y", onReorder: r, values: i, ...o }, s) { let a = Jn(() => gn(t)), l = [], c = A(!1); Jt(!!i, "Reorder.Group must be provided a values prop"); let u = { axis: n, registerItem: (f, d) => { let m = l.findIndex(y => f === y.value); m !== -1 ? l[m].layout = d[n] : l.push({ value: f, layout: d[n] }), l.sort(aF) }, updateOrder: (f, d, m) => { if (c.current) return; let y = iF(l, f, d, m); l !== y && (c.current = !0, r(y.map(sF).filter(g => i.indexOf(g) !== -1))) } }; return N(() => { c.current = !1 }), k(a, { ...o, ref: s, ignoreStrict: !0, children: k(J0.Provider, { value: u, children: e }) }) } var dN = Ve(oF); function sF(e) { return e.value } function aF(e, t) { return e.layout.min - t.layout.min } function Jv(e, t = 0) { return Oe(e) ? e : er(t) } function lF({ children: e, style: t = {}, value: n, as: r = "li", onDrag: i, layout: o = !0, ...s }, a) { let l = Jn(() => gn(r)), c = V(J0), u = { x: Jv(t.x), y: Jv(t.y) }, f = Dt([u.x, u.y], ([g, b]) => g || b ? 1 : "unset"); Jt(!!c, "Reorder.Item must be a child of Reorder.Group"); let { axis: d, registerItem: m, updateOrder: y } = c; return k(l, { drag: d, ...s, dragSnapToOrigin: !0, style: { ...t, x: u.x, y: u.y, zIndex: f }, layout: o, onDrag: (g, b) => { let { velocity: h } = b; h[d] && y(n, u[d].get(), h[d]), i && i(g, b) }, onLayoutMeasure: g => m(n, g), ref: a, ignoreStrict: !0, children: e }) } var mN = Ve(lF); var cF = { renderer: Id, ...Hl }, eb = { renderer: Id, ...Hl, ...T0 }, uF = { ...eb, ...j0, ...q0 }; function ey(e) { return typeof e == "number" ? e : parseFloat(e) } function Od(e, t = {}) { let { isStatic: n } = V(xr), r = A(null), i = er(Oe(e) ? ey(e.get()) : e), o = A(i.get()), s = A(() => { }), a = () => { let c = r.current; c && c.time === 0 && c.sample(We.delta), l(), r.current = dd({ keyframes: [i.get(), o.current], velocity: i.getVelocity(), type: "spring", restDelta: .001, restSpeed: .01, ...t, onUpdate: s.current }) }, l = () => { r.current && r.current.stop() }; return st(() => i.attach((c, u) => n ? u(c) : (o.current = c, s.current = u, Y.update(a), i.get()), l), [JSON.stringify(t)]), Gr(() => { if (Oe(e)) return e.on("change", c => i.set(ey(c))) }, [i]), i } function jl(e, t, n) { var r; if (typeof e == "string") { let i = document; t && (Jt(!!t.current, "Scope provided, but no element detected."), i = t.current), n ? ((r = n[e]) !== null && r !== void 0 || (n[e] = i.querySelectorAll(e)), e = n[e]) : e = i.querySelectorAll(e) } else e instanceof Element && (e = [e]); return Array.from(e || []) } var bl = new WeakMap, Wr; function fF(e, t) { if (t) { let { inlineSize: n, blockSize: r } = t[0]; return { width: n, height: r } } else return e instanceof SVGElement && "getBBox" in e ? e.getBBox() : { width: e.offsetWidth, height: e.offsetHeight } } function dF({ target: e, contentRect: t, borderBoxSize: n }) { var r; (r = bl.get(e)) === null || r === void 0 || r.forEach(i => { i({ target: e, contentSize: t, get size() { return fF(e, n) } }) }) } function hF(e) { e.forEach(dF) } function pF() { typeof ResizeObserver > "u" || (Wr = new ResizeObserver(hF)) } function mF(e, t) { Wr || pF(); let n = jl(e); return n.forEach(r => { let i = bl.get(r); i || (i = new Set, bl.set(r, i)), i.add(t), Wr?.observe(r) }), () => { n.forEach(r => { let i = bl.get(r); i?.delete(t), i?.size || Wr?.unobserve(r) }) } } var xl = new Set, Ts; function gF() { Ts = () => { let e = { width: I.innerWidth, height: I.innerHeight }, t = { target: I, size: e, contentSize: e }; xl.forEach(n => n(t)) }, I.addEventListener("resize", Ts) } function vF(e) { return xl.add(e), Ts || gF(), () => { xl.delete(e), !xl.size && Ts && (Ts = void 0) } } function yF(e, t) { return typeof e == "function" ? vF(e) : mF(e, t) } var bF = 50, ty = () => ({ current: 0, offset: [], progress: 0, scrollLength: 0, targetOffset: 0, targetLength: 0, containerLength: 0, velocity: 0 }), xF = () => ({ time: 0, x: ty(), y: ty() }), wF = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } }; function ny(e, t, n, r) { let i = n[t], { length: o, position: s } = wF[t], a = i.current, l = n.time; i.current = e[`scroll${s}`], i.scrollLength = e[`scroll${o}`] - e[`client${o}`], i.offset.length = 0, i.offset[0] = 0, i.offset[1] = i.scrollLength, i.progress = Ur(0, i.scrollLength, i.current); let c = r - l; i.velocity = c > bF ? 0 : td(i.current - a, c) } function SF(e, t, n) { ny(e, "x", t, n), ny(e, "y", t, n), t.time = n } function kF(e, t) { let n = { x: 0, y: 0 }, r = e; for (; r && r !== t;)if (r instanceof HTMLElement) n.x += r.offsetLeft, n.y += r.offsetTop, r = r.offsetParent; else if (r.tagName === "svg") { let i = r.getBoundingClientRect(); r = r.parentElement; let o = r.getBoundingClientRect(); n.x += i.left - o.left, n.y += i.top - o.top } else if (r instanceof SVGGraphicsElement) { let { x: i, y: o } = r.getBBox(); n.x += i, n.y += o; let s = null, a = r.parentNode; for (; !s;)a.tagName === "svg" && (s = a), a = r.parentNode; r = s } else break; return n } var CF = { Enter: [[0, 1], [1, 1]], Exit: [[0, 0], [1, 0]], Any: [[1, 0], [0, 1]], All: [[0, 0], [1, 1]] }, $f = { start: 0, center: .5, end: 1 }; function ry(e, t, n = 0) { let r = 0; if (e in $f && (e = $f[e]), typeof e == "string") { let i = parseFloat(e); e.endsWith("px") ? r = i : e.endsWith("%") ? e = i / 100 : e.endsWith("vw") ? r = i / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? r = i / 100 * document.documentElement.clientHeight : e = i } return typeof e == "number" && (r = t * e), n + r } var TF = [0, 0]; function EF(e, t, n, r) { let i = Array.isArray(e) ? e : TF, o = 0, s = 0; return typeof e == "number" ? i = [e, e] : typeof e == "string" && (e = e.trim(), e.includes(" ") ? i = e.split(" ") : i = [e, $f[e] ? e : "0"]), o = ry(i[0], n, r), s = ry(i[1], t), o - s } var RF = { x: 0, y: 0 }; function PF(e) { return "getBBox" in e && e.tagName !== "svg" ? e.getBBox() : { width: e.clientWidth, height: e.clientHeight } } function _F(e, t, n) { let { offset: r = CF.All } = n, { target: i = e, axis: o = "y" } = n, s = o === "y" ? "height" : "width", a = i !== e ? kF(i, e) : RF, l = i === e ? { width: e.scrollWidth, height: e.scrollHeight } : PF(i), c = { width: e.clientWidth, height: e.clientHeight }; t[o].offset.length = 0; let u = !t[o].interpolate, f = r.length; for (let d = 0; d < f; d++) { let m = EF(r[d], c[s], l[s], a[o]); !u && m !== t[o].interpolatorOffsets[d] && (u = !0), t[o].offset[d] = m } u && (t[o].interpolate = xo(t[o].offset, fd(r)), t[o].interpolatorOffsets = [...t[o].offset]), t[o].progress = t[o].interpolate(t[o].current) } function FF(e, t = e, n) { if (n.x.targetOffset = 0, n.y.targetOffset = 0, t !== e) { let r = t; for (; r && r !== e;)n.x.targetOffset += r.offsetLeft, n.y.targetOffset += r.offsetTop, r = r.offsetParent } n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth, n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight, n.x.containerLength = e.clientWidth, n.y.containerLength = e.clientHeight } function IF(e, t, n, r = {}) { return { measure: () => FF(e, r.target, n), update: i => { SF(e, n, i), (r.offset || r.target) && _F(e, n, r) }, notify: () => t(n) } } var gs = new WeakMap, iy = new WeakMap, Sf = new WeakMap, oy = e => e === document.documentElement ? I : e; function wo(e, { container: t = document.documentElement, ...n } = {}) { let r = Sf.get(t); r || (r = new Set, Sf.set(t, r)); let i = xF(), o = IF(t, e, i, n); if (r.add(o), !gs.has(t)) { let a = () => { for (let d of r) d.measure() }, l = () => { for (let d of r) d.update(We.timestamp) }, c = () => { for (let d of r) d.notify() }, u = () => { Y.read(a, !1, !0), Y.read(l, !1, !0), Y.update(c, !1, !0) }; gs.set(t, u); let f = oy(t); I.addEventListener("resize", u, { passive: !0 }), t !== document.documentElement && iy.set(t, yF(t, u)), f.addEventListener("scroll", u, { passive: !0 }) } let s = gs.get(t); return Y.read(s, !1, !0), () => { var a; Ht(s); let l = Sf.get(t); if (!l || (l.delete(o), l.size)) return; let c = gs.get(t); gs.delete(t), c && (oy(t).removeEventListener("scroll", c), (a = iy.get(t)) === null || a === void 0 || a(), I.removeEventListener("resize", c)) } } function sy(e, t) { vo(!!(!t || t.current), `You have defined a ${e} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`) } var LF = () => ({ scrollX: Ue(0), scrollY: Ue(0), scrollXProgress: Ue(0), scrollYProgress: Ue(0) }); function tb({ container: e, target: t, layoutEffect: n = !0, ...r } = {}) { let i = Jn(LF); return (n ? Gr : N)(() => (sy("target", t), sy("container", e), wo(({ x: s, y: a }) => { i.scrollX.set(s.current), i.scrollXProgress.set(s.progress), i.scrollY.set(a.current), i.scrollYProgress.set(a.progress) }, { ...r, container: e?.current || void 0, target: t?.current || void 0 })), [e, t, JSON.stringify(r.offset)]), i } function nb() { !kd.current && h0(); let [e] = Qe(El.current); return e } function Li() { let e = nb(), { reducedMotion: t } = V(xr); return t === "never" ? !1 : t === "always" ? !0 : e } function MF(e) { e.values.forEach(t => t.stop()) } function Nf(e, t) { [...t].reverse().forEach(r => { let i = e.getVariant(r); i && bd(e, i), e.variantChildren && e.variantChildren.forEach(o => { Nf(o, t) }) }) } function OF(e, t) { if (Array.isArray(t)) return Nf(e, t); if (typeof t == "string") return Nf(e, [t]); bd(e, t) } function rb() { let e = !1, t = new Set, n = { subscribe(r) { return t.add(r), () => void t.delete(r) }, start(r, i) { Jt(e, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook."); let o = []; return t.forEach(s => { o.push(wd(s, r, { transitionOverride: i })) }), Promise.all(o) }, set(r) { return Jt(e, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook."), t.forEach(i => { OF(i, r) }) }, stop() { t.forEach(r => { MF(r) }) }, mount() { return e = !0, () => { e = !1, n.stop() } } }; return n } var ib = (e, t, n) => { let r = t - e; return ((n - e) % r + r) % r + e }; function DF(e) { return typeof e == "object" && !Array.isArray(e) } function AF(e) { let t = { presenceContext: null, props: {}, visualState: { renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {} }, latestValues: {} } }, n = B0(e) ? new G0(t) : new U0(t); n.mount(e), kr.set(e, n) } function VF(e, t = 100) { let n = Ds({ keyframes: [0, t], ...e }), r = Math.min(Xy(n), Ff); return { type: "keyframes", ease: i => n.next(r * i).value / t, duration: Qn(r) } } function ay(e, t, n, r) { var i; return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : (i = r.get(t)) !== null && i !== void 0 ? i : e } function BF(e, t) { return Uy(e) ? e[ib(0, e.length, t)] : e } function zF(e, t, n) { for (let r = 0; r < e.length; r++) { let i = e[r]; i.at > t && i.at < n && (Os(e, i), r--) } } function $F(e, t, n, r, i, o) { zF(e, i, o); for (let s = 0; s < t.length; s++)e.push({ value: t[s], at: Fe(i, o, r[s]), easing: BF(n, s) }) } function NF(e, t) { return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at } var HF = "easeInOut"; function jF(e, { defaultTransition: t = {}, ...n } = {}, r) { let i = t.duration || .3, o = new Map, s = new Map, a = {}, l = new Map, c = 0, u = 0, f = 0; for (let d = 0; d < e.length; d++) { let m = e[d]; if (typeof m == "string") { l.set(m, u); continue } else if (!Array.isArray(m)) { l.set(m.name, ay(u, m.at, c, l)); continue } let [y, g, b = {}] = m; b.at !== void 0 && (u = ay(u, b.at, c, l)); let h = 0, p = (v, w, C, S = 0, R = 0) => { let E = WF(v), { delay: L = 0, times: F = fd(E), type: z = "keyframes", ...D } = w, { ease: K = t.ease || "easeOut", duration: U } = w, $ = typeof L == "function" ? L(S, R) : L, W = E.length; if (W <= 2 && z === "spring") { let ne = 100; if (W === 2 && qF(E)) { let pe = E[1] - E[0]; ne = Math.abs(pe) } let be = { ...D }; U !== void 0 && (be.duration = Fn(U)); let re = VF(be, ne); K = re.ease, U = re.duration } U ?? (U = i); let ee = u + $, te = ee + U; F.length === 1 && F[0] === 0 && (F[1] = 1); let q = F.length - E.length; q > 0 && Gy(F, q), E.length === 1 && E.unshift(null), $F(C, E, K, F, ee, te), h = Math.max($ + U, h), f = Math.max(te, f) }; if (Oe(y)) { let v = ly(y, s); p(g, b, cy("default", v)) } else { let v = jl(y, r, a), w = v.length; for (let C = 0; C < w; C++) { g = g, b = b; let S = v[C], R = ly(S, s); for (let E in g) p(g[E], UF(b, E), cy(E, R), C, w) } } c = u, u += h } return s.forEach((d, m) => { for (let y in d) { let g = d[y]; g.sort(NF); let b = [], h = [], p = []; for (let w = 0; w < g.length; w++) { let { at: C, value: S, easing: R } = g[w]; b.push(S), h.push(Ur(0, f, C)), p.push(R || "easeOut") } h[0] !== 0 && (h.unshift(0), b.unshift(b[0]), p.unshift(HF)), h[h.length - 1] !== 1 && (h.push(1), b.push(null)), o.has(m) || o.set(m, { keyframes: {}, transition: {} }); let v = o.get(m); v.keyframes[y] = b, v.transition[y] = { ...t, duration: f, ease: p, times: h, ...n } } }), o } function ly(e, t) { return !t.has(e) && t.set(e, {}), t.get(e) } function cy(e, t) { return t[e] || (t[e] = []), t[e] } function WF(e) { return Array.isArray(e) ? e : [e] } function UF(e, t) { return e[t] ? { ...e, ...e[t] } : { ...e } } var GF = e => typeof e == "number", qF = e => e.every(GF); function ob(e, t, n, r) { let i = jl(e, r), o = i.length; Jt(!!o, "No valid element provided."); let s = []; for (let a = 0; a < o; a++) { let l = i[a]; kr.has(l) || AF(l); let c = kr.get(l), u = { ...n }; typeof u.delay == "function" && (u.delay = u.delay(a, o)), s.push(...xd(c, { ...t, transition: u }, {})) } return new vd(s) } var XF = e => Array.isArray(e) && Array.isArray(e[0]); function YF(e, t, n) { let r = []; return jF(e, t, n).forEach(({ keyframes: o, transition: s }, a) => { let l; Oe(a) ? l = Fd(a, o.default, s.default) : l = ob(a, o, s), r.push(l) }), new vd(r) } var sb = e => { function t(n, r, i) { let o; return XF(n) ? o = YF(n, r, e) : DF(r) ? o = ob(n, r, i, e) : o = Fd(n, r, i), e && e.animations.push(o), o } return t }, tr = sb(); function ab() { let e = Jn(rb); return Gr(e.mount, []), e } var lb = ab; var KF = { some: 0, all: 1 }; function Dd(e, t, { root: n, margin: r, amount: i = "some" } = {}) { let o = jl(e), s = new WeakMap, a = c => { c.forEach(u => { let f = s.get(u.target); if (u.isIntersecting !== !!f) if (u.isIntersecting) { let d = t(u); typeof d == "function" ? s.set(u.target, d) : l.unobserve(u.target) } else f && (f(u), s.delete(u.target)) }) }, l = new IntersectionObserver(a, { root: n, rootMargin: r, threshold: typeof i == "number" ? i : KF[i] }); return o.forEach(c => l.observe(c)), () => l.disconnect() } function Ad(e) { return e !== null && typeof e == "object" && Xf in e } function cb(e) { if (Ad(e)) return e[Xf] } function Vd() { return QF } function QF(e) { Ii.current && (Ii.current.isUpdating = !1, Ii.current.blockUpdate(), e && e()) } function ub() { let [e, t] = Md(), n = Vd(), r = A(); return N(() => { Y.postRender(() => Y.postRender(() => { t === r.current && (Cl.current = !1) })) }, [t]), i => { n(() => { Cl.current = !0, e(), i(), r.current = t + 1 }) } } function fb() { return se(() => { let t = Ii.current; t && t.resetTree() }, []) } var uy = () => ({}); var _N = Dl({ scrapeMotionValuesFromProps: uy, createRenderState: uy }); function ZF(e, t) { if (e === "first") return 0; { let n = t - 1; return e === "last" ? n : n / 2 } } function Bd(e = .1, { startDelay: t = 0, from: n = 0, ease: r } = {}) { return (i, o) => { let s = typeof n == "number" ? n : ZF(n, o), a = Math.abs(s - i), l = e * a; if (r) { let c = o * e; l = _f(r)(l / c) * c } return t + l } } var JF = vs.reduce((e, t) => (e[t] = n => Ht(n), e), {}); var OL = {}; of(OL, { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: () => SL, createPortal: () => kL, createRoot: () => CL, default: () => P1, findDOMNode: () => TL, flushSync: () => EL, hydrate: () => RL, hydrateRoot: () => PL, render: () => _L, unmountComponentAtNode: () => FL, unstable_batchedUpdates: () => IL, unstable_renderSubtreeIntoContainer: () => LL, version: () => ML }); var Yl = {}; of(Yl, { default: () => Q, unstable_IdlePriority: () => nI, unstable_ImmediatePriority: () => rI, unstable_LowPriority: () => iI, unstable_NormalPriority: () => oI, unstable_Profiling: () => sI, unstable_UserBlockingPriority: () => aI, unstable_cancelCallback: () => lI, unstable_continueExecution: () => cI, unstable_forceFrameRate: () => uI, unstable_getCurrentPriorityLevel: () => fI, unstable_getFirstCallbackNode: () => dI, unstable_next: () => hI, unstable_now: () => tI, unstable_pauseExecution: () => pI, unstable_requestPaint: () => mI, unstable_runWithPriority: () => gI, unstable_scheduleCallback: () => vI, unstable_shouldYield: () => yI, unstable_wrapCallback: () => bI }); var Q = {}; function Hd(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < Wl(i, t))) break e; e[r] = t, e[n] = i, n = r } } function In(e) { return e.length === 0 ? null : e[0] } function Gl(e) { if (e.length === 0) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, o = i >>> 1; r < o;) { var s = 2 * (r + 1) - 1, a = e[s], l = s + 1, c = e[l]; if (0 > Wl(a, n)) l < i && 0 > Wl(c, a) ? (e[r] = c, e[l] = n, r = l) : (e[r] = a, e[s] = n, r = s); else { if (!(l < i && 0 > Wl(c, n))) break e; e[r] = c, e[l] = n, r = l } } } return t } function Wl(e, t) { var n = e.sortIndex - t.sortIndex; return n !== 0 ? n : e.id - t.id } typeof performance == "object" && typeof performance.now == "function" ? (db = performance, Q.unstable_now = function () { return db.now() }) : (zd = Date, hb = zd.now(), Q.unstable_now = function () { return zd.now() - hb }); var db, zd, hb, nr = [], Yr = [], eI = 1, vn = null, Et = 3, ql = !1, Mi = !1, zs = !1, gb = typeof setTimeout == "function" ? setTimeout : null, vb = typeof clearTimeout == "function" ? clearTimeout : null, pb = typeof setImmediate < "u" ? setImmediate : null; typeof Ne < "u" && Ne.scheduling !== void 0 && Ne.scheduling.isInputPending !== void 0 && Ne.scheduling.isInputPending.bind(Ne.scheduling); function jd(e) { for (var t = In(Yr); t !== null;) { if (t.callback === null) Gl(Yr); else { if (!(t.startTime <= e)) break; Gl(Yr), t.sortIndex = t.expirationTime, Hd(nr, t) } t = In(Yr) } } function Wd(e) { if (zs = !1, jd(e), !Mi) if (In(nr) !== null) Mi = !0, Gd(Ud); else { var t = In(Yr); t !== null && qd(Wd, t.startTime - e) } } function Ud(e, t) { Mi = !1, zs && (zs = !1, vb($s), $s = -1), ql = !0; var n = Et; try { for (jd(t), vn = In(nr); vn !== null && (!(vn.expirationTime > t) || e && !xb());) { var r = vn.callback; if (typeof r == "function") { vn.callback = null, Et = vn.priorityLevel; var i = r(vn.expirationTime <= t); t = Q.unstable_now(), typeof i == "function" ? vn.callback = i : vn === In(nr) && Gl(nr), jd(t) } else Gl(nr); vn = In(nr) } if (vn !== null) var o = !0; else { var s = In(Yr); s !== null && qd(Wd, s.startTime - t), o = !1 } return o } finally { vn = null, Et = n, ql = !1 } } var Xl = !1, Ul = null, $s = -1, yb = 5, bb = -1; function xb() { return !(Q.unstable_now() - bb < yb) } function $d() { if (Ul !== null) { var e = Q.unstable_now(); bb = e; var t = !0; try { t = Ul(!0, e) } finally { t ? Bs() : (Xl = !1, Ul = null) } } else Xl = !1 } var Bs; typeof pb == "function" ? Bs = function () { pb($d) } : typeof MessageChannel < "u" ? (Nd = new MessageChannel, mb = Nd.port2, Nd.port1.onmessage = $d, Bs = function () { mb.postMessage(null) }) : Bs = function () { gb($d, 0) }; var Nd, mb; function Gd(e) { Ul = e, Xl || (Xl = !0, Bs()) } function qd(e, t) { $s = gb(function () { e(Q.unstable_now()) }, t) } Q.unstable_IdlePriority = 5; Q.unstable_ImmediatePriority = 1; Q.unstable_LowPriority = 4; Q.unstable_NormalPriority = 3; Q.unstable_Profiling = null; Q.unstable_UserBlockingPriority = 2; Q.unstable_cancelCallback = function (e) { e.callback = null }; Q.unstable_continueExecution = function () { Mi || ql || (Mi = !0, Gd(Ud)) }; Q.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : yb = 0 < e ? Math.floor(1e3 / e) : 5 }; Q.unstable_getCurrentPriorityLevel = function () { return Et }; Q.unstable_getFirstCallbackNode = function () { return In(nr) }; Q.unstable_next = function (e) { switch (Et) { case 1: case 2: case 3: var t = 3; break; default: t = Et }var n = Et; Et = t; try { return e() } finally { Et = n } }; Q.unstable_pauseExecution = function () { }; Q.unstable_requestPaint = function () { }; Q.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = Et; Et = e; try { return t() } finally { Et = n } }; Q.unstable_scheduleCallback = function (e, t, n) { var r = Q.unstable_now(); switch (typeof n == "object" && n !== null ? (n = n.delay, n = typeof n == "number" && 0 < n ? r + n : r) : n = r, e) { case 1: var i = -1; break; case 2: i = 250; break; case 5: i = 1073741823; break; case 4: i = 1e4; break; default: i = 5e3 }return i = n + i, e = { id: eI++, callback: t, priorityLevel: e, startTime: n, expirationTime: i, sortIndex: -1 }, n > r ? (e.sortIndex = n, Hd(Yr, e), In(nr) === null && e === In(Yr) && (zs ? (vb($s), $s = -1) : zs = !0, qd(Wd, n - r))) : (e.sortIndex = i, Hd(nr, e), Mi || ql || (Mi = !0, Gd(Ud))), e }; Q.unstable_shouldYield = xb; Q.unstable_wrapCallback = function (e) { var t = Et; return function () { var n = Et; Et = t; try { return e.apply(this, arguments) } finally { Et = n } } }; var tI = Q.unstable_now, nI = Q.unstable_IdlePriority, rI = Q.unstable_ImmediatePriority, iI = Q.unstable_LowPriority, oI = Q.unstable_NormalPriority, sI = Q.unstable_Profiling, aI = Q.unstable_UserBlockingPriority, lI = Q.unstable_cancelCallback, cI = Q.unstable_continueExecution, uI = Q.unstable_forceFrameRate, fI = Q.unstable_getCurrentPriorityLevel, dI = Q.unstable_getFirstCallbackNode, hI = Q.unstable_next, pI = Q.unstable_pauseExecution, mI = Q.unstable_requestPaint, gI = Q.unstable_runWithPriority, vI = Q.unstable_scheduleCallback, yI = Q.unstable_shouldYield, bI = Q.unstable_wrapCallback; var xI = "default" in Ct ? x : Ct, wI = "default" in Yl ? Q : Yl, sn = {}, Rx = xI, on = wI; function M(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Px = new Set, la = {}; function Gi(e, t) { Ho(e, t), Ho(e + "Capture", t) } function Ho(e, t) { for (la[e] = t, e = 0; e < t.length; e++)Px.add(t[e]) } var _r = !(typeof I > "u" || typeof I.document > "u" || typeof I.document.createElement > "u"), gh = Object.prototype.hasOwnProperty, SI = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, wb = {}, Sb = {}; function kI(e) { return gh.call(Sb, e) ? !0 : gh.call(wb, e) ? !1 : SI.test(e) ? Sb[e] = !0 : (wb[e] = !0, !1) } function CI(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function TI(e, t, n, r) { if (t === null || typeof t > "u" || CI(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function Bt(e, t, n, r, i, o, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s } var bt = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { bt[e] = new Bt(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; bt[t] = new Bt(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { bt[e] = new Bt(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { bt[e] = new Bt(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { bt[e] = new Bt(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { bt[e] = new Bt(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { bt[e] = new Bt(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { bt[e] = new Bt(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { bt[e] = new Bt(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var ap = /[\-:]([a-z])/g; function lp(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(ap, lp); bt[t] = new Bt(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(ap, lp); bt[t] = new Bt(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(ap, lp); bt[t] = new Bt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { bt[e] = new Bt(e, 1, !1, e.toLowerCase(), null, !1, !1) }); bt.xlinkHref = new Bt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { bt[e] = new Bt(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function cp(e, t, n, r) { var i = bt.hasOwnProperty(t) ? bt[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (TI(t, n, i, r) && (n = null), r || i === null ? kI(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type !== 3 && "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var Mr = Rx.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Kl = Symbol.for("react.element"), Co = Symbol.for("react.portal"), To = Symbol.for("react.fragment"), up = Symbol.for("react.strict_mode"), vh = Symbol.for("react.profiler"), _x = Symbol.for("react.provider"), Fx = Symbol.for("react.context"), fp = Symbol.for("react.forward_ref"), yh = Symbol.for("react.suspense"), bh = Symbol.for("react.suspense_list"), dp = Symbol.for("react.memo"), Qr = Symbol.for("react.lazy"); Symbol.for("react.scope"); Symbol.for("react.debug_trace_mode"); var Ix = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"); Symbol.for("react.cache"); Symbol.for("react.tracing_marker"); var kb = Symbol.iterator; function Ns(e) { return e === null || typeof e != "object" ? null : (e = kb && e[kb] || e["@@iterator"], typeof e == "function" ? e : null) } var Xd, $e = Object.assign; function Ys(e) {
    if (Xd === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); Xd = t && t[1] || "" } return `
`+ Xd + e
} var Yd = !1; function Kd(e, t) {
    if (!e || Yd) return ""; Yd = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (i[s] !== o[a]) {
                if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || i[s] !== o[a]) {
                    var l = `
`+ i[s].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                } while (1 <= s && 0 <= a); break
            }
        }
    } finally { Yd = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? Ys(e) : ""
} function EI(e) { switch (e.tag) { case 5: return Ys(e.type); case 16: return Ys("Lazy"); case 13: return Ys("Suspense"); case 19: return Ys("SuspenseList"); case 0: case 2: case 15: return e = Kd(e.type, !1), e; case 11: return e = Kd(e.type.render, !1), e; case 1: return e = Kd(e.type, !0), e; default: return "" } } function xh(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case To: return "Fragment"; case Co: return "Portal"; case vh: return "Profiler"; case up: return "StrictMode"; case yh: return "Suspense"; case bh: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Fx: return (e.displayName || "Context") + ".Consumer"; case _x: return (e._context.displayName || "Context") + ".Provider"; case fp: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case dp: return t = e.displayName || null, t !== null ? t : xh(e.type) || "Memo"; case Qr: t = e._payload, e = e._init; try { return xh(e(t)) } catch { } }return null } function RI(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return xh(t); case 8: return t === up ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function fi(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Lx(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function PI(e) { var t = Lx(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, o.call(this, s) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Ql(e) { e._valueTracker || (e._valueTracker = PI(e)) } function Mx(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = Lx(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n && (t.setValue(e), !0) } function Tc(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function wh(e, t) { var n = t.checked; return $e({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function Cb(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = fi(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function Ox(e, t) { t = t.checked, t != null && cp(e, "checked", t, !1) } function Sh(e, t) { Ox(e, t); var n = fi(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? kh(e, t.type, n) : t.hasOwnProperty("defaultValue") && kh(e, t.type, fi(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function Tb(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function kh(e, t, n) { t === "number" && Tc(e.ownerDocument) === e || (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Ks = Array.isArray; function Ao(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + fi(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function Ch(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(M(91)); return $e({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Eb(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(M(92)); if (Ks(n)) { if (1 < n.length) throw Error(M(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: fi(n) } } function Dx(e, t) { var n = fi(t.value), r = fi(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function Rb(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Ax(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Th(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Ax(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Zl, Vx = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Zl = Zl || document.createElement("div"), Zl.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Zl.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function ca(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Js = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, _I = ["Webkit", "ms", "Moz", "O"]; Object.keys(Js).forEach(function (e) { _I.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Js[t] = Js[e] }) }); function Bx(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Js.hasOwnProperty(e) && Js[e] ? ("" + t).trim() : t + "px" } function zx(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = Bx(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var FI = $e({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Eh(e, t) { if (t) { if (FI[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(M(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(M(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(M(61)) } if (t.style != null && typeof t.style != "object") throw Error(M(62)) } } function Rh(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Ph = null; function hp(e) { return e = e.target || e.srcElement || I, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var _h = null, Vo = null, Bo = null; function Pb(e) { if (e = Ra(e)) { if (typeof _h != "function") throw Error(M(280)); var t = e.stateNode; t && (t = Jc(t), _h(e.stateNode, e.type, t)) } } function $x(e) { Vo ? Bo ? Bo.push(e) : Bo = [e] : Vo = e } function Nx() { if (Vo) { var e = Vo, t = Bo; if (Bo = Vo = null, Pb(e), t) for (e = 0; e < t.length; e++)Pb(t[e]) } } function Hx(e, t) { return e(t) } function jx() { } var Qd = !1; function Wx(e, t, n) { if (Qd) return e(t, n); Qd = !0; try { return Hx(e, t, n) } finally { Qd = !1, (Vo !== null || Bo !== null) && (jx(), Nx()) } } function ua(e, t) { var n = e.stateNode; if (n === null) return null; var r = Jc(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(M(231, t, typeof n)); return n } var Fh = !1; if (_r) try { So = {}, Object.defineProperty(So, "passive", { get: function () { Fh = !0 } }), I.addEventListener("test", So, So), I.removeEventListener("test", So, So) } catch { Fh = !1 } var So; function II(e, t, n, r, i, o, s, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var ea = !1, Ec = null, Rc = !1, Ih = null, LI = { onError: function (e) { ea = !0, Ec = e } }; function MI(e, t, n, r, i, o, s, a, l) { ea = !1, Ec = null, II.apply(LI, arguments) } function OI(e, t, n, r, i, o, s, a, l) { if (MI.apply(this, arguments), ea) { if (!ea) throw Error(M(198)); var c = Ec; ea = !1, Ec = null, Rc || (Rc = !0, Ih = c) } } function qi(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, 4098 & t.flags && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Ux(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function _b(e) { if (qi(e) !== e) throw Error(M(188)) } function DI(e) { var t = e.alternate; if (!t) { if (t = qi(e), t === null) throw Error(M(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var o = i.alternate; if (o === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return _b(i), e; if (o === r) return _b(i), t; o = o.sibling } throw Error(M(188)) } if (n.return !== r.return) n = i, r = o; else { for (var s = !1, a = i.child; a;) { if (a === n) { s = !0, n = i, r = o; break } if (a === r) { s = !0, r = i, n = o; break } a = a.sibling } if (!s) { for (a = o.child; a;) { if (a === n) { s = !0, n = o, r = i; break } if (a === r) { s = !0, r = o, n = i; break } a = a.sibling } if (!s) throw Error(M(189)) } } if (n.alternate !== r) throw Error(M(190)) } if (n.tag !== 3) throw Error(M(188)); return n.stateNode.current === n ? e : t } function Gx(e) { return e = DI(e), e !== null ? qx(e) : null } function qx(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = qx(e); if (t !== null) return t; e = e.sibling } return null } var Xx = on.unstable_scheduleCallback, Fb = on.unstable_cancelCallback, AI = on.unstable_shouldYield, VI = on.unstable_requestPaint, Ye = on.unstable_now, BI = on.unstable_getCurrentPriorityLevel, pp = on.unstable_ImmediatePriority, Yx = on.unstable_UserBlockingPriority, Pc = on.unstable_NormalPriority, zI = on.unstable_LowPriority, Kx = on.unstable_IdlePriority, Yc = null, sr = null; function $I(e) { if (sr && typeof sr.onCommitFiberRoot == "function") try { sr.onCommitFiberRoot(Yc, e, void 0, (128 & e.current.flags) === 128) } catch { } } var An = Math.clz32 ? Math.clz32 : jI, NI = Math.log, HI = Math.LN2; function jI(e) { return e >>>= 0, e === 0 ? 32 : 31 - (NI(e) / HI | 0) | 0 } var Jl = 64, ec = 4194304; function Qs(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function _c(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, s = 268435455 & n; if (s !== 0) { var a = s & ~i; a !== 0 ? r = Qs(a) : (o &= s, o !== 0 && (r = Qs(o))) } else s = n & ~i, s !== 0 ? r = Qs(s) : o !== 0 && (r = Qs(o)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, o = t & -t, i >= o || i === 16 && (4194240 & o) !== 0)) return t; if (4 & r && (r |= 16 & n), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - An(t), i = 1 << n, r |= e[n], t &= ~i; return r } function WI(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function UI(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var s = 31 - An(o), a = 1 << s, l = i[s]; l === -1 ? a & n && !(a & r) || (i[s] = WI(a, t)) : l <= t && (e.expiredLanes |= a), o &= ~a } } function Lh(e) { return e = -1073741825 & e.pendingLanes, e !== 0 ? e : 1073741824 & e ? 1073741824 : 0 } function Qx() { var e = Jl; return Jl <<= 1, !(4194240 & Jl) && (Jl = 64), e } function Zd(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function Ta(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - An(t), e[t] = n } function GI(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - An(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } } function mp(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - An(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var we = 0; function Zx(e) { return e &= -e, 1 < e ? 4 < e ? 268435455 & e ? 16 : 536870912 : 4 : 1 } var Jx, gp, ew, tw, nw, Mh = !1, tc = [], ri = null, ii = null, oi = null, fa = new Map, da = new Map, Jr = [], qI = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Ib(e, t) { switch (e) { case "focusin": case "focusout": ri = null; break; case "dragenter": case "dragleave": ii = null; break; case "mouseover": case "mouseout": oi = null; break; case "pointerover": case "pointerout": fa.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": da.delete(t.pointerId) } } function Hs(e, t, n, r, i, o) { return e === null || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, t !== null && (t = Ra(t), t !== null && gp(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function XI(e, t, n, r, i) { switch (t) { case "focusin": return ri = Hs(ri, e, t, n, r, i), !0; case "dragenter": return ii = Hs(ii, e, t, n, r, i), !0; case "mouseover": return oi = Hs(oi, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return fa.set(o, Hs(fa.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, da.set(o, Hs(da.get(o) || null, e, t, n, r, i)), !0 }return !1 } function rw(e) { var t = Ai(e.target); if (t !== null) { var n = qi(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Ux(n), t !== null) { e.blockedOn = t, nw(e.priority, function () { ew(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function mc(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Oh(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n !== null) return t = Ra(n), t !== null && gp(t), e.blockedOn = n, !1; n = e.nativeEvent; var r = new n.constructor(n.type, n); Ph = r, n.target.dispatchEvent(r), Ph = null, t.shift() } return !0 } function Lb(e, t, n) { mc(e) && n.delete(t) } function YI() { Mh = !1, ri !== null && mc(ri) && (ri = null), ii !== null && mc(ii) && (ii = null), oi !== null && mc(oi) && (oi = null), fa.forEach(Lb), da.forEach(Lb) } function js(e, t) { e.blockedOn === t && (e.blockedOn = null, Mh || (Mh = !0, on.unstable_scheduleCallback(on.unstable_NormalPriority, YI))) } function ha(e) { function t(i) { return js(i, e) } if (0 < tc.length) { js(tc[0], e); for (var n = 1; n < tc.length; n++) { var r = tc[n]; r.blockedOn === e && (r.blockedOn = null) } } for (ri !== null && js(ri, e), ii !== null && js(ii, e), oi !== null && js(oi, e), fa.forEach(t), da.forEach(t), n = 0; n < Jr.length; n++)r = Jr[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < Jr.length && (n = Jr[0], n.blockedOn === null);)rw(n), n.blockedOn === null && Jr.shift() } var zo = Mr.ReactCurrentBatchConfig, Fc = !0; function KI(e, t, n, r) { var i = we, o = zo.transition; zo.transition = null; try { we = 1, vp(e, t, n, r) } finally { we = i, zo.transition = o } } function QI(e, t, n, r) { var i = we, o = zo.transition; zo.transition = null; try { we = 4, vp(e, t, n, r) } finally { we = i, zo.transition = o } } function vp(e, t, n, r) { if (Fc) { var i = Oh(e, t, n, r); if (i === null) oh(e, t, r, Ic, n), Ib(e, r); else if (XI(i, e, t, n, r)) r.stopPropagation(); else if (Ib(e, r), 4 & t && -1 < qI.indexOf(e)) { for (; i !== null;) { var o = Ra(i); if (o !== null && Jx(o), o = Oh(e, t, n, r), o === null && oh(e, t, r, Ic, n), o === i) break; i = o } i !== null && r.stopPropagation() } else oh(e, t, r, null, n) } } var Ic = null; function Oh(e, t, n, r) { if (Ic = null, e = hp(r), e = Ai(e), e !== null) if (t = qi(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Ux(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Ic = e, null } function iw(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (BI()) { case pp: return 1; case Yx: return 4; case Pc: case zI: return 16; case Kx: return 536870912; default: return 16 }default: return 16 } } var ti = null, yp = null, gc = null; function ow() { if (gc) return gc; var e, t, n = yp, r = n.length, i = "value" in ti ? ti.value : ti.textContent, o = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var s = r - e; for (t = 1; t <= s && n[r - t] === i[o - t]; t++); return gc = i.slice(e, 1 < t ? 1 - t : void 0) } function vc(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function nc() { return !0 } function Mb() { return !1 } function an(e) { function t(n, r, i, o, s) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(o) : o[a]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? nc : Mb, this.isPropagationStopped = Mb, this } return $e(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = nc) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = nc) }, persist: function () { }, isPersistent: nc }), t } var Jd, eh, Ws, Yo = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, bp = an(Yo), Ea = $e({}, Yo, { view: 0, detail: 0 }), ZI = an(Ea), Kc = $e({}, Ea, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: xp, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Ws && (Ws && e.type === "mousemove" ? (Jd = e.screenX - Ws.screenX, eh = e.screenY - Ws.screenY) : eh = Jd = 0, Ws = e), Jd) }, movementY: function (e) { return "movementY" in e ? e.movementY : eh } }), Ob = an(Kc), JI = $e({}, Kc, { dataTransfer: 0 }), e2 = an(JI), t2 = $e({}, Ea, { relatedTarget: 0 }), th = an(t2), n2 = $e({}, Yo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), r2 = an(n2), i2 = $e({}, Yo, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : I.clipboardData } }), o2 = an(i2), s2 = $e({}, Yo, { data: 0 }), Db = an(s2), a2 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, l2 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, c2 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function u2(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = c2[e]) && !!t[e] } function xp() { return u2 } var f2 = $e({}, Ea, { key: function (e) { if (e.key) { var t = a2[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = vc(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? l2[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: xp, charCode: function (e) { return e.type === "keypress" ? vc(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? vc(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), d2 = an(f2), h2 = $e({}, Kc, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Ab = an(h2), p2 = $e({}, Ea, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: xp }), m2 = an(p2), g2 = $e({}, Yo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), v2 = an(g2), y2 = $e({}, Kc, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), b2 = an(y2), x2 = [9, 13, 27, 32], wp = _r && "CompositionEvent" in I, ta = null; _r && "documentMode" in document && (ta = document.documentMode); var w2 = _r && "TextEvent" in I && !ta, sw = _r && (!wp || ta && 8 < ta && 11 >= ta), Vb = String.fromCharCode(32), Bb = !1; function aw(e, t) { switch (e) { case "keyup": return x2.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function lw(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Eo = !1; function S2(e, t) { switch (e) { case "compositionend": return lw(t); case "keypress": return t.which !== 32 ? null : (Bb = !0, Vb); case "textInput": return e = t.data, e === Vb && Bb ? null : e; default: return null } } function k2(e, t) { if (Eo) return e === "compositionend" || !wp && aw(e, t) ? (e = ow(), gc = yp = ti = null, Eo = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return sw && t.locale !== "ko" ? null : t.data; default: return null } } var C2 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function zb(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!C2[e.type] : t === "textarea" } function cw(e, t, n, r) { $x(r), t = Lc(t, "onChange"), 0 < t.length && (n = new bp("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var na = null, pa = null; function T2(e) { xw(e, 0) } function Qc(e) { var t = _o(e); if (Mx(t)) return e } function E2(e, t) { if (e === "change") return t } var uw = !1; _r && (_r ? (ic = "oninput" in document, ic || (nh = document.createElement("div"), nh.setAttribute("oninput", "return;"), ic = typeof nh.oninput == "function"), rc = ic) : rc = !1, uw = rc && (!document.documentMode || 9 < document.documentMode)); var rc, ic, nh; function $b() { na && (na.detachEvent("onpropertychange", fw), pa = na = null) } function fw(e) { if (e.propertyName === "value" && Qc(pa)) { var t = []; cw(t, pa, e, hp(e)), Wx(T2, t) } } function R2(e, t, n) { e === "focusin" ? ($b(), na = t, pa = n, na.attachEvent("onpropertychange", fw)) : e === "focusout" && $b() } function P2(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Qc(pa) } function _2(e, t) { if (e === "click") return Qc(t) } function F2(e, t) { if (e === "input" || e === "change") return Qc(t) } function I2(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Bn = typeof Object.is == "function" ? Object.is : I2; function ma(e, t) { if (Bn(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!gh.call(t, i) || !Bn(e[i], t[i])) return !1 } return !0 } function Nb(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Hb(e, t) { var n = Nb(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Nb(n) } } function dw(e, t) { return !(!e || !t) && (e === t || (!e || e.nodeType !== 3) && (t && t.nodeType === 3 ? dw(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function hw() { for (var e = I, t = Tc(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (!n) break; e = t.contentWindow, t = Tc(e.document) } return t } function Sp(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function L2(e) { var t = hw(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && dw(n.ownerDocument.documentElement, n)) { if (r !== null && Sp(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || I, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = r.end === void 0 ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = Hb(n, o); var s = Hb(n, r); i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var M2 = _r && "documentMode" in document && 11 >= document.documentMode, Ro = null, Dh = null, ra = null, Ah = !1; function jb(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Ah || Ro == null || Ro !== Tc(r) || (r = Ro, "selectionStart" in r && Sp(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || I).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), ra && ma(ra, r) || (ra = r, r = Lc(Dh, "onSelect"), 0 < r.length && (t = new bp("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = Ro))) } function oc(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Po = { animationend: oc("Animation", "AnimationEnd"), animationiteration: oc("Animation", "AnimationIteration"), animationstart: oc("Animation", "AnimationStart"), transitionend: oc("Transition", "TransitionEnd") }, rh = {}, pw = {}; _r && (pw = document.createElement("div").style, "AnimationEvent" in I || (delete Po.animationend.animation, delete Po.animationiteration.animation, delete Po.animationstart.animation), "TransitionEvent" in I || delete Po.transitionend.transition); function Zc(e) { if (rh[e]) return rh[e]; if (!Po[e]) return e; var t, n = Po[e]; for (t in n) if (n.hasOwnProperty(t) && t in pw) return rh[e] = n[t]; return e } var mw = Zc("animationend"), gw = Zc("animationiteration"), vw = Zc("animationstart"), yw = Zc("transitionend"), bw = new Map, Wb = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function hi(e, t) { bw.set(e, t), Gi(t, [e]) } for (sc = 0; sc < Wb.length; sc++)ac = Wb[sc], Ub = ac.toLowerCase(), Gb = ac[0].toUpperCase() + ac.slice(1), hi(Ub, "on" + Gb); var ac, Ub, Gb, sc; hi(mw, "onAnimationEnd"); hi(gw, "onAnimationIteration"); hi(vw, "onAnimationStart"); hi("dblclick", "onDoubleClick"); hi("focusin", "onFocus"); hi("focusout", "onBlur"); hi(yw, "onTransitionEnd"); Ho("onMouseEnter", ["mouseout", "mouseover"]); Ho("onMouseLeave", ["mouseout", "mouseover"]); Ho("onPointerEnter", ["pointerout", "pointerover"]); Ho("onPointerLeave", ["pointerout", "pointerover"]); Gi("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Gi("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Gi("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Gi("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Gi("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Gi("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Zs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), O2 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Zs)); function qb(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, OI(r, t, void 0, e), e.currentTarget = null } function xw(e, t) { t = (4 & t) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var a = r[s], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== o && i.isPropagationStopped()) break e; qb(i, a, c), o = l } else for (s = 0; s < r.length; s++) { if (a = r[s], l = a.instance, c = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break e; qb(i, a, c), o = l } } } if (Rc) throw e = Ih, Rc = !1, Ih = null, e } function Ie(e, t) { var n = t[Nh]; n === void 0 && (n = t[Nh] = new Set); var r = e + "__bubble"; n.has(r) || (ww(t, e, 2, !1), n.add(r)) } function ih(e, t, n) { var r = 0; t && (r |= 4), ww(n, e, r, t) } var lc = "_reactListening" + Math.random().toString(36).slice(2); function ga(e) { if (!e[lc]) { e[lc] = !0, Px.forEach(function (n) { n !== "selectionchange" && (O2.has(n) || ih(n, !1, e), ih(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[lc] || (t[lc] = !0, ih("selectionchange", !1, t)) } } function ww(e, t, n, r) { switch (iw(t)) { case 1: var i = KI; break; case 4: i = QI; break; default: i = vp }n = i.bind(null, t, n, e), i = void 0, !Fh || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function oh(e, t, n, r, i) { var o = r; if (!(1 & t) && !(2 & t) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var l = s.tag; if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; s = s.return } for (; a !== null;) { if (s = Ai(a), s === null) return; if (l = s.tag, l === 5 || l === 6) { r = o = s; continue e } a = a.parentNode } } r = r.return } Wx(function () { var c = o, u = hp(n), f = []; e: { var d = bw.get(e); if (d !== void 0) { var m = bp, y = e; switch (e) { case "keypress": if (vc(n) === 0) break e; case "keydown": case "keyup": m = d2; break; case "focusin": y = "focus", m = th; break; case "focusout": y = "blur", m = th; break; case "beforeblur": case "afterblur": m = th; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": m = Ob; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": m = e2; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": m = m2; break; case mw: case gw: case vw: m = r2; break; case yw: m = v2; break; case "scroll": m = ZI; break; case "wheel": m = b2; break; case "copy": case "cut": case "paste": m = o2; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": m = Ab }var g = (4 & t) !== 0, b = !g && e === "scroll", h = g ? d !== null ? d + "Capture" : null : d; g = []; for (var p, v = c; v !== null;) { p = v; var w = p.stateNode; if (p.tag === 5 && w !== null && (p = w, h !== null && (w = ua(v, h), w != null && g.push(va(v, w, p)))), b) break; v = v.return } 0 < g.length && (d = new m(d, y, null, n, u), f.push({ event: d, listeners: g })) } } if (!(7 & t)) { if (d = e === "mouseover" || e === "pointerover", m = e === "mouseout" || e === "pointerout", (!d || n === Ph || !(y = n.relatedTarget || n.fromElement) || !Ai(y) && !y[Fr]) && (m || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : I, m ? (y = n.relatedTarget || n.toElement, m = c, y = y ? Ai(y) : null, y !== null && (b = qi(y), y !== b || y.tag !== 5 && y.tag !== 6) && (y = null)) : (m = null, y = c), m !== y)) { if (g = Ob, w = "onMouseLeave", h = "onMouseEnter", v = "mouse", e !== "pointerout" && e !== "pointerover" || (g = Ab, w = "onPointerLeave", h = "onPointerEnter", v = "pointer"), b = m == null ? d : _o(m), p = y == null ? d : _o(y), d = new g(w, v + "leave", m, n, u), d.target = b, d.relatedTarget = p, w = null, Ai(u) === c && (g = new g(h, v + "enter", y, n, u), g.target = p, g.relatedTarget = b, w = g), b = w, m && y) e: { for (g = m, h = y, v = 0, p = g; p; p = ko(p))v++; for (p = 0, w = h; w; w = ko(w))p++; for (; 0 < v - p;)g = ko(g), v--; for (; 0 < p - v;)h = ko(h), p--; for (; v--;) { if (g === h || h !== null && g === h.alternate) break e; g = ko(g), h = ko(h) } g = null } else g = null; m !== null && Xb(f, d, m, g, !1), y !== null && b !== null && Xb(f, b, y, g, !0) } if (d = c ? _o(c) : I, m = d.nodeName && d.nodeName.toLowerCase(), m === "select" || m === "input" && d.type === "file") var C = E2; else if (zb(d)) if (uw) C = F2; else { C = P2; var S = R2 } else (m = d.nodeName) && m.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (C = _2); switch (C && (C = C(e, c)) ? cw(f, C, n, u) : (S && S(e, d, c), e === "focusout" && (S = d._wrapperState) && S.controlled && d.type === "number" && kh(d, "number", d.value)), S = c ? _o(c) : I, e) { case "focusin": (zb(S) || S.contentEditable === "true") && (Ro = S, Dh = c, ra = null); break; case "focusout": ra = Dh = Ro = null; break; case "mousedown": Ah = !0; break; case "contextmenu": case "mouseup": case "dragend": Ah = !1, jb(f, n, u); break; case "selectionchange": if (M2) break; case "keydown": case "keyup": jb(f, n, u) }var R; if (wp) e: { switch (e) { case "compositionstart": var E = "onCompositionStart"; break e; case "compositionend": E = "onCompositionEnd"; break e; case "compositionupdate": E = "onCompositionUpdate"; break e }E = void 0 } else Eo ? aw(e, n) && (E = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (E = "onCompositionStart"); E && (sw && n.locale !== "ko" && (Eo || E !== "onCompositionStart" ? E === "onCompositionEnd" && Eo && (R = ow()) : (ti = u, yp = "value" in ti ? ti.value : ti.textContent, Eo = !0)), S = Lc(c, E), 0 < S.length && (E = new Db(E, e, null, n, u), f.push({ event: E, listeners: S }), R ? E.data = R : (R = lw(n), R !== null && (E.data = R)))), (R = w2 ? S2(e, n) : k2(e, n)) && (c = Lc(c, "onBeforeInput"), 0 < c.length && (u = new Db("onBeforeInput", "beforeinput", null, n, u), f.push({ event: u, listeners: c }), u.data = R)) } xw(f, t) }) } function va(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Lc(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, o = i.stateNode; i.tag === 5 && o !== null && (i = o, o = ua(e, n), o != null && r.unshift(va(e, o, i)), o = ua(e, t), o != null && r.push(va(e, o, i))), e = e.return } return r } function ko(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Xb(e, t, n, r, i) { for (var o = t._reactName, s = []; n !== null && n !== r;) { var a = n, l = a.alternate, c = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && c !== null && (a = c, i ? (l = ua(n, o), l != null && s.unshift(va(n, l, a))) : i || (l = ua(n, o), l != null && s.push(va(n, l, a)))), n = n.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var D2 = /\r\n?/g, A2 = /\u0000|\uFFFD/g; function Yb(e) {
    return (typeof e == "string" ? e : "" + e).replace(D2, `
`).replace(A2, "")
} function cc(e, t, n) { if (t = Yb(t), Yb(e) !== t && n) throw Error(M(425)) } function Mc() { } var Vh = null, Bh = null; function zh(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var $h = typeof setTimeout == "function" ? setTimeout : void 0, V2 = typeof clearTimeout == "function" ? clearTimeout : void 0, Kb = typeof Promise == "function" ? Promise : void 0, B2 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Kb < "u" ? function (e) { return Kb.resolve(null).then(e).catch(z2) } : $h; function z2(e) { setTimeout(function () { throw e }) } function sh(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), ha(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); ha(t) } function si(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Qb(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var Ko = Math.random().toString(36).slice(2), or = "__reactFiber$" + Ko, ya = "__reactProps$" + Ko, Fr = "__reactContainer$" + Ko, Nh = "__reactEvents$" + Ko, $2 = "__reactListeners$" + Ko, N2 = "__reactHandles$" + Ko; function Ai(e) { var t = e[or]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[Fr] || n[or]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Qb(e); e !== null;) { if (n = e[or]) return n; e = Qb(e) } return t } e = n, n = e.parentNode } return null } function Ra(e) { return e = e[or] || e[Fr], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function _o(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(M(33)) } function Jc(e) { return e[ya] || null } var Hh = [], Fo = -1; function pi(e) { return { current: e } } function Le(e) { 0 > Fo || (e.current = Hh[Fo], Hh[Fo] = null, Fo--) } function Re(e, t) { Fo++, Hh[Fo] = e.current, e.current = t } var di = {}, Ft = pi(di), qt = pi(!1), Ni = di; function jo(e, t) { var n = e.type.contextTypes; if (!n) return di; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, o = {}; for (i in n) o[i] = t[i]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o } function Xt(e) { return e = e.childContextTypes, e != null } function Oc() { Le(qt), Le(Ft) } function Zb(e, t, n) { if (Ft.current !== di) throw Error(M(168)); Re(Ft, t), Re(qt, n) } function Sw(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(M(108, RI(e) || "Unknown", i)); return $e({}, n, r) } function Dc(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || di, Ni = Ft.current, Re(Ft, e), Re(qt, qt.current), !0 } function Jb(e, t, n) { var r = e.stateNode; if (!r) throw Error(M(169)); n ? (e = Sw(e, t, Ni), r.__reactInternalMemoizedMergedChildContext = e, Le(qt), Le(Ft), Re(Ft, e)) : Le(qt), Re(qt, n) } var Tr = null, eu = !1, ah = !1; function kw(e) { Tr === null ? Tr = [e] : Tr.push(e) } function H2(e) { eu = !0, kw(e) } function mi() { if (!ah && Tr !== null) { ah = !0; var e = 0, t = we; try { var n = Tr; for (we = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } Tr = null, eu = !1 } catch (i) { throw Tr !== null && (Tr = Tr.slice(e + 1)), Xx(pp, mi), i } finally { we = t, ah = !1 } } return null } var Io = [], Lo = 0, Ac = null, Vc = 0, yn = [], bn = 0, Hi = null, Er = 1, Rr = ""; function Oi(e, t) { Io[Lo++] = Vc, Io[Lo++] = Ac, Ac = e, Vc = t } function Cw(e, t, n) { yn[bn++] = Er, yn[bn++] = Rr, yn[bn++] = Hi, Hi = e; var r = Er; e = Rr; var i = 32 - An(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - An(t) + i; if (30 < o) { var s = i - i % 5; o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Er = 1 << 32 - An(t) + i | n << i | r, Rr = o + e } else Er = 1 << o | n << i | r, Rr = e } function kp(e) { e.return !== null && (Oi(e, 1), Cw(e, 1, 0)) } function Cp(e) { for (; e === Ac;)Ac = Io[--Lo], Io[Lo] = null, Vc = Io[--Lo], Io[Lo] = null; for (; e === Hi;)Hi = yn[--bn], yn[bn] = null, Rr = yn[--bn], yn[bn] = null, Er = yn[--bn], yn[bn] = null } var rn = null, nn = null, De = !1, Dn = null; function Tw(e, t) { var n = xn(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function ex(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null && (e.stateNode = t, rn = e, nn = si(t.firstChild), !0); case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null && (e.stateNode = t, rn = e, nn = null, !0); case 13: return t = t.nodeType !== 8 ? null : t, t !== null && (n = Hi !== null ? { id: Er, overflow: Rr } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = xn(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, rn = e, nn = null, !0); default: return !1 } } function jh(e) { return (1 & e.mode) !== 0 && (128 & e.flags) === 0 } function Wh(e) { if (De) { var t = nn; if (t) { var n = t; if (!ex(e, t)) { if (jh(e)) throw Error(M(418)); t = si(n.nextSibling); var r = rn; t && ex(e, t) ? Tw(r, n) : (e.flags = -4097 & e.flags | 2, De = !1, rn = e) } } else { if (jh(e)) throw Error(M(418)); e.flags = -4097 & e.flags | 2, De = !1, rn = e } } } function tx(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; rn = e } function uc(e) { if (e !== rn) return !1; if (!De) return tx(e), De = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !zh(e.type, e.memoizedProps)), t && (t = nn)) { if (jh(e)) throw Ew(), Error(M(418)); for (; t;)Tw(e, t), t = si(t.nextSibling) } if (tx(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(M(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { nn = si(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } nn = null } } else nn = rn ? si(e.stateNode.nextSibling) : null; return !0 } function Ew() { for (var e = nn; e;)e = si(e.nextSibling) } function Wo() { nn = rn = null, De = !1 } function Tp(e) { Dn === null ? Dn = [e] : Dn.push(e) } var j2 = Mr.ReactCurrentBatchConfig; function Mn(e, t) { if (e && e.defaultProps) { t = $e({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } var Bc = pi(null), zc = null, Mo = null, Ep = null; function Rp() { Ep = Mo = zc = null } function Pp(e) { var t = Bc.current; Le(Bc), e._currentValue = t } function Uh(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function $o(e, t) { zc = e, Ep = Mo = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Gt = !0), e.firstContext = null) } function Sn(e) { var t = e._currentValue; if (Ep !== e) if (e = { context: e, memoizedValue: t, next: null }, Mo === null) { if (zc === null) throw Error(M(308)); Mo = e, zc.dependencies = { lanes: 0, firstContext: e } } else Mo = Mo.next = e; return t } var Vi = null; function _p(e) { Vi === null ? Vi = [e] : Vi.push(e) } function Rw(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, _p(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Ir(e, r) } function Ir(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var Zr = !1; function Fp(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Pw(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Pr(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function ai(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, 2 & ve) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Ir(e, n) } return i = r.interleaved, i === null ? (t.next = t, _p(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Ir(e, n) } function yc(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (4194240 & n) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, mp(e, n) } } function nx(e, t) { var n = e.updateQueue, r = e.alternate; if (r === null || (r = r.updateQueue, n !== r)) e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t; else { var i = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? i = o = s : o = o.next = s, n = n.next } while (n !== null); o === null ? i = o = t : o = o.next = t } else i = o = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, e.updateQueue = n } } function $c(e, t, n, r) { var i = e.updateQueue; Zr = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, c = l.next; l.next = null, s === null ? o = c : s.next = c, s = l; var u = e.alternate; u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== s && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l)) } if (o !== null) { var f = i.baseState; s = 0, u = c = l = null, a = o; do { var d = a.lane, m = a.eventTime; if ((r & d) === d) { u !== null && (u = u.next = { eventTime: m, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var y = e, g = a; switch (d = t, m = n, g.tag) { case 1: if (y = g.payload, typeof y == "function") { f = y.call(m, f, d); break e } f = y; break e; case 3: y.flags = -65537 & y.flags | 128; case 0: if (y = g.payload, d = typeof y == "function" ? y.call(m, f, d) : y, d == null) break e; f = $e({}, f, d); break e; case 2: Zr = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, d = i.effects, d === null ? i.effects = [a] : d.push(a)) } else m = { eventTime: m, lane: d, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, u === null ? (c = u = m, l = f) : u = u.next = m, s |= d; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; d = a, a = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null } } while (1); if (u === null && (l = f), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, t = i.shared.interleaved, t !== null) { i = t; do s |= i.lane, i = i.next; while (i !== t) } else o === null && (i.shared.lanes = 0); Wi |= s, e.lanes = s, e.memoizedState = f } } function rx(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(M(191, i)); i.call(r) } } } var _w = new Rx.Component().refs; function Gh(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : $e({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var tu = { isMounted: function (e) { return !!(e = e._reactInternals) && qi(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = Vt(), i = ci(e), o = Pr(r, i); o.payload = t, n != null && (o.callback = n), t = ai(e, o, i), t !== null && (Vn(t, e, i, r), yc(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = Vt(), i = ci(e), o = Pr(r, i); o.tag = 1, o.payload = t, n != null && (o.callback = n), t = ai(e, o, i), t !== null && (Vn(t, e, i, r), yc(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = Vt(), r = ci(e), i = Pr(n, r); i.tag = 2, t != null && (i.callback = t), t = ai(e, i, r), t !== null && (Vn(t, e, r, n), yc(t, e, r)) } }; function ix(e, t, n, r, i, o, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || !ma(n, r) || !ma(i, o) } function Fw(e, t, n) { var r = !1, i = di, o = t.contextType; return typeof o == "object" && o !== null ? o = Sn(o) : (i = Xt(t) ? Ni : Ft.current, r = t.contextTypes, o = (r = r != null) ? jo(e, i) : di), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = tu, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function ox(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && tu.enqueueReplaceState(t, t.state, null) } function qh(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = _w, Fp(e); var o = t.contextType; typeof o == "object" && o !== null ? i.context = Sn(o) : (o = Xt(t) ? Ni : Ft.current, i.context = jo(e, o)), i.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (Gh(e, t, o, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && tu.enqueueReplaceState(i, i.state, null), $c(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function Us(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(M(309)); var r = n.stateNode } if (!r) throw Error(M(147, e)); var i = r, o = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (s) { var a = i.refs; a === _w && (a = i.refs = {}), s === null ? delete a[o] : a[o] = s }, t._stringRef = o, t) } if (typeof e != "string") throw Error(M(284)); if (!n._owner) throw Error(M(290, e)) } return e } function fc(e, t) { throw e = Object.prototype.toString.call(t), Error(M(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function sx(e) { var t = e._init; return t(e._payload) } function Iw(e) { function t(h, p) { if (e) { var v = h.deletions; v === null ? (h.deletions = [p], h.flags |= 16) : v.push(p) } } function n(h, p) { if (!e) return null; for (; p !== null;)t(h, p), p = p.sibling; return null } function r(h, p) { for (h = new Map; p !== null;)p.key !== null ? h.set(p.key, p) : h.set(p.index, p), p = p.sibling; return h } function i(h, p) { return h = ui(h, p), h.index = 0, h.sibling = null, h } function o(h, p, v) { return h.index = v, e ? (v = h.alternate, v !== null ? (v = v.index, v < p ? (h.flags |= 2, p) : v) : (h.flags |= 2, p)) : (h.flags |= 1048576, p) } function s(h) { return e && h.alternate === null && (h.flags |= 2), h } function a(h, p, v, w) { return p === null || p.tag !== 6 ? (p = ph(v, h.mode, w), p.return = h, p) : (p = i(p, v), p.return = h, p) } function l(h, p, v, w) { var C = v.type; return C === To ? u(h, p, v.props.children, w, v.key) : p !== null && (p.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Qr && sx(C) === p.type) ? (w = i(p, v.props), w.ref = Us(h, p, v), w.return = h, w) : (w = Cc(v.type, v.key, v.props, null, h.mode, w), w.ref = Us(h, p, v), w.return = h, w) } function c(h, p, v, w) { return p === null || p.tag !== 4 || p.stateNode.containerInfo !== v.containerInfo || p.stateNode.implementation !== v.implementation ? (p = mh(v, h.mode, w), p.return = h, p) : (p = i(p, v.children || []), p.return = h, p) } function u(h, p, v, w, C) { return p === null || p.tag !== 7 ? (p = $i(v, h.mode, w, C), p.return = h, p) : (p = i(p, v), p.return = h, p) } function f(h, p, v) { if (typeof p == "string" && p !== "" || typeof p == "number") return p = ph("" + p, h.mode, v), p.return = h, p; if (typeof p == "object" && p !== null) { switch (p.$$typeof) { case Kl: return v = Cc(p.type, p.key, p.props, null, h.mode, v), v.ref = Us(h, null, p), v.return = h, v; case Co: return p = mh(p, h.mode, v), p.return = h, p; case Qr: var w = p._init; return f(h, w(p._payload), v) }if (Ks(p) || Ns(p)) return p = $i(p, h.mode, v, null), p.return = h, p; fc(h, p) } return null } function d(h, p, v, w) { var C = p !== null ? p.key : null; if (typeof v == "string" && v !== "" || typeof v == "number") return C !== null ? null : a(h, p, "" + v, w); if (typeof v == "object" && v !== null) { switch (v.$$typeof) { case Kl: return v.key === C ? l(h, p, v, w) : null; case Co: return v.key === C ? c(h, p, v, w) : null; case Qr: return C = v._init, d(h, p, C(v._payload), w) }if (Ks(v) || Ns(v)) return C !== null ? null : u(h, p, v, w, null); fc(h, v) } return null } function m(h, p, v, w, C) { if (typeof w == "string" && w !== "" || typeof w == "number") return h = h.get(v) || null, a(p, h, "" + w, C); if (typeof w == "object" && w !== null) { switch (w.$$typeof) { case Kl: return h = h.get(w.key === null ? v : w.key) || null, l(p, h, w, C); case Co: return h = h.get(w.key === null ? v : w.key) || null, c(p, h, w, C); case Qr: var S = w._init; return m(h, p, v, S(w._payload), C) }if (Ks(w) || Ns(w)) return h = h.get(v) || null, u(p, h, w, C, null); fc(p, w) } return null } function y(h, p, v, w) { for (var C = null, S = null, R = p, E = p = 0, L = null; R !== null && E < v.length; E++) { R.index > E ? (L = R, R = null) : L = R.sibling; var F = d(h, R, v[E], w); if (F === null) { R === null && (R = L); break } e && R && F.alternate === null && t(h, R), p = o(F, p, E), S === null ? C = F : S.sibling = F, S = F, R = L } if (E === v.length) return n(h, R), De && Oi(h, E), C; if (R === null) { for (; E < v.length; E++)R = f(h, v[E], w), R !== null && (p = o(R, p, E), S === null ? C = R : S.sibling = R, S = R); return De && Oi(h, E), C } for (R = r(h, R); E < v.length; E++)L = m(R, h, E, v[E], w), L !== null && (e && L.alternate !== null && R.delete(L.key === null ? E : L.key), p = o(L, p, E), S === null ? C = L : S.sibling = L, S = L); return e && R.forEach(function (z) { return t(h, z) }), De && Oi(h, E), C } function g(h, p, v, w) { var C = Ns(v); if (typeof C != "function") throw Error(M(150)); if (v = C.call(v), v == null) throw Error(M(151)); for (var S = C = null, R = p, E = p = 0, L = null, F = v.next(); R !== null && !F.done; E++, F = v.next()) { R.index > E ? (L = R, R = null) : L = R.sibling; var z = d(h, R, F.value, w); if (z === null) { R === null && (R = L); break } e && R && z.alternate === null && t(h, R), p = o(z, p, E), S === null ? C = z : S.sibling = z, S = z, R = L } if (F.done) return n(h, R), De && Oi(h, E), C; if (R === null) { for (; !F.done; E++, F = v.next())F = f(h, F.value, w), F !== null && (p = o(F, p, E), S === null ? C = F : S.sibling = F, S = F); return De && Oi(h, E), C } for (R = r(h, R); !F.done; E++, F = v.next())F = m(R, h, E, F.value, w), F !== null && (e && F.alternate !== null && R.delete(F.key === null ? E : F.key), p = o(F, p, E), S === null ? C = F : S.sibling = F, S = F); return e && R.forEach(function (D) { return t(h, D) }), De && Oi(h, E), C } function b(h, p, v, w) { if (typeof v == "object" && v !== null && v.type === To && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) { switch (v.$$typeof) { case Kl: e: { for (var C = v.key, S = p; S !== null;) { if (S.key === C) { if (C = v.type, C === To) { if (S.tag === 7) { n(h, S.sibling), p = i(S, v.props.children), p.return = h, h = p; break e } } else if (S.elementType === C || typeof C == "object" && C !== null && C.$$typeof === Qr && sx(C) === S.type) { n(h, S.sibling), p = i(S, v.props), p.ref = Us(h, S, v), p.return = h, h = p; break e } n(h, S); break } t(h, S), S = S.sibling } v.type === To ? (p = $i(v.props.children, h.mode, w, v.key), p.return = h, h = p) : (w = Cc(v.type, v.key, v.props, null, h.mode, w), w.ref = Us(h, p, v), w.return = h, h = w) } return s(h); case Co: e: { for (S = v.key; p !== null;) { if (p.key === S) { if (p.tag === 4 && p.stateNode.containerInfo === v.containerInfo && p.stateNode.implementation === v.implementation) { n(h, p.sibling), p = i(p, v.children || []), p.return = h, h = p; break e } n(h, p); break } t(h, p), p = p.sibling } p = mh(v, h.mode, w), p.return = h, h = p } return s(h); case Qr: return S = v._init, b(h, p, S(v._payload), w) }if (Ks(v)) return y(h, p, v, w); if (Ns(v)) return g(h, p, v, w); fc(h, v) } return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, p !== null && p.tag === 6 ? (n(h, p.sibling), p = i(p, v), p.return = h, h = p) : (n(h, p), p = ph(v, h.mode, w), p.return = h, h = p), s(h)) : n(h, p) } return b } var Uo = Iw(!0), Lw = Iw(!1), Pa = {}, ar = pi(Pa), ba = pi(Pa), xa = pi(Pa); function Bi(e) { if (e === Pa) throw Error(M(174)); return e } function Ip(e, t) { switch (Re(xa, t), Re(ba, e), Re(ar, Pa), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Th(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Th(t, e) }Le(ar), Re(ar, t) } function Go() { Le(ar), Le(ba), Le(xa) } function Mw(e) { Bi(xa.current); var t = Bi(ar.current), n = Th(t, e.type); t !== n && (Re(ba, e), Re(ar, n)) } function Lp(e) { ba.current === e && (Le(ar), Le(ba)) } var Be = pi(0); function Nc(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (128 & t.flags) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var lh = []; function Mp() { for (var e = 0; e < lh.length; e++)lh[e]._workInProgressVersionPrimary = null; lh.length = 0 } var bc = Mr.ReactCurrentDispatcher, ch = Mr.ReactCurrentBatchConfig, ji = 0, ze = null, tt = null, at = null, Hc = !1, ia = !1, wa = 0, W2 = 0; function Rt() { throw Error(M(321)) } function Op(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!Bn(e[n], t[n])) return !1; return !0 } function Dp(e, t, n, r, i, o) { if (ji = o, ze = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, bc.current = e === null || e.memoizedState === null ? X2 : Y2, e = n(r, i), ia) { o = 0; do { if (ia = !1, wa = 0, 25 <= o) throw Error(M(301)); o += 1, at = tt = null, t.updateQueue = null, bc.current = K2, e = n(r, i) } while (ia) } if (bc.current = jc, t = tt !== null && tt.next !== null, ji = 0, at = tt = ze = null, Hc = !1, t) throw Error(M(300)); return e } function Ap() { var e = wa !== 0; return wa = 0, e } function ir() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return at === null ? ze.memoizedState = at = e : at = at.next = e, at } function kn() { if (tt === null) { var e = ze.alternate; e = e !== null ? e.memoizedState : null } else e = tt.next; var t = at === null ? ze.memoizedState : at.next; if (t !== null) at = t, tt = e; else { if (e === null) throw Error(M(310)); tt = e, e = { memoizedState: tt.memoizedState, baseState: tt.baseState, baseQueue: tt.baseQueue, queue: tt.queue, next: null }, at === null ? ze.memoizedState = at = e : at = at.next = e } return at } function Sa(e, t) { return typeof t == "function" ? t(e) : t } function uh(e) { var t = kn(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = tt, i = r.baseQueue, o = n.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, n.pending = null } if (i !== null) { o = i.next, r = r.baseState; var a = s = null, l = null, c = o; do { var u = c.lane; if ((ji & u) === u) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), r = c.hasEagerState ? c.eagerState : e(r, c.action); else { var f = { lane: u, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = f, s = r) : l = l.next = f, ze.lanes |= u, Wi |= u } c = c.next } while (c !== null && c !== o); l === null ? s = r : l.next = a, Bn(r, t.memoizedState) || (Gt = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do o = i.lane, ze.lanes |= o, Wi |= o, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function fh(e) { var t = kn(), n = t.queue; if (n === null) throw Error(M(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (i !== null) { n.pending = null; var s = i = i.next; do o = e(o, s.action), s = s.next; while (s !== i); Bn(o, t.memoizedState) || (Gt = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function Ow() { } function Dw(e, t) { var n = ze, r = kn(), i = t(), o = !Bn(r.memoizedState, i); if (o && (r.memoizedState = i, Gt = !0), r = r.queue, Vp(Bw.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || at !== null && 1 & at.memoizedState.tag) { if (n.flags |= 2048, ka(9, Vw.bind(null, n, r, i, t), void 0, null), lt === null) throw Error(M(349)); 30 & ji || Aw(n, t, i) } return i } function Aw(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = ze.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ze.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function Vw(e, t, n, r) { t.value = n, t.getSnapshot = r, zw(t) && $w(e) } function Bw(e, t, n) { return n(function () { zw(t) && $w(e) }) } function zw(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Bn(e, n) } catch { return !0 } } function $w(e) { var t = Ir(e, 1); t !== null && Vn(t, e, 1, -1) } function ax(e) { var t = ir(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Sa, lastRenderedState: e }, t.queue = e, e = e.dispatch = q2.bind(null, ze, e), [t.memoizedState, e] } function ka(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = ze.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ze.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function Nw() { return kn().memoizedState } function xc(e, t, n, r) { var i = ir(); ze.flags |= e, i.memoizedState = ka(1 | t, n, void 0, r === void 0 ? null : r) } function nu(e, t, n, r) { var i = kn(); r = r === void 0 ? null : r; var o = void 0; if (tt !== null) { var s = tt.memoizedState; if (o = s.destroy, r !== null && Op(r, s.deps)) { i.memoizedState = ka(t, n, o, r); return } } ze.flags |= e, i.memoizedState = ka(1 | t, n, o, r) } function lx(e, t) { return xc(8390656, 8, e, t) } function Vp(e, t) { return nu(2048, 8, e, t) } function Hw(e, t) { return nu(4, 2, e, t) } function jw(e, t) { return nu(4, 4, e, t) } function Ww(e, t) { return typeof t == "function" ? (e = e(), t(e), function () { t(null) }) : t != null ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Uw(e, t, n) { return n = n != null ? n.concat([e]) : null, nu(4, 4, Ww.bind(null, t, e), n) } function Bp() { } function Gw(e, t) { var n = kn(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Op(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function qw(e, t) { var n = kn(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Op(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Xw(e, t, n) { return 21 & ji ? (Bn(n, t) || (n = Qx(), ze.lanes |= n, Wi |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Gt = !0), e.memoizedState = n) } function U2(e, t) { var n = we; we = n !== 0 && 4 > n ? n : 4, e(!0); var r = ch.transition; ch.transition = {}; try { e(!1), t() } finally { we = n, ch.transition = r } } function Yw() { return kn().memoizedState } function G2(e, t, n) { var r = ci(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Kw(e)) Qw(t, n); else if (n = Rw(e, t, n, r), n !== null) { var i = Vt(); Vn(n, e, r, i), Zw(n, t, r) } } function q2(e, t, n) { var r = ci(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Kw(e)) Qw(t, i); else { var o = e.alternate; if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try { var s = t.lastRenderedState, a = o(s, n); if (i.hasEagerState = !0, i.eagerState = a, Bn(a, s)) { var l = t.interleaved; l === null ? (i.next = i, _p(t)) : (i.next = l.next, l.next = i), t.interleaved = i; return } } catch { } n = Rw(e, t, i, r), n !== null && (i = Vt(), Vn(n, e, r, i), Zw(n, t, r)) } } function Kw(e) { var t = e.alternate; return e === ze || t !== null && t === ze } function Qw(e, t) { ia = Hc = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function Zw(e, t, n) { if (4194240 & n) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, mp(e, n) } } var jc = { readContext: Sn, useCallback: Rt, useContext: Rt, useEffect: Rt, useImperativeHandle: Rt, useInsertionEffect: Rt, useLayoutEffect: Rt, useMemo: Rt, useReducer: Rt, useRef: Rt, useState: Rt, useDebugValue: Rt, useDeferredValue: Rt, useTransition: Rt, useMutableSource: Rt, useSyncExternalStore: Rt, useId: Rt, unstable_isNewReconciler: !1 }, X2 = { readContext: Sn, useCallback: function (e, t) { return ir().memoizedState = [e, t === void 0 ? null : t], e }, useContext: Sn, useEffect: lx, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, xc(4194308, 4, Ww.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return xc(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return xc(4, 2, e, t) }, useMemo: function (e, t) { var n = ir(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = ir(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = G2.bind(null, ze, e), [r.memoizedState, e] }, useRef: function (e) { var t = ir(); return e = { current: e }, t.memoizedState = e }, useState: ax, useDebugValue: Bp, useDeferredValue: function (e) { return ir().memoizedState = e }, useTransition: function () { var e = ax(!1), t = e[0]; return e = U2.bind(null, e[1]), ir().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ze, i = ir(); if (De) { if (n === void 0) throw Error(M(407)); n = n() } else { if (n = t(), lt === null) throw Error(M(349)); 30 & ji || Aw(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, lx(Bw.bind(null, r, o, e), [e]), r.flags |= 2048, ka(9, Vw.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = ir(), t = lt.identifierPrefix; if (De) { var n = Rr, r = Er; n = (r & ~(1 << 32 - An(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = wa++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = W2++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, Y2 = { readContext: Sn, useCallback: Gw, useContext: Sn, useEffect: Vp, useImperativeHandle: Uw, useInsertionEffect: Hw, useLayoutEffect: jw, useMemo: qw, useReducer: uh, useRef: Nw, useState: function () { return uh(Sa) }, useDebugValue: Bp, useDeferredValue: function (e) { var t = kn(); return Xw(t, tt.memoizedState, e) }, useTransition: function () { var e = uh(Sa)[0], t = kn().memoizedState; return [e, t] }, useMutableSource: Ow, useSyncExternalStore: Dw, useId: Yw, unstable_isNewReconciler: !1 }, K2 = { readContext: Sn, useCallback: Gw, useContext: Sn, useEffect: Vp, useImperativeHandle: Uw, useInsertionEffect: Hw, useLayoutEffect: jw, useMemo: qw, useReducer: fh, useRef: Nw, useState: function () { return fh(Sa) }, useDebugValue: Bp, useDeferredValue: function (e) { var t = kn(); return tt === null ? t.memoizedState = e : Xw(t, tt.memoizedState, e) }, useTransition: function () { var e = fh(Sa)[0], t = kn().memoizedState; return [e, t] }, useMutableSource: Ow, useSyncExternalStore: Dw, useId: Yw, unstable_isNewReconciler: !1 }; function qo(e, t) {
    try { var n = "", r = t; do n += EI(r), r = r.return; while (r); var i = n } catch (o) {
        i = `
Error generating stack: `+ o.message + `
`+ o.stack
    } return { value: e, source: t, stack: i, digest: null }
} function dh(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function Xh(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var Q2 = typeof WeakMap == "function" ? WeakMap : Map; function Jw(e, t, n) { n = Pr(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Uc || (Uc = !0, rp = r), Xh(e, t) }, n } function e1(e, t, n) { n = Pr(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { Xh(e, t) } } var o = e.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { Xh(e, t), typeof r != "function" && (li === null ? li = new Set([this]) : li.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), n } function cx(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new Q2; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = fL.bind(null, e, t, n), t.then(e, e)) } function ux(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t === null || t.dehydrated !== null), t) return e; e = e.return } while (e !== null); return null } function fx(e, t, n, r, i) { return 1 & e.mode ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Pr(-1, 1), t.tag = 2, ai(n, t, 1))), n.lanes |= 1), e) } var Z2 = Mr.ReactCurrentOwner, Gt = !1; function At(e, t, n, r) { t.child = e === null ? Lw(t, null, n, r) : Uo(t, e.child, n, r) } function dx(e, t, n, r, i) { n = n.render; var o = t.ref; return $o(t, i), r = Dp(e, t, n, r, o, i), n = Ap(), e !== null && !Gt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Lr(e, t, i)) : (De && n && kp(t), t.flags |= 1, At(e, t, r, i), t.child) } function hx(e, t, n, r, i) { if (e === null) { var o = n.type; return typeof o == "function" && !Gp(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, t1(e, t, o, r, i)) : (e = Cc(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (o = e.child, !(e.lanes & i)) { var s = o.memoizedProps; if (n = n.compare, n = n !== null ? n : ma, n(s, r) && e.ref === t.ref) return Lr(e, t, i) } return t.flags |= 1, e = ui(o, r), e.ref = t.ref, e.return = t, t.child = e } function t1(e, t, n, r, i) { if (e !== null) { var o = e.memoizedProps; if (ma(o, r) && e.ref === t.ref) { if (Gt = !1, t.pendingProps = r = o, (e.lanes & i) === 0) return t.lanes = e.lanes, Lr(e, t, i); 131072 & e.flags && (Gt = !0) } } return Yh(e, t, n, r, i) } function n1(e, t, n) { var r = t.pendingProps, i = r.children, o = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Re(Do, tn), tn |= n; else { if (!(1073741824 & n)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Re(Do, tn), tn |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : n, Re(Do, tn), tn |= r } else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Re(Do, tn), tn |= r; return At(e, t, i, n), t.child } function r1(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Yh(e, t, n, r, i) { var o = Xt(n) ? Ni : Ft.current; return o = jo(t, o), $o(t, i), n = Dp(e, t, n, r, o, i), r = Ap(), e !== null && !Gt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Lr(e, t, i)) : (De && r && kp(t), t.flags |= 1, At(e, t, n, i), t.child) } function px(e, t, n, r, i) { if (Xt(n)) { var o = !0; Dc(t) } else o = !1; if ($o(t, i), t.stateNode === null) wc(e, t), Fw(t, n, r), qh(t, n, r, i), r = !0; else if (e === null) { var s = t.stateNode, a = t.memoizedProps; s.props = a; var l = s.context, c = n.contextType; typeof c == "object" && c !== null ? c = Sn(c) : (c = Xt(n) ? Ni : Ft.current, c = jo(t, c)); var u = n.getDerivedStateFromProps, f = typeof u == "function" || typeof s.getSnapshotBeforeUpdate == "function"; f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== c) && ox(t, s, r, c), Zr = !1; var d = t.memoizedState; s.state = d, $c(t, r, s, i), l = t.memoizedState, a !== r || d !== l || qt.current || Zr ? (typeof u == "function" && (Gh(t, n, u, r), l = t.memoizedState), (a = Zr || ix(t, n, a, r, d, l, c)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = c, r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, Pw(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : Mn(t.type, a), s.props = c, f = t.pendingProps, d = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = Sn(l) : (l = Xt(n) ? Ni : Ft.current, l = jo(t, l)); var m = n.getDerivedStateFromProps; (u = typeof m == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== f || d !== l) && ox(t, s, r, l), Zr = !1, d = t.memoizedState, s.state = d, $c(t, r, s, i); var y = t.memoizedState; a !== f || d !== y || qt.current || Zr ? (typeof m == "function" && (Gh(t, n, m, r), y = t.memoizedState), (c = Zr || ix(t, n, c, r, d, y, l) || !1) ? (u || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, y, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, y, l)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = y), s.props = r, s.state = y, s.context = l, r = c) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1) } return Kh(e, t, n, r, o, i) } function Kh(e, t, n, r, i, o) { r1(e, t); var s = (128 & t.flags) !== 0; if (!r && !s) return i && Jb(t, n, !1), Lr(e, t, o); r = t.stateNode, Z2.current = t; var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && s ? (t.child = Uo(t, e.child, null, o), t.child = Uo(t, null, a, o)) : At(e, t, a, o), t.memoizedState = r.state, i && Jb(t, n, !0), t.child } function i1(e) { var t = e.stateNode; t.pendingContext ? Zb(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Zb(e, t.context, !1), Ip(e, t.containerInfo) } function mx(e, t, n, r, i) { return Wo(), Tp(i), t.flags |= 256, At(e, t, n, r), t.child } var Qh = { dehydrated: null, treeContext: null, retryLane: 0 }; function Zh(e) { return { baseLanes: e, cachePool: null, transitions: null } } function o1(e, t, n) { var r, i = t.pendingProps, o = Be.current, s = !1, a = (128 & t.flags) !== 0; if ((r = a) || (r = (e === null || e.memoizedState !== null) && (2 & o) !== 0), r ? (s = !0, t.flags &= -129) : e !== null && e.memoizedState === null || (o |= 1), Re(Be, 1 & o), e === null) return Wh(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (1 & t.mode ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (a = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, a = { mode: "hidden", children: a }, !(1 & i) && s !== null ? (s.childLanes = 0, s.pendingProps = a) : s = ou(a, i, 0, null), e = $i(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Zh(n), t.memoizedState = Qh, e) : zp(t, a)); if (o = e.memoizedState, o !== null && (r = o.dehydrated, r !== null)) return J2(e, t, a, i, r, o, n); if (s) { s = i.fallback, a = t.mode, o = e.child, r = o.sibling; var l = { mode: "hidden", children: i.children }; return !(1 & a) && t.child !== o ? (i = t.child, i.childLanes = 0, i.pendingProps = l, t.deletions = null) : (i = ui(o, l), i.subtreeFlags = 14680064 & o.subtreeFlags), r !== null ? s = ui(r, s) : (s = $i(s, a, n, null), s.flags |= 2), s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, a = e.child.memoizedState, a = a === null ? Zh(n) : { baseLanes: a.baseLanes | n, cachePool: null, transitions: a.transitions }, s.memoizedState = a, s.childLanes = e.childLanes & ~n, t.memoizedState = Qh, i } return s = e.child, e = s.sibling, i = ui(s, { mode: "visible", children: i.children }), !(1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function zp(e, t) { return t = ou({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function dc(e, t, n, r) { return r !== null && Tp(r), Uo(t, e.child, null, n), e = zp(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function J2(e, t, n, r, i, o, s) { if (n) return 256 & t.flags ? (t.flags &= -257, r = dh(Error(M(422))), dc(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = ou({ mode: "visible", children: r.children }, i, 0, null), o = $i(o, i, s, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, 1 & t.mode && Uo(t, e.child, null, s), t.child.memoizedState = Zh(s), t.memoizedState = Qh, o); if (!(1 & t.mode)) return dc(e, t, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, o = Error(M(419)), r = dh(o, r, void 0), dc(e, t, s, r) } if (a = (s & e.childLanes) !== 0, Gt || a) { if (r = lt, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Ir(e, i), Vn(r, e, i, -1)) } return Up(), r = dh(Error(M(421))), dc(e, t, s, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = dL.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, nn = si(i.nextSibling), rn = t, De = !0, Dn = null, e !== null && (yn[bn++] = Er, yn[bn++] = Rr, yn[bn++] = Hi, Er = e.id, Rr = e.overflow, Hi = t), t = zp(t, r.children), t.flags |= 4096, t) } function gx(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), Uh(e.return, t, n) } function hh(e, t, n, r, i) { var o = e.memoizedState; o === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function s1(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (At(e, t, r.children, n), r = Be.current, 2 & r) r = 1 & r | 2, t.flags |= 128; else { if (e !== null && 128 & e.flags) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && gx(e, n, t); else if (e.tag === 19) gx(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Re(Be, r), !(1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && Nc(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), hh(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && Nc(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } hh(t, !0, n, null, o); break; case "together": hh(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function wc(e, t) { !(1 & t.mode) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Lr(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Wi |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(M(153)); if (t.child !== null) { for (e = t.child, n = ui(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = ui(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function eL(e, t, n) { switch (t.tag) { case 3: i1(t), Wo(); break; case 5: Mw(t); break; case 1: Xt(t.type) && Dc(t); break; case 4: Ip(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Re(Bc, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (Re(Be, 1 & Be.current), t.flags |= 128, null) : n & t.child.childLanes ? o1(e, t, n) : (Re(Be, 1 & Be.current), e = Lr(e, t, n), e !== null ? e.sibling : null); Re(Be, 1 & Be.current); break; case 19: if (r = (n & t.childLanes) !== 0, 128 & e.flags) { if (r) return s1(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Re(Be, Be.current), r) break; return null; case 22: case 23: return t.lanes = 0, n1(e, t, n) }return Lr(e, t, n) } var a1, Jh, l1, c1; a1 = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Jh = function () { }; l1 = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, Bi(ar.current); var o = null; switch (n) { case "input": i = wh(e, i), r = wh(e, r), o = []; break; case "select": i = $e({}, i, { value: void 0 }), r = $e({}, r, { value: void 0 }), o = []; break; case "textarea": i = Ch(e, i), r = Ch(e, r), o = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Mc) }Eh(n, r); var s; n = null; for (c in i) if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null) if (c === "style") { var a = i[c]; for (s in a) a.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (la.hasOwnProperty(c) ? o || (o = []) : (o = o || []).push(c, null)); for (c in r) { var l = r[c]; if (a = i?.[c], r.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]) } else n || (o || (o = []), o.push(c, n)), n = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (la.hasOwnProperty(c) ? (l != null && c === "onScroll" && Ie("scroll", e), o || a === l || (o = [])) : (o = o || []).push(c, l)) } n && (o = o || []).push("style", n); var c = o; (t.updateQueue = c) && (t.flags |= 4) } }; c1 = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function Gs(e, t) { if (!De) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Pt(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function tL(e, t, n) { var r = t.pendingProps; switch (Cp(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Pt(t), null; case 1: return Xt(t.type) && Oc(), Pt(t), null; case 3: return r = t.stateNode, Go(), Le(qt), Le(Ft), Mp(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), e !== null && e.child !== null || (uc(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(256 & t.flags) || (t.flags |= 1024, Dn !== null && (sp(Dn), Dn = null))), Jh(e, t), Pt(t), null; case 5: Lp(t); var i = Bi(xa.current); if (n = t.type, e !== null && t.stateNode != null) l1(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(M(166)); return Pt(t), null } if (e = Bi(ar.current), uc(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[or] = t, r[ya] = o, e = (1 & t.mode) !== 0, n) { case "dialog": Ie("cancel", r), Ie("close", r); break; case "iframe": case "object": case "embed": Ie("load", r); break; case "video": case "audio": for (i = 0; i < Zs.length; i++)Ie(Zs[i], r); break; case "source": Ie("error", r); break; case "img": case "image": case "link": Ie("error", r), Ie("load", r); break; case "details": Ie("toggle", r); break; case "input": Cb(r, o), Ie("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, Ie("invalid", r); break; case "textarea": Eb(r, o), Ie("invalid", r) }Eh(n, o), i = null; for (var s in o) if (o.hasOwnProperty(s)) { var a = o[s]; s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && cc(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && cc(r.textContent, a, e), i = ["children", "" + a]) : la.hasOwnProperty(s) && a != null && s === "onScroll" && Ie("scroll", r) } switch (n) { case "input": Ql(r), Tb(r, o, !0); break; case "textarea": Ql(r), Rb(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = Mc) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Ax(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, { is: r.is }) : (e = s.createElement(n), n === "select" && (s = e, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n), e[or] = t, e[ya] = r, a1(e, t, !1, !1), t.stateNode = e; e: { switch (s = Rh(n, r), n) { case "dialog": Ie("cancel", e), Ie("close", e), i = r; break; case "iframe": case "object": case "embed": Ie("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Zs.length; i++)Ie(Zs[i], e); i = r; break; case "source": Ie("error", e), i = r; break; case "img": case "image": case "link": Ie("error", e), Ie("load", e), i = r; break; case "details": Ie("toggle", e), i = r; break; case "input": Cb(e, r), i = wh(e, r), Ie("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = $e({}, r, { value: void 0 }), Ie("invalid", e); break; case "textarea": Eb(e, r), i = Ch(e, r), Ie("invalid", e); break; default: i = r }Eh(n, i), a = i; for (o in a) if (a.hasOwnProperty(o)) { var l = a[o]; o === "style" ? zx(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Vx(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && ca(e, l) : typeof l == "number" && ca(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (la.hasOwnProperty(o) ? l != null && o === "onScroll" && Ie("scroll", e) : l != null && cp(e, o, l, s)) } switch (n) { case "input": Ql(e), Tb(e, r, !1); break; case "textarea": Ql(e), Rb(e); break; case "option": r.value != null && e.setAttribute("value", "" + fi(r.value)); break; case "select": e.multiple = !!r.multiple, o = r.value, o != null ? Ao(e, !!r.multiple, o, !1) : r.defaultValue != null && Ao(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = Mc) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Pt(t), null; case 6: if (e && t.stateNode != null) c1(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(M(166)); if (n = Bi(xa.current), Bi(ar.current), uc(t)) { if (r = t.stateNode, n = t.memoizedProps, r[or] = t, (o = r.nodeValue !== n) && (e = rn, e !== null)) switch (e.tag) { case 3: cc(r.nodeValue, n, (1 & e.mode) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && cc(r.nodeValue, n, (1 & e.mode) !== 0) }o && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[or] = t, t.stateNode = r } return Pt(t), null; case 13: if (Le(Be), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (De && nn !== null && 1 & t.mode && !(128 & t.flags)) Ew(), Wo(), t.flags |= 98560, o = !1; else if (o = uc(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!o) throw Error(M(318)); if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(M(317)); o[or] = t } else Wo(), !(128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Pt(t), o = !1 } else Dn !== null && (sp(Dn), Dn = null), o = !0; if (!o) return 65536 & t.flags ? t : null } return 128 & t.flags ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, 1 & t.mode && (e === null || 1 & Be.current ? nt === 0 && (nt = 3) : Up())), t.updateQueue !== null && (t.flags |= 4), Pt(t), null); case 4: return Go(), Jh(e, t), e === null && ga(t.stateNode.containerInfo), Pt(t), null; case 10: return Pp(t.type._context), Pt(t), null; case 17: return Xt(t.type) && Oc(), Pt(t), null; case 19: if (Le(Be), o = t.memoizedState, o === null) return Pt(t), null; if (r = (128 & t.flags) !== 0, s = o.rendering, s === null) if (r) Gs(o, !1); else { if (nt !== 0 || e !== null && 128 & e.flags) for (e = t.child; e !== null;) { if (s = Nc(e), s !== null) { for (t.flags |= 128, Gs(o, !1), r = s.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)o = n, e = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, e = s.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Re(Be, 1 & Be.current | 2), t.child } e = e.sibling } o.tail !== null && Ye() > Xo && (t.flags |= 128, r = !0, Gs(o, !1), t.lanes = 4194304) } else { if (!r) if (e = Nc(s), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Gs(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !De) return Pt(t), null } else 2 * Ye() - o.renderingStartTime > Xo && n !== 1073741824 && (t.flags |= 128, r = !0, Gs(o, !1), t.lanes = 4194304); o.isBackwards ? (s.sibling = t.child, t.child = s) : (n = o.last, n !== null ? n.sibling = s : t.child = s, o.last = s) } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = Ye(), t.sibling = null, n = Be.current, Re(Be, r ? 1 & n | 2 : 1 & n), t) : (Pt(t), null); case 22: case 23: return Wp(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && 1 & t.mode ? 1073741824 & tn && (Pt(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Pt(t), null; case 24: return null; case 25: return null }throw Error(M(156, t.tag)) } function nL(e, t) { switch (Cp(t), t.tag) { case 1: return Xt(t.type) && Oc(), e = t.flags, 65536 & e ? (t.flags = -65537 & e | 128, t) : null; case 3: return Go(), Le(qt), Le(Ft), Mp(), e = t.flags, 65536 & e && !(128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return Lp(t), null; case 13: if (Le(Be), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(M(340)); Wo() } return e = t.flags, 65536 & e ? (t.flags = -65537 & e | 128, t) : null; case 19: return Le(Be), null; case 4: return Go(), null; case 10: return Pp(t.type._context), null; case 22: case 23: return Wp(), null; case 24: return null; default: return null } } var hc = !1, _t = !1, rL = typeof WeakSet == "function" ? WeakSet : Set, B = null; function Oo(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { Ge(e, t, r) } else n.current = null } function u1(e, t, n) { try { n() } catch (r) { Ge(e, t, r) } } var vx = !1; function iL(e, t) { if (Vh = Fc, e = hw(), Sp(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || I; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var s = 0, a = -1, l = -1, c = 0, u = 0, f = e, d = null; t: for (; ;) { for (var m; f !== n || i !== 0 && f.nodeType !== 3 || (a = s + i), f !== o || r !== 0 && f.nodeType !== 3 || (l = s + r), f.nodeType === 3 && (s += f.nodeValue.length), (m = f.firstChild) !== null;)d = f, f = m; for (; ;) { if (f === e) break t; if (d === n && ++c === i && (a = s), d === o && ++u === r && (l = s), (m = f.nextSibling) !== null) break; f = d, d = f.parentNode } f = m } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Bh = { focusedElem: e, selectionRange: n }, Fc = !1, B = t; B !== null;)if (t = B, e = t.child, (1028 & t.subtreeFlags) !== 0 && e !== null) e.return = t, B = e; else for (; B !== null;) { t = B; try { var y = t.alternate; if (1024 & t.flags) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (y !== null) { var g = y.memoizedProps, b = y.memoizedState, h = t.stateNode, p = h.getSnapshotBeforeUpdate(t.elementType === t.type ? g : Mn(t.type, g), b); h.__reactInternalSnapshotBeforeUpdate = p } break; case 3: var v = t.stateNode.containerInfo; v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(M(163)) } } catch (w) { Ge(t, t.return, w) } if (e = t.sibling, e !== null) { e.return = t.return, B = e; break } B = t.return } return y = vx, vx = !1, y } function oa(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, o !== void 0 && u1(t, n, o) } i = i.next } while (i !== r) } } function ru(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function ep(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function f1(e) { var t = e.alternate; t !== null && (e.alternate = null, f1(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[or], delete t[ya], delete t[Nh], delete t[$2], delete t[N2])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function d1(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function yx(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || d1(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (2 & e.flags || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function tp(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Mc)); else if (r !== 4 && (e = e.child, e !== null)) for (tp(e, t, n), e = e.sibling; e !== null;)tp(e, t, n), e = e.sibling } function np(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (np(e, t, n), e = e.sibling; e !== null;)np(e, t, n), e = e.sibling } var vt = null, On = !1; function Kr(e, t, n) { for (n = n.child; n !== null;)h1(e, t, n), n = n.sibling } function h1(e, t, n) { if (sr && typeof sr.onCommitFiberUnmount == "function") try { sr.onCommitFiberUnmount(Yc, n) } catch { } switch (n.tag) { case 5: _t || Oo(n, t); case 6: var r = vt, i = On; vt = null, Kr(e, t, n), vt = r, On = i, vt !== null && (On ? (e = vt, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : vt.removeChild(n.stateNode)); break; case 18: vt !== null && (On ? (e = vt, n = n.stateNode, e.nodeType === 8 ? sh(e.parentNode, n) : e.nodeType === 1 && sh(e, n), ha(e)) : sh(vt, n.stateNode)); break; case 4: r = vt, i = On, vt = n.stateNode.containerInfo, On = !0, Kr(e, t, n), vt = r, On = i; break; case 0: case 11: case 14: case 15: if (!_t && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var o = i, s = o.destroy; o = o.tag, s !== void 0 && (2 & o || 4 & o) && u1(n, t, s), i = i.next } while (i !== r) } Kr(e, t, n); break; case 1: if (!_t && (Oo(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { Ge(n, t, a) } Kr(e, t, n); break; case 21: Kr(e, t, n); break; case 22: 1 & n.mode ? (_t = (r = _t) || n.memoizedState !== null, Kr(e, t, n), _t = r) : Kr(e, t, n); break; default: Kr(e, t, n) } } function bx(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new rL), t.forEach(function (r) { var i = hL.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function Ln(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, s = t, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: vt = a.stateNode, On = !1; break e; case 3: vt = a.stateNode.containerInfo, On = !0; break e; case 4: vt = a.stateNode.containerInfo, On = !0; break e }a = a.return } if (vt === null) throw Error(M(160)); h1(o, s, i), vt = null, On = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (c) { Ge(i, t, c) } } if (12854 & t.subtreeFlags) for (t = t.child; t !== null;)p1(t, e), t = t.sibling } function p1(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Ln(t, e), rr(e), 4 & r) { try { oa(3, e, e.return), ru(3, e) } catch (g) { Ge(e, e.return, g) } try { oa(5, e, e.return) } catch (g) { Ge(e, e.return, g) } } break; case 1: Ln(t, e), rr(e), 512 & r && n !== null && Oo(n, n.return); break; case 5: if (Ln(t, e), rr(e), 512 & r && n !== null && Oo(n, n.return), 32 & e.flags) { var i = e.stateNode; try { ca(i, "") } catch (g) { Ge(e, e.return, g) } } if (4 & r && (i = e.stateNode, i != null)) { var o = e.memoizedProps, s = n !== null ? n.memoizedProps : o, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && o.type === "radio" && o.name != null && Ox(i, o), Rh(a, s); var c = Rh(a, o); for (s = 0; s < l.length; s += 2) { var u = l[s], f = l[s + 1]; u === "style" ? zx(i, f) : u === "dangerouslySetInnerHTML" ? Vx(i, f) : u === "children" ? ca(i, f) : cp(i, u, f, c) } switch (a) { case "input": Sh(i, o); break; case "textarea": Dx(i, o); break; case "select": var d = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var m = o.value; m != null ? Ao(i, !!o.multiple, m, !1) : d !== !!o.multiple && (o.defaultValue != null ? Ao(i, !!o.multiple, o.defaultValue, !0) : Ao(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[ya] = o } catch (g) { Ge(e, e.return, g) } } break; case 6: if (Ln(t, e), rr(e), 4 & r) { if (e.stateNode === null) throw Error(M(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (g) { Ge(e, e.return, g) } } break; case 3: if (Ln(t, e), rr(e), 4 & r && n !== null && n.memoizedState.isDehydrated) try { ha(t.containerInfo) } catch (g) { Ge(e, e.return, g) } break; case 4: Ln(t, e), rr(e); break; case 13: Ln(t, e), rr(e), i = e.child, 8192 & i.flags && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (Hp = Ye())), 4 & r && bx(e); break; case 22: if (u = n !== null && n.memoizedState !== null, 1 & e.mode ? (_t = (c = _t) || u, Ln(t, e), _t = c) : Ln(t, e), rr(e), 8192 & r) { if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !u && 1 & e.mode) for (B = e, u = e.child; u !== null;) { for (f = B = u; B !== null;) { switch (d = B, m = d.child, d.tag) { case 0: case 11: case 14: case 15: oa(4, d, d.return); break; case 1: Oo(d, d.return); var y = d.stateNode; if (typeof y.componentWillUnmount == "function") { r = d, n = d.return; try { t = r, y.props = t.memoizedProps, y.state = t.memoizedState, y.componentWillUnmount() } catch (g) { Ge(r, n, g) } } break; case 5: Oo(d, d.return); break; case 22: if (d.memoizedState !== null) { wx(f); continue } }m !== null ? (m.return = d, B = m) : wx(f) } u = u.sibling } e: for (u = null, f = e; ;) { if (f.tag === 5) { if (u === null) { u = f; try { i = f.stateNode, c ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Bx("display", s)) } catch (g) { Ge(e, e.return, g) } } } else if (f.tag === 6) { if (u === null) try { f.stateNode.nodeValue = c ? "" : f.memoizedProps } catch (g) { Ge(e, e.return, g) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === e) break e; for (; f.sibling === null;) { if (f.return === null || f.return === e) break e; u === f && (u = null), f = f.return } u === f && (u = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: Ln(t, e), rr(e), 4 & r && bx(e); break; case 21: break; default: Ln(t, e), rr(e) } } function rr(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; n !== null;) { if (d1(n)) { var r = n; break e } n = n.return } throw Error(M(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (ca(i, ""), r.flags &= -33); var o = yx(e); np(e, o, i); break; case 3: case 4: var s = r.stateNode.containerInfo, a = yx(e); tp(e, a, s); break; default: throw Error(M(161)) } } catch (l) { Ge(e, e.return, l) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function oL(e, t, n) { B = e, m1(e, t, n) } function m1(e, t, n) { for (var r = (1 & e.mode) !== 0; B !== null;) { var i = B, o = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || hc; if (!s) { var a = i.alternate, l = a !== null && a.memoizedState !== null || _t; a = hc; var c = _t; if (hc = s, (_t = l) && !c) for (B = i; B !== null;)s = B, l = s.child, s.tag === 22 && s.memoizedState !== null ? Sx(i) : l !== null ? (l.return = s, B = l) : Sx(i); for (; o !== null;)B = o, m1(o, t, n), o = o.sibling; B = i, hc = a, _t = c } xx(e, t, n) } else 8772 & i.subtreeFlags && o !== null ? (o.return = i, B = o) : xx(e, t, n) } } function xx(e) { for (; B !== null;) { var t = B; if (8772 & t.flags) { var n = t.alternate; try { if (8772 & t.flags) switch (t.tag) { case 0: case 11: case 15: _t || ru(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !_t) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : Mn(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; o !== null && rx(t, o, r); break; case 3: var s = t.updateQueue; if (s !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }rx(t, s, n) } break; case 5: var a = t.stateNode; if (n === null && 4 & t.flags) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var c = t.alternate; if (c !== null) { var u = c.memoizedState; if (u !== null) { var f = u.dehydrated; f !== null && ha(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(M(163)) }_t || 512 & t.flags && ep(t) } catch (d) { Ge(t, t.return, d) } } if (t === e) { B = null; break } if (n = t.sibling, n !== null) { n.return = t.return, B = n; break } B = t.return } } function wx(e) { for (; B !== null;) { var t = B; if (t === e) { B = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, B = n; break } B = t.return } } function Sx(e) { for (; B !== null;) { var t = B; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { ru(4, t) } catch (l) { Ge(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (l) { Ge(t, i, l) } } var o = t.return; try { ep(t) } catch (l) { Ge(t, o, l) } break; case 5: var s = t.return; try { ep(t) } catch (l) { Ge(t, s, l) } } } catch (l) { Ge(t, t.return, l) } if (t === e) { B = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, B = a; break } B = t.return } } var sL = Math.ceil, Wc = Mr.ReactCurrentDispatcher, $p = Mr.ReactCurrentOwner, wn = Mr.ReactCurrentBatchConfig, ve = 0, lt = null, Ze = null, yt = 0, tn = 0, Do = pi(0), nt = 0, Ca = null, Wi = 0, iu = 0, Np = 0, sa = null, Ut = null, Hp = 0, Xo = 1 / 0, Cr = null, Uc = !1, rp = null, li = null, pc = !1, ni = null, Gc = 0, aa = 0, ip = null, Sc = -1, kc = 0; function Vt() { return 6 & ve ? Ye() : Sc !== -1 ? Sc : Sc = Ye() } function ci(e) { return 1 & e.mode ? 2 & ve && yt !== 0 ? yt & -yt : j2.transition !== null ? (kc === 0 && (kc = Qx()), kc) : (e = we, e !== 0 || (e = I.event, e = e === void 0 ? 16 : iw(e.type)), e) : 1 } function Vn(e, t, n, r) { if (50 < aa) throw aa = 0, ip = null, Error(M(185)); Ta(e, n, r), 2 & ve && e === lt || (e === lt && (!(2 & ve) && (iu |= n), nt === 4 && ei(e, yt)), Yt(e, r), n === 1 && ve === 0 && !(1 & t.mode) && (Xo = Ye() + 500, eu && mi())) } function Yt(e, t) { var n = e.callbackNode; UI(e, t); var r = _c(e, e === lt ? yt : 0); if (r === 0) n !== null && Fb(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Fb(n), t === 1) e.tag === 0 ? H2(kx.bind(null, e)) : kw(kx.bind(null, e)), B2(function () { !(6 & ve) && mi() }), n = null; else { switch (Zx(r)) { case 1: n = pp; break; case 4: n = Yx; break; case 16: n = Pc; break; case 536870912: n = Kx; break; default: n = Pc }n = k1(n, g1.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function g1(e, t) { if (Sc = -1, kc = 0, 6 & ve) throw Error(M(327)); var n = e.callbackNode; if (No() && e.callbackNode !== n) return null; var r = _c(e, e === lt ? yt : 0); if (r === 0) return null; if (30 & r || r & e.expiredLanes || t) t = qc(e, r); else { t = r; var i = ve; ve |= 2; var o = y1(); lt === e && yt === t || (Cr = null, Xo = Ye() + 500, zi(e, t)); do try { cL(); break } catch (a) { v1(e, a) } while (1); Rp(), Wc.current = o, ve = i, Ze !== null ? t = 0 : (lt = null, yt = 0, t = nt) } if (t !== 0) { if (t === 2 && (i = Lh(e), i !== 0 && (r = i, t = op(e, i))), t === 1) throw n = Ca, zi(e, 0), ei(e, r), Yt(e, Ye()), n; if (t === 6) ei(e, r); else { if (i = e.current.alternate, !(30 & r) && !aL(i) && (t = qc(e, r), t === 2 && (o = Lh(e), o !== 0 && (r = o, t = op(e, o))), t === 1)) throw n = Ca, zi(e, 0), ei(e, r), Yt(e, Ye()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(M(345)); case 2: Di(e, Ut, Cr); break; case 3: if (ei(e, r), (130023424 & r) === r && (t = Hp + 500 - Ye(), 10 < t)) { if (_c(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { Vt(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = $h(Di.bind(null, e, Ut, Cr), t); break } Di(e, Ut, Cr); break; case 4: if (ei(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - An(r); o = 1 << s, s = t[s], s > i && (i = s), r &= ~o } if (r = i, r = Ye() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * sL(r / 1960)) - r, 10 < r) { e.timeoutHandle = $h(Di.bind(null, e, Ut, Cr), r); break } Di(e, Ut, Cr); break; case 5: Di(e, Ut, Cr); break; default: throw Error(M(329)) } } } return Yt(e, Ye()), e.callbackNode === n ? g1.bind(null, e) : null } function op(e, t) { var n = sa; return e.current.memoizedState.isDehydrated && (zi(e, t).flags |= 256), e = qc(e, t), e !== 2 && (t = Ut, Ut = n, t !== null && sp(t)), e } function sp(e) { Ut === null ? Ut = e : Ut.push.apply(Ut, e) } function aL(e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!Bn(o(), i)) return !1 } catch { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function ei(e, t) { for (t &= ~Np, t &= ~iu, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - An(t), r = 1 << n; e[n] = -1, t &= ~r } } function kx(e) { if (6 & ve) throw Error(M(327)); No(); var t = _c(e, 0); if (!(1 & t)) return Yt(e, Ye()), null; var n = qc(e, t); if (e.tag !== 0 && n === 2) { var r = Lh(e); r !== 0 && (t = r, n = op(e, r)) } if (n === 1) throw n = Ca, zi(e, 0), ei(e, t), Yt(e, Ye()), n; if (n === 6) throw Error(M(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Di(e, Ut, Cr), Yt(e, Ye()), null } function jp(e, t) { var n = ve; ve |= 1; try { return e(t) } finally { ve = n, ve === 0 && (Xo = Ye() + 500, eu && mi()) } } function Ui(e) { ni !== null && ni.tag === 0 && !(6 & ve) && No(); var t = ve; ve |= 1; var n = wn.transition, r = we; try { if (wn.transition = null, we = 1, e) return e() } finally { we = r, wn.transition = n, ve = t, !(6 & ve) && mi() } } function Wp() { tn = Do.current, Le(Do) } function zi(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, V2(n)), Ze !== null) for (n = Ze.return; n !== null;) { var r = n; switch (Cp(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Oc(); break; case 3: Go(), Le(qt), Le(Ft), Mp(); break; case 5: Lp(r); break; case 4: Go(); break; case 13: Le(Be); break; case 19: Le(Be); break; case 10: Pp(r.type._context); break; case 22: case 23: Wp() }n = n.return } if (lt = e, Ze = e = ui(e.current, null), yt = tn = t, nt = 0, Ca = null, Np = iu = Wi = 0, Ut = sa = null, Vi !== null) { for (t = 0; t < Vi.length; t++)if (n = Vi[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, o = n.pending; if (o !== null) { var s = o.next; o.next = i, r.next = s } n.pending = r } Vi = null } return e } function v1(e, t) { do { var n = Ze; try { if (Rp(), bc.current = jc, Hc) { for (var r = ze.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } Hc = !1 } if (ji = 0, at = tt = ze = null, ia = !1, wa = 0, $p.current = null, n === null || n.return === null) { nt = 1, Ca = t, Ze = null; break } e: { var o = e, s = n.return, a = n, l = t; if (t = yt, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, u = a, f = u.tag; if (!(1 & u.mode) && (f === 0 || f === 11 || f === 15)) { var d = u.alternate; d ? (u.updateQueue = d.updateQueue, u.memoizedState = d.memoizedState, u.lanes = d.lanes) : (u.updateQueue = null, u.memoizedState = null) } var m = ux(s); if (m !== null) { m.flags &= -257, fx(m, s, a, o, t), 1 & m.mode && cx(o, c, t), t = m, l = c; var y = t.updateQueue; if (y === null) { var g = new Set; g.add(l), t.updateQueue = g } else y.add(l); break e } if (!(1 & t)) { cx(o, c, t), Up(); break e } l = Error(M(426)) } else if (De && 1 & a.mode) { var b = ux(s); if (b !== null) { !(65536 & b.flags) && (b.flags |= 256), fx(b, s, a, o, t), Tp(qo(l, a)); break e } } o = l = qo(l, a), nt !== 4 && (nt = 2), sa === null ? sa = [o] : sa.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t; var h = Jw(o, l, t); nx(o, h); break e; case 1: a = l; var p = o.type, v = o.stateNode; if (!(128 & o.flags) && (typeof p.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (li === null || !li.has(v)))) { o.flags |= 65536, t &= -t, o.lanes |= t; var w = e1(o, a, t); nx(o, w); break e } }o = o.return } while (o !== null) } x1(n) } catch (C) { t = C, Ze === n && n !== null && (Ze = n = n.return); continue } break } while (1) } function y1() { var e = Wc.current; return Wc.current = jc, e === null ? jc : e } function Up() { nt !== 0 && nt !== 3 && nt !== 2 || (nt = 4), lt === null || !(268435455 & Wi) && !(268435455 & iu) || ei(lt, yt) } function qc(e, t) { var n = ve; ve |= 2; var r = y1(); lt === e && yt === t || (Cr = null, zi(e, t)); do try { lL(); break } catch (i) { v1(e, i) } while (1); if (Rp(), ve = n, Wc.current = r, Ze !== null) throw Error(M(261)); return lt = null, yt = 0, nt } function lL() { for (; Ze !== null;)b1(Ze) } function cL() { for (; Ze !== null && !AI();)b1(Ze) } function b1(e) { var t = S1(e.alternate, e, tn); e.memoizedProps = e.pendingProps, t === null ? x1(e) : Ze = t, $p.current = null } function x1(e) { var t = e; do { var n = t.alternate; if (e = t.return, 32768 & t.flags) { if (n = nL(n, t), n !== null) { n.flags &= 32767, Ze = n; return } if (e === null) { nt = 6, Ze = null; return } e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } else if (n = tL(n, t, tn), n !== null) { Ze = n; return } if (t = t.sibling, t !== null) { Ze = t; return } Ze = t = e } while (t !== null); nt === 0 && (nt = 5) } function Di(e, t, n) { var r = we, i = wn.transition; try { wn.transition = null, we = 1, uL(e, t, n, r) } finally { wn.transition = i, we = r } return null } function uL(e, t, n, r) { do No(); while (ni !== null); if (6 & ve) throw Error(M(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(M(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (GI(e, o), e === lt && (Ze = lt = null, yt = 0), !(2064 & n.subtreeFlags) && !(2064 & n.flags) || pc || (pc = !0, k1(Pc, function () { return No(), null })), o = (15990 & n.flags) !== 0, 15990 & n.subtreeFlags || o) { o = wn.transition, wn.transition = null; var s = we; we = 1; var a = ve; ve |= 4, $p.current = null, iL(e, n), p1(n, e), L2(Bh), Fc = !!Vh, Bh = Vh = null, e.current = n, oL(n, e, i), VI(), ve = a, we = s, wn.transition = o } else e.current = n; if (pc && (pc = !1, ni = e, Gc = i), o = e.pendingLanes, o === 0 && (li = null), $I(n.stateNode, r), Yt(e, Ye()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Uc) throw Uc = !1, e = rp, rp = null, e; return 1 & Gc && e.tag !== 0 && No(), o = e.pendingLanes, 1 & o ? e === ip ? aa++ : (aa = 0, ip = e) : aa = 0, mi(), null } function No() { if (ni !== null) { var e = Zx(Gc), t = wn.transition, n = we; try { if (wn.transition = null, we = 16 > e ? 16 : e, ni === null) var r = !1; else { if (e = ni, ni = null, Gc = 0, 6 & ve) throw Error(M(331)); var i = ve; for (ve |= 4, B = e.current; B !== null;) { var o = B, s = o.child; if (16 & B.flags) { var a = o.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for (B = c; B !== null;) { var u = B; switch (u.tag) { case 0: case 11: case 15: oa(8, u, o) }var f = u.child; if (f !== null) f.return = u, B = f; else for (; B !== null;) { u = B; var d = u.sibling, m = u.return; if (f1(u), u === c) { B = null; break } if (d !== null) { d.return = m, B = d; break } B = m } } } var y = o.alternate; if (y !== null) { var g = y.child; if (g !== null) { y.child = null; do { var b = g.sibling; g.sibling = null, g = b } while (g !== null) } } B = o } } if (2064 & o.subtreeFlags && s !== null) s.return = o, B = s; else e: for (; B !== null;) { if (o = B, 2048 & o.flags) switch (o.tag) { case 0: case 11: case 15: oa(9, o, o.return) }var h = o.sibling; if (h !== null) { h.return = o.return, B = h; break e } B = o.return } } var p = e.current; for (B = p; B !== null;) { s = B; var v = s.child; if (2064 & s.subtreeFlags && v !== null) v.return = s, B = v; else e: for (s = p; B !== null;) { if (a = B, 2048 & a.flags) try { switch (a.tag) { case 0: case 11: case 15: ru(9, a) } } catch (C) { Ge(a, a.return, C) } if (a === s) { B = null; break e } var w = a.sibling; if (w !== null) { w.return = a.return, B = w; break e } B = a.return } } if (ve = i, mi(), sr && typeof sr.onPostCommitFiberRoot == "function") try { sr.onPostCommitFiberRoot(Yc, e) } catch { } r = !0 } return r } finally { we = n, wn.transition = t } } return !1 } function Cx(e, t, n) { t = qo(n, t), t = Jw(e, t, 1), e = ai(e, t, 1), t = Vt(), e !== null && (Ta(e, 1, t), Yt(e, t)) } function Ge(e, t, n) { if (e.tag === 3) Cx(e, e, n); else for (; t !== null;) { if (t.tag === 3) { Cx(t, e, n); break } if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (li === null || !li.has(r))) { e = qo(n, e), e = e1(t, e, 1), t = ai(t, e, 1), e = Vt(), t !== null && (Ta(t, 1, e), Yt(t, e)); break } } t = t.return } } function fL(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = Vt(), e.pingedLanes |= e.suspendedLanes & n, lt === e && (yt & n) === n && (nt === 4 || nt === 3 && (130023424 & yt) === yt && 500 > Ye() - Hp ? zi(e, 0) : Np |= n), Yt(e, t) } function w1(e, t) { t === 0 && (1 & e.mode ? (t = ec, ec <<= 1, !(130023424 & ec) && (ec = 4194304)) : t = 1); var n = Vt(); e = Ir(e, t), e !== null && (Ta(e, t, n), Yt(e, n)) } function dL(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), w1(e, n) } function hL(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(M(314)) }r !== null && r.delete(t), w1(e, n) } var S1; S1 = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || qt.current) Gt = !0; else { if (!(e.lanes & n) && !(128 & t.flags)) return Gt = !1, eL(e, t, n); Gt = (131072 & e.flags) !== 0 } else Gt = !1, De && 1048576 & t.flags && Cw(t, Vc, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; wc(e, t), e = t.pendingProps; var i = jo(t, Ft.current); $o(t, n), i = Dp(null, t, r, e, i, n); var o = Ap(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Xt(r) ? (o = !0, Dc(t)) : o = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, Fp(t), i.updater = tu, t.stateNode = i, i._reactInternals = t, qh(t, r, e, n), t = Kh(null, t, r, !0, o, n)) : (t.tag = 0, De && o && kp(t), At(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (wc(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = mL(r), e = Mn(r, e), i) { case 0: t = Yh(null, t, r, e, n); break e; case 1: t = px(null, t, r, e, n); break e; case 11: t = dx(null, t, r, e, n); break e; case 14: t = hx(null, t, r, Mn(r.type, e), n); break e }throw Error(M(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Mn(r, i), Yh(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Mn(r, i), px(e, t, r, i, n); case 3: e: { if (i1(t), e === null) throw Error(M(387)); r = t.pendingProps, o = t.memoizedState, i = o.element, Pw(e, t), $c(t, r, null, n); var s = t.memoizedState; if (r = s.element, o.isDehydrated) { if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, 256 & t.flags) { i = qo(Error(M(423)), t), t = mx(e, t, r, n, i); break e } if (r !== i) { i = qo(Error(M(424)), t), t = mx(e, t, r, n, i); break e } for (nn = si(t.stateNode.containerInfo.firstChild), rn = t, De = !0, Dn = null, n = Lw(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (Wo(), r === i) { t = Lr(e, t, n); break e } At(e, t, r, n) } t = t.child } return t; case 5: return Mw(t), e === null && Wh(t), r = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, s = i.children, zh(r, i) ? s = null : o !== null && zh(r, o) && (t.flags |= 32), r1(e, t), At(e, t, s, n), t.child; case 6: return e === null && Wh(t), null; case 13: return o1(e, t, n); case 4: return Ip(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Uo(t, null, r, n) : At(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Mn(r, i), dx(e, t, r, i, n); case 7: return At(e, t, t.pendingProps, n), t.child; case 8: return At(e, t, t.pendingProps.children, n), t.child; case 12: return At(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, Re(Bc, r._currentValue), r._currentValue = s, o !== null) if (Bn(o.value, s)) { if (o.children === i.children && !qt.current) { t = Lr(e, t, n); break e } } else for (o = t.child, o !== null && (o.return = t); o !== null;) { var a = o.dependencies; if (a !== null) { s = o.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (o.tag === 1) { l = Pr(-1, n & -n), l.tag = 2; var c = o.updateQueue; if (c !== null) { c = c.shared; var u = c.pending; u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l } } o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), Uh(o.return, n, t), a.lanes |= n; break } l = l.next } } else if (o.tag === 10) s = o.type === t.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(M(341)); s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), Uh(s, n, t), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === t) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } At(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, $o(t, n), i = Sn(i), r = r(i), t.flags |= 1, At(e, t, r, n), t.child; case 14: return r = t.type, i = Mn(r, t.pendingProps), i = Mn(r.type, i), hx(e, t, r, i, n); case 15: return t1(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Mn(r, i), wc(e, t), t.tag = 1, Xt(r) ? (e = !0, Dc(t)) : e = !1, $o(t, n), Fw(t, r, i), qh(t, r, i, n), Kh(null, t, r, !0, e, n); case 19: return s1(e, t, n); case 22: return n1(e, t, n) }throw Error(M(156, t.tag)) }; function k1(e, t) { return Xx(e, t) } function pL(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function xn(e, t, n, r) { return new pL(e, t, n, r) } function Gp(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function mL(e) { if (typeof e == "function") return Gp(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === fp) return 11; if (e === dp) return 14 } return 2 } function ui(e, t) { var n = e.alternate; return n === null ? (n = xn(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Cc(e, t, n, r, i, o) { var s = 2; if (r = e, typeof e == "function") Gp(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case To: return $i(n.children, i, o, t); case up: s = 8, i |= 8; break; case vh: return e = xn(12, n, t, 2 | i), e.elementType = vh, e.lanes = o, e; case yh: return e = xn(13, n, t, i), e.elementType = yh, e.lanes = o, e; case bh: return e = xn(19, n, t, i), e.elementType = bh, e.lanes = o, e; case Ix: return ou(n, i, o, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case _x: s = 10; break e; case Fx: s = 9; break e; case fp: s = 11; break e; case dp: s = 14; break e; case Qr: s = 16, r = null; break e }throw Error(M(130, e == null ? e : typeof e, "")) }return t = xn(s, n, t, i), t.elementType = e, t.type = r, t.lanes = o, t } function $i(e, t, n, r) { return e = xn(7, e, r, t), e.lanes = n, e } function ou(e, t, n, r) { return e = xn(22, e, r, t), e.elementType = Ix, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function ph(e, t, n) { return e = xn(6, e, null, t), e.lanes = n, e } function mh(e, t, n) { return t = xn(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function gL(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Zd(0), this.expirationTimes = Zd(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Zd(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function qp(e, t, n, r, i, o, s, a, l) { return e = new gL(e, t, n, a, l), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = xn(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Fp(o), e } function vL(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Co, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function C1(e) { if (!e) return di; e = e._reactInternals; e: { if (qi(e) !== e || e.tag !== 1) throw Error(M(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Xt(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(M(171)) } if (e.tag === 1) { var n = e.type; if (Xt(n)) return Sw(e, n, t) } return t } function T1(e, t, n, r, i, o, s, a, l) { return e = qp(n, r, !0, e, i, o, s, a, l), e.context = C1(null), n = e.current, r = Vt(), i = ci(n), o = Pr(r, i), o.callback = t ?? null, ai(n, o, i), e.current.lanes = i, Ta(e, i, r), Yt(e, r), e } function su(e, t, n, r) { var i = t.current, o = Vt(), s = ci(i); return n = C1(n), t.context === null ? t.context = n : t.pendingContext = n, t = Pr(o, s), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = ai(i, t, s), e !== null && (Vn(e, i, s, o), yc(e, i, s)), s } function Xc(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Tx(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function Xp(e, t) { Tx(e, t), (e = e.alternate) && Tx(e, t) } function yL() { return null } var E1 = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function Yp(e) { this._internalRoot = e } au.prototype.render = Yp.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(M(409)); su(e, t, null, null) }; au.prototype.unmount = Yp.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Ui(function () { su(null, e, null, null) }), t[Fr] = null } }; function au(e) { this._internalRoot = e } au.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = tw(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Jr.length && t !== 0 && t < Jr[n].priority; n++); Jr.splice(n, 0, e), n === 0 && rw(e) } }; function Kp(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function lu(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Ex() { } function bL(e, t, n, r, i) { if (i) { if (typeof r == "function") { var o = r; r = function () { var c = Xc(s); o.call(c) } } var s = T1(t, r, e, 0, null, !1, !1, "", Ex); return e._reactRootContainer = s, e[Fr] = s.current, ga(e.nodeType === 8 ? e.parentNode : e), Ui(), s } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var c = Xc(l); a.call(c) } } var l = qp(e, 0, !1, null, null, !1, !1, "", Ex); return e._reactRootContainer = l, e[Fr] = l.current, ga(e.nodeType === 8 ? e.parentNode : e), Ui(function () { su(t, l, n, r) }), l } function cu(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var s = o; if (typeof i == "function") { var a = i; i = function () { var l = Xc(s); a.call(l) } } su(t, s, e, i) } else s = bL(n, t, e, i, r); return Xc(s) } Jx = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Qs(t.pendingLanes); n !== 0 && (mp(t, 1 | n), Yt(t, Ye()), !(6 & ve) && (Xo = Ye() + 500, mi())) } break; case 13: Ui(function () { var r = Ir(e, 1); if (r !== null) { var i = Vt(); Vn(r, e, 1, i) } }), Xp(e, 1) } }; gp = function (e) { if (e.tag === 13) { var t = Ir(e, 134217728); if (t !== null) { var n = Vt(); Vn(t, e, 134217728, n) } Xp(e, 134217728) } }; ew = function (e) { if (e.tag === 13) { var t = ci(e), n = Ir(e, t); if (n !== null) { var r = Vt(); Vn(n, e, t, r) } Xp(e, t) } }; tw = function () { return we }; nw = function (e, t) { var n = we; try { return we = e, t() } finally { we = n } }; _h = function (e, t, n) { switch (t) { case "input": if (Sh(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = Jc(r); if (!i) throw Error(M(90)); Mx(r), Sh(r, i) } } } break; case "textarea": Dx(e, n); break; case "select": t = n.value, t != null && Ao(e, !!n.multiple, t, !1) } }; Hx = jp; jx = Ui; var xL = { usingClientEntryPoint: !1, Events: [Ra, _o, Jc, $x, Nx, jp] }, qs = { findFiberByHostInstance: Ai, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, wL = { bundleType: qs.bundleType, version: qs.version, rendererPackageName: qs.rendererPackageName, rendererConfig: qs.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Mr.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Gx(e), e === null ? null : e.stateNode }, findFiberByHostInstance: qs.findFiberByHostInstance || yL, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (Xs = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Xs.isDisabled && Xs.supportsFiber)) try { Yc = Xs.inject(wL), sr = Xs } catch { } var Xs; sn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = xL; sn.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Kp(t)) throw Error(M(200)); return vL(e, t, null, n) }; sn.createRoot = function (e, t) { if (!Kp(e)) throw Error(M(299)); var n = !1, r = "", i = E1; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = qp(e, 1, !1, null, null, n, !1, r, i), e[Fr] = t.current, ga(e.nodeType === 8 ? e.parentNode : e), new Yp(t) }; sn.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(M(188)) : (e = Object.keys(e).join(","), Error(M(268, e))); return e = Gx(t), e = e === null ? null : e.stateNode, e }; sn.flushSync = function (e) { return Ui(e) }; sn.hydrate = function (e, t, n) { if (!lu(t)) throw Error(M(200)); return cu(null, e, t, !0, n) }; sn.hydrateRoot = function (e, t, n) { if (!Kp(e)) throw Error(M(405)); var r = n != null && n.hydratedSources || null, i = !1, o = "", s = E1; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), t = T1(t, null, e, 1, n ?? null, i, !1, o, s), e[Fr] = t.current, ga(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new au(t) }; sn.render = function (e, t, n) { if (!lu(t)) throw Error(M(200)); return cu(null, e, t, !1, n) }; sn.unmountComponentAtNode = function (e) { if (!lu(e)) throw Error(M(40)); return !!e._reactRootContainer && (Ui(function () { cu(null, null, e, !1, function () { e._reactRootContainer = null, e[Fr] = null }) }), !0) }; sn.unstable_batchedUpdates = jp; sn.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!lu(n)) throw Error(M(200)); if (e == null || e._reactInternals === void 0) throw Error(M(38)); return cu(e, t, n, !1, r) }; sn.version = "18.2.0-next-9e3b772b8-20220608"; function R1() { if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE == "function") try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(R1) } catch (e) { console.error(e) } } R1(); var ln = sn, P1 = ln, SL = ln.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, kL = ln.createPortal, CL = ln.createRoot, TL = ln.findDOMNode, EL = ln.flushSync, RL = ln.hydrate, PL = ln.hydrateRoot, _L = ln.render, FL = ln.unmountComponentAtNode, IL = ln.unstable_batchedUpdates, LL = ln.unstable_renderSubtreeIntoContainer, ML = ln.version; var DL = mn({ "../../../node_modules/hsluv/dist/hsluv.cjs"(e) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Hsluv = void 0; var t = class { constructor() { this.hex = "#000000", this.rgb_r = 0, this.rgb_g = 0, this.rgb_b = 0, this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0, this.luv_l = 0, this.luv_u = 0, this.luv_v = 0, this.lch_l = 0, this.lch_c = 0, this.lch_h = 0, this.hsluv_h = 0, this.hsluv_s = 0, this.hsluv_l = 0, this.hpluv_h = 0, this.hpluv_p = 0, this.hpluv_l = 0, this.r0s = 0, this.r0i = 0, this.r1s = 0, this.r1i = 0, this.g0s = 0, this.g0i = 0, this.g1s = 0, this.g1i = 0, this.b0s = 0, this.b0i = 0, this.b1s = 0, this.b1i = 0 } static fromLinear(n) { return n <= .0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055 } static toLinear(n) { return n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92 } static yToL(n) { return n <= t.epsilon ? n / t.refY * t.kappa : 116 * Math.pow(n / t.refY, 1 / 3) - 16 } static lToY(n) { return n <= 8 ? t.refY * n / t.kappa : t.refY * Math.pow((n + 16) / 116, 3) } static rgbChannelToHex(n) { let r = Math.round(n * 255), i = r % 16, o = (r - i) / 16 | 0; return t.hexChars.charAt(o) + t.hexChars.charAt(i) } static hexToRgbChannel(n, r) { let i = t.hexChars.indexOf(n.charAt(r)), o = t.hexChars.indexOf(n.charAt(r + 1)); return (i * 16 + o) / 255 } static distanceFromOriginAngle(n, r, i) { let o = r / (Math.sin(i) - n * Math.cos(i)); return o < 0 ? 1 / 0 : o } static distanceFromOrigin(n, r) { return Math.abs(r) / Math.sqrt(Math.pow(n, 2) + 1) } static min6(n, r, i, o, s, a) { return Math.min(n, Math.min(r, Math.min(i, Math.min(o, Math.min(s, a))))) } rgbToHex() { this.hex = "#", this.hex += t.rgbChannelToHex(this.rgb_r), this.hex += t.rgbChannelToHex(this.rgb_g), this.hex += t.rgbChannelToHex(this.rgb_b) } hexToRgb() { this.hex = this.hex.toLowerCase(), this.rgb_r = t.hexToRgbChannel(this.hex, 1), this.rgb_g = t.hexToRgbChannel(this.hex, 3), this.rgb_b = t.hexToRgbChannel(this.hex, 5) } xyzToRgb() { this.rgb_r = t.fromLinear(t.m_r0 * this.xyz_x + t.m_r1 * this.xyz_y + t.m_r2 * this.xyz_z), this.rgb_g = t.fromLinear(t.m_g0 * this.xyz_x + t.m_g1 * this.xyz_y + t.m_g2 * this.xyz_z), this.rgb_b = t.fromLinear(t.m_b0 * this.xyz_x + t.m_b1 * this.xyz_y + t.m_b2 * this.xyz_z) } rgbToXyz() { let n = t.toLinear(this.rgb_r), r = t.toLinear(this.rgb_g), i = t.toLinear(this.rgb_b); this.xyz_x = .41239079926595 * n + .35758433938387 * r + .18048078840183 * i, this.xyz_y = .21263900587151 * n + .71516867876775 * r + .072192315360733 * i, this.xyz_z = .019330818715591 * n + .11919477979462 * r + .95053215224966 * i } xyzToLuv() { let n = this.xyz_x + 15 * this.xyz_y + 3 * this.xyz_z, r = 4 * this.xyz_x, i = 9 * this.xyz_y; n !== 0 ? (r /= n, i /= n) : (r = NaN, i = NaN), this.luv_l = t.yToL(this.xyz_y), this.luv_l === 0 ? (this.luv_u = 0, this.luv_v = 0) : (this.luv_u = 13 * this.luv_l * (r - t.refU), this.luv_v = 13 * this.luv_l * (i - t.refV)) } luvToXyz() { if (this.luv_l === 0) { this.xyz_x = 0, this.xyz_y = 0, this.xyz_z = 0; return } let n = this.luv_u / (13 * this.luv_l) + t.refU, r = this.luv_v / (13 * this.luv_l) + t.refV; this.xyz_y = t.lToY(this.luv_l), this.xyz_x = 0 - 9 * this.xyz_y * n / ((n - 4) * r - n * r), this.xyz_z = (9 * this.xyz_y - 15 * r * this.xyz_y - r * this.xyz_x) / (3 * r) } luvToLch() { if (this.lch_l = this.luv_l, this.lch_c = Math.sqrt(this.luv_u * this.luv_u + this.luv_v * this.luv_v), this.lch_c < 1e-8) this.lch_h = 0; else { let n = Math.atan2(this.luv_v, this.luv_u); this.lch_h = n * 180 / Math.PI, this.lch_h < 0 && (this.lch_h = 360 + this.lch_h) } } lchToLuv() { let n = this.lch_h / 180 * Math.PI; this.luv_l = this.lch_l, this.luv_u = Math.cos(n) * this.lch_c, this.luv_v = Math.sin(n) * this.lch_c } calculateBoundingLines(n) { let r = Math.pow(n + 16, 3) / 1560896, i = r > t.epsilon ? r : n / t.kappa, o = i * (284517 * t.m_r0 - 94839 * t.m_r2), s = i * (838422 * t.m_r2 + 769860 * t.m_r1 + 731718 * t.m_r0), a = i * (632260 * t.m_r2 - 126452 * t.m_r1), l = i * (284517 * t.m_g0 - 94839 * t.m_g2), c = i * (838422 * t.m_g2 + 769860 * t.m_g1 + 731718 * t.m_g0), u = i * (632260 * t.m_g2 - 126452 * t.m_g1), f = i * (284517 * t.m_b0 - 94839 * t.m_b2), d = i * (838422 * t.m_b2 + 769860 * t.m_b1 + 731718 * t.m_b0), m = i * (632260 * t.m_b2 - 126452 * t.m_b1); this.r0s = o / a, this.r0i = s * n / a, this.r1s = o / (a + 126452), this.r1i = (s - 769860) * n / (a + 126452), this.g0s = l / u, this.g0i = c * n / u, this.g1s = l / (u + 126452), this.g1i = (c - 769860) * n / (u + 126452), this.b0s = f / m, this.b0i = d * n / m, this.b1s = f / (m + 126452), this.b1i = (d - 769860) * n / (m + 126452) } calcMaxChromaHpluv() { let n = t.distanceFromOrigin(this.r0s, this.r0i), r = t.distanceFromOrigin(this.r1s, this.r1i), i = t.distanceFromOrigin(this.g0s, this.g0i), o = t.distanceFromOrigin(this.g1s, this.g1i), s = t.distanceFromOrigin(this.b0s, this.b0i), a = t.distanceFromOrigin(this.b1s, this.b1i); return t.min6(n, r, i, o, s, a) } calcMaxChromaHsluv(n) { let r = n / 360 * Math.PI * 2, i = t.distanceFromOriginAngle(this.r0s, this.r0i, r), o = t.distanceFromOriginAngle(this.r1s, this.r1i, r), s = t.distanceFromOriginAngle(this.g0s, this.g0i, r), a = t.distanceFromOriginAngle(this.g1s, this.g1i, r), l = t.distanceFromOriginAngle(this.b0s, this.b0i, r), c = t.distanceFromOriginAngle(this.b1s, this.b1i, r); return t.min6(i, o, s, a, l, c) } hsluvToLch() { if (this.hsluv_l > 99.9999999) this.lch_l = 100, this.lch_c = 0; else if (this.hsluv_l < 1e-8) this.lch_l = 0, this.lch_c = 0; else { this.lch_l = this.hsluv_l, this.calculateBoundingLines(this.hsluv_l); let n = this.calcMaxChromaHsluv(this.hsluv_h); this.lch_c = n / 100 * this.hsluv_s } this.lch_h = this.hsluv_h } lchToHsluv() { if (this.lch_l > 99.9999999) this.hsluv_s = 0, this.hsluv_l = 100; else if (this.lch_l < 1e-8) this.hsluv_s = 0, this.hsluv_l = 0; else { this.calculateBoundingLines(this.lch_l); let n = this.calcMaxChromaHsluv(this.lch_h); this.hsluv_s = this.lch_c / n * 100, this.hsluv_l = this.lch_l } this.hsluv_h = this.lch_h } hpluvToLch() { if (this.hpluv_l > 99.9999999) this.lch_l = 100, this.lch_c = 0; else if (this.hpluv_l < 1e-8) this.lch_l = 0, this.lch_c = 0; else { this.lch_l = this.hpluv_l, this.calculateBoundingLines(this.hpluv_l); let n = this.calcMaxChromaHpluv(); this.lch_c = n / 100 * this.hpluv_p } this.lch_h = this.hpluv_h } lchToHpluv() { if (this.lch_l > 99.9999999) this.hpluv_p = 0, this.hpluv_l = 100; else if (this.lch_l < 1e-8) this.hpluv_p = 0, this.hpluv_l = 0; else { this.calculateBoundingLines(this.lch_l); let n = this.calcMaxChromaHpluv(); this.hpluv_p = this.lch_c / n * 100, this.hpluv_l = this.lch_l } this.hpluv_h = this.lch_h } hsluvToRgb() { this.hsluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb() } hpluvToRgb() { this.hpluvToLch(), this.lchToLuv(), this.luvToXyz(), this.xyzToRgb() } hsluvToHex() { this.hsluvToRgb(), this.rgbToHex() } hpluvToHex() { this.hpluvToRgb(), this.rgbToHex() } rgbToHsluv() { this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHsluv() } rgbToHpluv() { this.rgbToXyz(), this.xyzToLuv(), this.luvToLch(), this.lchToHpluv(), this.lchToHpluv() } hexToHsluv() { this.hexToRgb(), this.rgbToHsluv() } hexToHpluv() { this.hexToRgb(), this.rgbToHpluv() } }; e.Hsluv = t, t.hexChars = "0123456789abcdef", t.refY = 1, t.refU = .19783000664283, t.refV = .46831999493879, t.kappa = 903.2962962, t.epsilon = .0088564516, t.m_r0 = 3.240969941904521, t.m_r1 = -1.537383177570093, t.m_r2 = -.498610760293, t.m_g0 = -.96924363628087, t.m_g1 = 1.87596750150772, t.m_g2 = .041555057407175, t.m_b0 = .055630079696993, t.m_b1 = -.20397695888897, t.m_b2 = 1.056971514242878 } }), AL = mn({ "../../../node_modules/eventemitter3/index.js"(e, t) { "use strict"; var n = Object.prototype.hasOwnProperty, r = "~"; function i() { } Object.create && (i.prototype = Object.create(null), new i().__proto__ || (r = !1)); function o(c, u, f) { this.fn = c, this.context = u, this.once = f || !1 } function s(c, u, f, d, m) { if (typeof f != "function") throw new TypeError("The listener must be a function"); var y = new o(f, d || c, m), g = r ? r + u : u; return c._events[g] ? c._events[g].fn ? c._events[g] = [c._events[g], y] : c._events[g].push(y) : (c._events[g] = y, c._eventsCount++), c } function a(c, u) { --c._eventsCount === 0 ? c._events = new i : delete c._events[u] } function l() { this._events = new i, this._eventsCount = 0 } l.prototype.eventNames = function () { var u = [], f, d; if (this._eventsCount === 0) return u; for (d in f = this._events) n.call(f, d) && u.push(r ? d.slice(1) : d); return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(f)) : u }, l.prototype.listeners = function (u) { var f = r ? r + u : u, d = this._events[f]; if (!d) return []; if (d.fn) return [d.fn]; for (var m = 0, y = d.length, g = new Array(y); m < y; m++)g[m] = d[m].fn; return g }, l.prototype.listenerCount = function (u) { var f = r ? r + u : u, d = this._events[f]; return d ? d.fn ? 1 : d.length : 0 }, l.prototype.emit = function (u, f, d, m, y, g) { var b = r ? r + u : u; if (!this._events[b]) return !1; var h = this._events[b], p = arguments.length, v, w; if (h.fn) { switch (h.once && this.removeListener(u, h.fn, void 0, !0), p) { case 1: return h.fn.call(h.context), !0; case 2: return h.fn.call(h.context, f), !0; case 3: return h.fn.call(h.context, f, d), !0; case 4: return h.fn.call(h.context, f, d, m), !0; case 5: return h.fn.call(h.context, f, d, m, y), !0; case 6: return h.fn.call(h.context, f, d, m, y, g), !0 }for (w = 1, v = new Array(p - 1); w < p; w++)v[w - 1] = arguments[w]; h.fn.apply(h.context, v) } else { var C = h.length, S; for (w = 0; w < C; w++)switch (h[w].once && this.removeListener(u, h[w].fn, void 0, !0), p) { case 1: h[w].fn.call(h[w].context); break; case 2: h[w].fn.call(h[w].context, f); break; case 3: h[w].fn.call(h[w].context, f, d); break; case 4: h[w].fn.call(h[w].context, f, d, m); break; default: if (!v) for (S = 1, v = new Array(p - 1); S < p; S++)v[S - 1] = arguments[S]; h[w].fn.apply(h[w].context, v) } } return !0 }, l.prototype.on = function (u, f, d) { return s(this, u, f, d, !1) }, l.prototype.once = function (u, f, d) { return s(this, u, f, d, !0) }, l.prototype.removeListener = function (u, f, d, m) { var y = r ? r + u : u; if (!this._events[y]) return this; if (!f) return a(this, y), this; var g = this._events[y]; if (g.fn) g.fn === f && (!m || g.once) && (!d || g.context === d) && a(this, y); else { for (var b = 0, h = [], p = g.length; b < p; b++)(g[b].fn !== f || m && !g[b].once || d && g[b].context !== d) && h.push(g[b]); h.length ? this._events[y] = h.length === 1 ? h[0] : h : a(this, y) } return this }, l.prototype.removeAllListeners = function (u) { var f; return u ? (f = r ? r + u : u, this._events[f] && a(this, f)) : (this._events = new i, this._eventsCount = 0), this }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = r, l.EventEmitter = l, typeof t < "u" && (t.exports = l) } }), Um = mn({ "../../../node_modules/process/browser.js"(e, t) { var n = t.exports = {}, r, i; function o() { throw new Error("setTimeout has not been defined") } function s() { throw new Error("clearTimeout has not been defined") } (function () { try { typeof setTimeout == "function" ? r = setTimeout : r = o } catch { r = o } try { typeof clearTimeout == "function" ? i = clearTimeout : i = s } catch { i = s } })(); function a(h) { if (r === setTimeout) return setTimeout(h, 0); if ((r === o || !r) && setTimeout) return r = setTimeout, setTimeout(h, 0); try { return r(h, 0) } catch { try { return r.call(null, h, 0) } catch { return r.call(this, h, 0) } } } function l(h) { if (i === clearTimeout) return clearTimeout(h); if ((i === s || !i) && clearTimeout) return i = clearTimeout, clearTimeout(h); try { return i(h) } catch { try { return i.call(null, h) } catch { return i.call(this, h) } } } var c = [], u = !1, f, d = -1; function m() { !u || !f || (u = !1, f.length ? c = f.concat(c) : d = -1, c.length && y()) } function y() { if (!u) { var h = a(m); u = !0; for (var p = c.length; p;) { for (f = c, c = []; ++d < p;)f && f[d].run(); d = -1, p = c.length } f = null, u = !1, l(h) } } n.nextTick = function (h) { var p = new Array(arguments.length - 1); if (arguments.length > 1) for (var v = 1; v < arguments.length; v++)p[v - 1] = arguments[v]; c.push(new g(h, p)), c.length === 1 && !u && a(y) }; function g(h, p) { this.fun = h, this.array = p } g.prototype.run = function () { this.fun.apply(null, this.array) }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}; function b() { } n.on = b, n.addListener = b, n.once = b, n.off = b, n.removeListener = b, n.removeAllListeners = b, n.emit = b, n.prependListener = b, n.prependOnceListener = b, n.listeners = function (h) { return [] }, n.binding = function (h) { throw new Error("process.binding is not supported") }, n.cwd = function () { return "/" }, n.chdir = function (h) { throw new Error("process.chdir is not supported") }, n.umask = function () { return 0 } } }), VL = mn({ "../../../node_modules/@juggle/resize-observer/lib/exports/resize-observer.umd.js"(e, t) { (function (n, r) { typeof e == "object" && typeof t < "u" ? r(e) : typeof define == "function" && define.amd ? define(["exports"], r) : (n = typeof globalThis < "u" ? globalThis : n || self, r(n.ResizeObserver = {})) })(e, function (n) { "use strict"; var r = [], i = function () { return r.some(function (P) { return P.activeTargets.length > 0 }) }, o = function () { return r.some(function (P) { return P.skippedTargets.length > 0 }) }, s = "ResizeObserver loop completed with undelivered notifications.", a = function () { var P; typeof ErrorEvent == "function" ? P = new ErrorEvent("error", { message: s }) : (P = document.createEvent("Event"), P.initEvent("error", !1, !1), P.message = s), I.dispatchEvent(P) }, l; (function (P) { P.BORDER_BOX = "border-box", P.CONTENT_BOX = "content-box", P.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box" })(l || (l = {})); var c = function (P) { return Object.freeze(P) }, u = function () { function P(_, O) { this.inlineSize = _, this.blockSize = O, c(this) } return P }(), f = function () { function P(_, O, j, ge) { return this.x = _, this.y = O, this.width = j, this.height = ge, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, c(this) } return P.prototype.toJSON = function () { var _ = this, O = _.x, j = _.y, ge = _.top, Mt = _.right, pt = _.bottom, Xe = _.left, pr = _.width, Zt = _.height; return { x: O, y: j, top: ge, right: Mt, bottom: pt, left: Xe, width: pr, height: Zt } }, P.fromRect = function (_) { return new P(_.x, _.y, _.width, _.height) }, P }(), d = function (P) { return P instanceof SVGElement && "getBBox" in P }, m = function (P) { if (d(P)) { var _ = P.getBBox(), O = _.width, j = _.height; return !O && !j } var ge = P, Mt = ge.offsetWidth, pt = ge.offsetHeight; return !(Mt || pt || P.getClientRects().length) }, y = function (P) { var _, O; if (P instanceof Element) return !0; var j = (O = (_ = P) === null || _ === void 0 ? void 0 : _.ownerDocument) === null || O === void 0 ? void 0 : O.defaultView; return !!(j && P instanceof j.Element) }, g = function (P) { switch (P.tagName) { case "INPUT": if (P.type !== "image") break; case "VIDEO": case "AUDIO": case "EMBED": case "OBJECT": case "CANVAS": case "IFRAME": case "IMG": return !0 }return !1 }, b = typeof I < "u" ? I : {}, h = new WeakMap, p = /auto|scroll/, v = /^tb|vertical/, w = /msie|trident/i.test(b.navigator && b.navigator.userAgent), C = function (P) { return parseFloat(P || "0") }, S = function (P, _, O) { return P === void 0 && (P = 0), _ === void 0 && (_ = 0), O === void 0 && (O = !1), new u((O ? _ : P) || 0, (O ? P : _) || 0) }, R = c({ devicePixelContentBoxSize: S(), borderBoxSize: S(), contentBoxSize: S(), contentRect: new f(0, 0, 0, 0) }), E = function (P, _) { if (_ === void 0 && (_ = !1), h.has(P) && !_) return h.get(P); if (m(P)) return h.set(P, R), R; var O = getComputedStyle(P), j = d(P) && P.ownerSVGElement && P.getBBox(), ge = !w && O.boxSizing === "border-box", Mt = v.test(O.writingMode || ""), pt = !j && p.test(O.overflowY || ""), Xe = !j && p.test(O.overflowX || ""), pr = j ? 0 : C(O.paddingTop), Zt = j ? 0 : C(O.paddingRight), Ci = j ? 0 : C(O.paddingBottom), ro = j ? 0 : C(O.paddingLeft), dT = j ? 0 : C(O.borderTopWidth), hT = j ? 0 : C(O.borderRightWidth), pT = j ? 0 : C(O.borderBottomWidth), mT = j ? 0 : C(O.borderLeftWidth), kg = ro + Zt, Cg = pr + Ci, nf = mT + hT, rf = dT + pT, Tg = Xe ? P.offsetHeight - rf - P.clientHeight : 0, Eg = pt ? P.offsetWidth - nf - P.clientWidth : 0, gT = ge ? kg + nf : 0, vT = ge ? Cg + rf : 0, al = j ? j.width : C(O.width) - gT - Eg, ll = j ? j.height : C(O.height) - vT - Tg, yT = al + kg + Eg + nf, bT = ll + Cg + Tg + rf, Rg = c({ devicePixelContentBoxSize: S(Math.round(al * devicePixelRatio), Math.round(ll * devicePixelRatio), Mt), borderBoxSize: S(yT, bT, Mt), contentBoxSize: S(al, ll, Mt), contentRect: new f(ro, pr, al, ll) }); return h.set(P, Rg), Rg }, L = function (P, _, O) { var j = E(P, O), ge = j.borderBoxSize, Mt = j.contentBoxSize, pt = j.devicePixelContentBoxSize; switch (_) { case l.DEVICE_PIXEL_CONTENT_BOX: return pt; case l.BORDER_BOX: return ge; default: return Mt } }, F = function () { function P(_) { var O = E(_); this.target = _, this.contentRect = O.contentRect, this.borderBoxSize = c([O.borderBoxSize]), this.contentBoxSize = c([O.contentBoxSize]), this.devicePixelContentBoxSize = c([O.devicePixelContentBoxSize]) } return P }(), z = function (P) { if (m(P)) return 1 / 0; for (var _ = 0, O = P.parentNode; O;)_ += 1, O = O.parentNode; return _ }, D = function () { var P = 1 / 0, _ = []; r.forEach(function (pt) { if (pt.activeTargets.length !== 0) { var Xe = []; pt.activeTargets.forEach(function (Zt) { var Ci = new F(Zt.target), ro = z(Zt.target); Xe.push(Ci), Zt.lastReportedSize = L(Zt.target, Zt.observedBox), ro < P && (P = ro) }), _.push(function () { pt.callback.call(pt.observer, Xe, pt.observer) }), pt.activeTargets.splice(0, pt.activeTargets.length) } }); for (var O = 0, j = _; O < j.length; O++) { var ge = j[O]; ge() } return P }, K = function (P) { r.forEach(function (O) { O.activeTargets.splice(0, O.activeTargets.length), O.skippedTargets.splice(0, O.skippedTargets.length), O.observationTargets.forEach(function (ge) { ge.isActive() && (z(ge.target) > P ? O.activeTargets.push(ge) : O.skippedTargets.push(ge)) }) }) }, U = function () { var P = 0; for (K(P); i();)P = D(), K(P); return o() && a(), P > 0 }, $, W = [], ee = function () { return W.splice(0).forEach(function (P) { return P() }) }, te = function (P) { if (!$) { var _ = 0, O = document.createTextNode(""), j = { characterData: !0 }; new MutationObserver(function () { return ee() }).observe(O, j), $ = function () { O.textContent = "" + (_ ? _-- : _++) } } W.push(P), $() }, q = function (P) { te(function () { requestAnimationFrame(P) }) }, ne = 0, be = function () { return !!ne }, re = 250, pe = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, ie = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], ht = function (P) { return P === void 0 && (P = 0), Date.now() + P }, _e = !1, Lt = function () { function P() { var _ = this; this.stopped = !0, this.listener = function () { return _.schedule() } } return P.prototype.run = function (_) { var O = this; if (_ === void 0 && (_ = re), !_e) { _e = !0; var j = ht(_); q(function () { var ge = !1; try { ge = U() } finally { if (_e = !1, _ = j - ht(), !be()) return; ge ? O.run(1e3) : _ > 0 ? O.run(_) : O.start() } }) } }, P.prototype.schedule = function () { this.stop(), this.run() }, P.prototype.observe = function () { var _ = this, O = function () { return _.observer && _.observer.observe(document.body, pe) }; document.body ? O() : b.addEventListener("DOMContentLoaded", O) }, P.prototype.start = function () { var _ = this; this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), ie.forEach(function (O) { return b.addEventListener(O, _.listener, !0) })) }, P.prototype.stop = function () { var _ = this; this.stopped || (this.observer && this.observer.disconnect(), ie.forEach(function (O) { return b.removeEventListener(O, _.listener, !0) }), this.stopped = !0) }, P }(), Se = new Lt, Qt = function (P) { !ne && P > 0 && Se.start(), ne += P, !ne && Se.stop() }, Pn = function (P) { return !d(P) && !g(P) && getComputedStyle(P).display === "inline" }, _n = function () { function P(_, O) { this.target = _, this.observedBox = O || l.CONTENT_BOX, this.lastReportedSize = { inlineSize: 0, blockSize: 0 } } return P.prototype.isActive = function () { var _ = L(this.target, this.observedBox, !0); return Pn(this.target) && (this.lastReportedSize = _), this.lastReportedSize.inlineSize !== _.inlineSize || this.lastReportedSize.blockSize !== _.blockSize }, P }(), me = function () { function P(_, O) { this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = _, this.callback = O } return P }(), Gn = new WeakMap, ot = function (P, _) { for (var O = 0; O < P.length; O += 1)if (P[O].target === _) return O; return -1 }, dn = function () { function P() { } return P.connect = function (_, O) { var j = new me(_, O); Gn.set(_, j) }, P.observe = function (_, O, j) { var ge = Gn.get(_), Mt = ge.observationTargets.length === 0; ot(ge.observationTargets, O) < 0 && (Mt && r.push(ge), ge.observationTargets.push(new _n(O, j && j.box)), Qt(1), Se.schedule()) }, P.unobserve = function (_, O) { var j = Gn.get(_), ge = ot(j.observationTargets, O), Mt = j.observationTargets.length === 1; ge >= 0 && (Mt && r.splice(r.indexOf(j), 1), j.observationTargets.splice(ge, 1), Qt(-1)) }, P.disconnect = function (_) { var O = this, j = Gn.get(_); j.observationTargets.slice().forEach(function (ge) { return O.unobserve(_, ge.target) }), j.activeTargets.splice(0, j.activeTargets.length) }, P }(), sl = function () { function P(_) { if (arguments.length === 0) throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present."); if (typeof _ != "function") throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function."); dn.connect(this, _) } return P.prototype.observe = function (_, O) { if (arguments.length === 0) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present."); if (!y(_)) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element"); dn.observe(this, _, O) }, P.prototype.unobserve = function (_) { if (arguments.length === 0) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present."); if (!y(_)) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element"); dn.unobserve(this, _) }, P.prototype.disconnect = function () { dn.disconnect(this) }, P.toString = function () { return "function ResizeObserver () { [polyfill code] }" }, P }(); n.ResizeObserver = sl, n.ResizeObserverEntry = F, n.ResizeObserverSize = u, Object.defineProperty(n, "__esModule", { value: !0 }) }) } }), BL = mn({ "../../../node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"(e) { "use strict"; var t = typeof Symbol == "function" && Symbol.for, n = t ? Symbol.for("react.element") : 60103, r = t ? Symbol.for("react.portal") : 60106, i = t ? Symbol.for("react.fragment") : 60107, o = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, a = t ? Symbol.for("react.provider") : 60109, l = t ? Symbol.for("react.context") : 60110, c = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, f = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, m = t ? Symbol.for("react.suspense_list") : 60120, y = t ? Symbol.for("react.memo") : 60115, g = t ? Symbol.for("react.lazy") : 60116, b = t ? Symbol.for("react.block") : 60121, h = t ? Symbol.for("react.fundamental") : 60117, p = t ? Symbol.for("react.responder") : 60118, v = t ? Symbol.for("react.scope") : 60119; function w(S) { if (typeof S == "object" && S !== null) { var R = S.$$typeof; switch (R) { case n: switch (S = S.type, S) { case c: case u: case i: case s: case o: case d: return S; default: switch (S = S && S.$$typeof, S) { case l: case f: case g: case y: case a: return S; default: return R } }case r: return R } } } function C(S) { return w(S) === u } e.AsyncMode = c, e.ConcurrentMode = u, e.ContextConsumer = l, e.ContextProvider = a, e.Element = n, e.ForwardRef = f, e.Fragment = i, e.Lazy = g, e.Memo = y, e.Portal = r, e.Profiler = s, e.StrictMode = o, e.Suspense = d, e.isAsyncMode = function (S) { return C(S) || w(S) === c }, e.isConcurrentMode = C, e.isContextConsumer = function (S) { return w(S) === l }, e.isContextProvider = function (S) { return w(S) === a }, e.isElement = function (S) { return typeof S == "object" && S !== null && S.$$typeof === n }, e.isForwardRef = function (S) { return w(S) === f }, e.isFragment = function (S) { return w(S) === i }, e.isLazy = function (S) { return w(S) === g }, e.isMemo = function (S) { return w(S) === y }, e.isPortal = function (S) { return w(S) === r }, e.isProfiler = function (S) { return w(S) === s }, e.isStrictMode = function (S) { return w(S) === o }, e.isSuspense = function (S) { return w(S) === d }, e.isValidElementType = function (S) { return typeof S == "string" || typeof S == "function" || S === i || S === u || S === s || S === o || S === d || S === m || typeof S == "object" && S !== null && (S.$$typeof === g || S.$$typeof === y || S.$$typeof === a || S.$$typeof === l || S.$$typeof === f || S.$$typeof === h || S.$$typeof === p || S.$$typeof === v || S.$$typeof === b) }, e.typeOf = w } }), zL = mn({ "../../../node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(e, t) { "use strict"; t.exports = BL() } }), Wu = mn({ "../../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(e, t) { "use strict"; var n = zL(), r = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, i = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, o = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, s = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, a = {}; a[n.ForwardRef] = o, a[n.Memo] = s; function l(b) { return n.isMemo(b) ? s : a[b.$$typeof] || r } var c = Object.defineProperty, u = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, d = Object.getOwnPropertyDescriptor, m = Object.getPrototypeOf, y = Object.prototype; function g(b, h, p) { if (typeof h != "string") { if (y) { var v = m(h); v && v !== y && g(b, v, p) } var w = u(h); f && (w = w.concat(f(h))); for (var C = l(b), S = l(h), R = 0; R < w.length; ++R) { var E = w[R]; if (!i[E] && !(p && p[E]) && !(S && S[E]) && !(C && C[E])) { var L = d(h, E); try { c(b, E, L) } catch { } } } } return b } t.exports = g } }), $L = mn({
    "../../../node_modules/archy/index.js"(e, t) {
        t.exports = function n(r, i, o) {
            i === void 0 && (i = ""), o || (o = {}); var s = function (u) { var f = { "\u2502": "|", "\u2514": "`", "\u251C": "+", "\u2500": "-", "\u252C": "-" }; return o.unicode === !1 ? f[u] : u }; typeof r == "string" && (r = { label: r }); var a = r.nodes || [], l = (r.label || "").split(`
`), c = `
`+ i + (a.length ? s("\u2502") : " ") + " "; return i + l.join(c) + `
`+ a.map(function (u, f) { var d = f === a.length - 1, m = u.nodes && u.nodes.length, y = i + (d ? " " : s("\u2502")) + " "; return i + s(d ? "\u2514" : "\u251C") + s("\u2500") + s(m ? "\u252C" : "\u2500") + " " + n(u, y, o).slice(i.length + 2) }).join("")
        }
    }
}), NL = mn({ "../../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js"(e, t) { (function () { function n(h, p) { document.addEventListener ? h.addEventListener("scroll", p, !1) : h.attachEvent("scroll", p) } function r(h) { document.body ? h() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function p() { document.removeEventListener("DOMContentLoaded", p), h() }) : document.attachEvent("onreadystatechange", function p() { (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", p), h()) }) } function i(h) { this.a = document.createElement("div"), this.a.setAttribute("aria-hidden", "true"), this.a.appendChild(document.createTextNode(h)), this.b = document.createElement("span"), this.c = document.createElement("span"), this.h = document.createElement("span"), this.f = document.createElement("span"), this.g = -1, this.b.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.c.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.f.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.h.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.b.appendChild(this.h), this.c.appendChild(this.f), this.a.appendChild(this.b), this.a.appendChild(this.c) } function o(h, p) { h.a.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + p + ";" } function s(h) { var p = h.a.offsetWidth, v = p + 100; return h.f.style.width = v + "px", h.c.scrollLeft = v, h.b.scrollLeft = h.b.scrollWidth + 100, h.g !== p ? (h.g = p, !0) : !1 } function a(h, p) { function v() { var C = w; s(C) && C.a.parentNode && p(C.g) } var w = h; n(h.b, v), n(h.c, v), s(h) } function l(h, p) { var v = p || {}; this.family = h, this.style = v.style || "normal", this.weight = v.weight || "normal", this.stretch = v.stretch || "normal" } var c = null, u = null, f = null, d = null; function m() { if (u === null) if (y() && /Apple/.test(I.navigator.vendor)) { var h = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(I.navigator.userAgent); u = !!h && 603 > parseInt(h[1], 10) } else u = !1; return u } function y() { return d === null && (d = !!document.fonts), d } function g() { if (f === null) { var h = document.createElement("div"); try { h.style.font = "condensed 100px sans-serif" } catch { } f = h.style.font !== "" } return f } function b(h, p) { return [h.style, h.weight, g() ? h.stretch : "", "100px", p].join(" ") } l.prototype.load = function (h, p) { var v = this, w = h || "BESbswy", C = 0, S = p || 3e3, R = new Date().getTime(); return new Promise(function (E, L) { if (y() && !m()) { var F = new Promise(function (D, K) { function U() { new Date().getTime() - R >= S ? K(Error("" + S + "ms timeout exceeded")) : document.fonts.load(b(v, '"' + v.family + '"'), w).then(function ($) { 1 <= $.length ? D() : setTimeout(U, 25) }, K) } U() }), z = new Promise(function (D, K) { C = setTimeout(function () { K(Error("" + S + "ms timeout exceeded")) }, S) }); Promise.race([z, F]).then(function () { clearTimeout(C), E(v) }, L) } else r(function () { function D() { var ie; (ie = ee != -1 && te != -1 || ee != -1 && q != -1 || te != -1 && q != -1) && ((ie = ee != te && ee != q && te != q) || (c === null && (ie = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(I.navigator.userAgent), c = !!ie && (536 > parseInt(ie[1], 10) || parseInt(ie[1], 10) === 536 && 11 >= parseInt(ie[2], 10))), ie = c && (ee == ne && te == ne && q == ne || ee == be && te == be && q == be || ee == re && te == re && q == re)), ie = !ie), ie && (pe.parentNode && pe.parentNode.removeChild(pe), clearTimeout(C), E(v)) } function K() { if (new Date().getTime() - R >= S) pe.parentNode && pe.parentNode.removeChild(pe), L(Error("" + S + "ms timeout exceeded")); else { var ie = document.hidden; (ie === !0 || ie === void 0) && (ee = U.a.offsetWidth, te = $.a.offsetWidth, q = W.a.offsetWidth, D()), C = setTimeout(K, 50) } } var U = new i(w), $ = new i(w), W = new i(w), ee = -1, te = -1, q = -1, ne = -1, be = -1, re = -1, pe = document.createElement("div"); pe.dir = "ltr", o(U, b(v, "sans-serif")), o($, b(v, "serif")), o(W, b(v, "monospace")), pe.appendChild(U.a), pe.appendChild($.a), pe.appendChild(W.a), document.body.appendChild(pe), ne = U.a.offsetWidth, be = $.a.offsetWidth, re = W.a.offsetWidth, K(), a(U, function (ie) { ee = ie, D() }), o(U, b(v, '"' + v.family + '",sans-serif')), a($, function (ie) { te = ie, D() }), o($, b(v, '"' + v.family + '",serif')), a(W, function (ie) { q = ie, D() }), o(W, b(v, '"' + v.family + '",monospace')) }) }) }, typeof t == "object" ? t.exports = l : (I.FontFaceObserver = l, I.FontFaceObserver.prototype.load = l.prototype.load) })() } }); function wm(e, t) { let n = { style: t }; return x.isValidElement(e) ? x.cloneElement(e, n) : x.createElement(e, n) } var HL = class extends Error { }, xu = class extends Error { }, jL = class extends Ee { constructor(e) { super(e), this.state = { error: void 0, forceUpdateKey: e.forceUpdateKey } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { if (e.forceUpdateKey !== t.forceUpdateKey) { let n = { forceUpdateKey: e.forceUpdateKey }; return t.error && (n.error = void 0), n } return null } render() { if (this.state.error === void 0) return this.props.children; if (!(this.state.error instanceof HL)) { let n = new xu; throw n.cause = this.state.error, n } let { notFoundPage: e, defaultPageStyle: t } = this.props; if (!e) throw this.state.error; return wm(e, t) } }, WL = ":([a-z]\\w*)", eo = new RegExp(WL, "gi"); function ck(e, t) { return e.replace(eo, (n, r) => { let i = t[r]; return typeof i != "string" || i.length === 0 ? n : encodeURIComponent(i) }) } function uk(e, t) { if (!e.startsWith("/") || !t.startsWith("/")) throw new Error("from/to paths are expected to be absolute"); let [n] = _1(e), [r, i] = _1(t), o = UL(n, r); return o === "" && (o = "."), !o.startsWith(".") && !o.startsWith("/") && (o = "./" + o), o + "/" + i } function _1(e) { let t = e.lastIndexOf("/"); return [e.substring(0, t + 1), e.substring(t + 1)] } var Qp = 46, es = 47, Si = (e, t) => e.charCodeAt(t), F1 = (e, t) => e.lastIndexOf(t), ns = (e, t, n) => e.slice(t, n); function UL(e, t) { if (e === t || (e = "/" + L1(e), t = "/" + L1(t), e === t)) return ""; let n = 1, r = e.length, i = r - n, o = 1, s = t.length - o, a = i < s ? i : s, l = -1, c = 0; for (; c < a; c++) { let f = Si(e, n + c); if (f !== Si(t, o + c)) break; f === es && (l = c) } if (c === a) if (s > a) { if (Si(t, o + c) === es) return ns(t, o + c + 1); if (c === 0) return ns(t, o + c) } else i > a && (Si(e, n + c) === es ? l = c : c === 0 && (l = 0)); let u = ""; for (c = n + l + 1; c <= r; ++c)(c === r || Si(e, c) === es) && (u += u.length === 0 ? ".." : "/.."); return `${u}${ns(t, o + l)}` } var GL = !1, uu = "/", I1 = e => e === es; function L1(e) { let t = "", n = 0, r = -1, i = 0, o = 0; for (let s = 0; s <= e.length; ++s) { if (s < e.length) o = Si(e, s); else { if (I1(o)) break; o = es } if (I1(o)) { if (!(r === s - 1 || i === 1)) if (i === 2) { if (t.length < 2 || n !== 2 || Si(t, t.length - 1) !== Qp || Si(t, t.length - 2) !== Qp) { if (t.length > 2) { let a = F1(t, uu); a === -1 ? (t = "", n = 0) : (t = ns(t, 0, a), n = t.length - 1 - F1(t, uu)), r = s, i = 0; continue } else if (t.length !== 0) { t = "", n = 0, r = s, i = 0; continue } } GL && (t += t.length > 0 ? `${uu}..` : "..", n = 2) } else t.length > 0 ? t += `${uu}${ns(e, r + 1, s)}` : t = ns(e, r + 1, s), n = s - r - 1; r = s, i = 0 } else o === Qp && i !== -1 ? ++i : i = -1 } return t } function fk(e) { let t = typeof I < "u" ? I.location.search : ""; return t ? qL(t, e) : e } function qL(e, t) { let n = t.indexOf("#"), r = n === -1 ? t : t.substring(0, n), i = n === -1 ? "" : t.substring(n), o = r.indexOf("?"); if (o === -1) return r + e + i; let s = new URLSearchParams(e), a = r.substring(o + 1), l = new URLSearchParams(a); for (let [c, u] of s) l.has(c) || l.append(c, u); return r.substring(0, o + 1) + l.toString() + i } function Aa(e) { return typeof e == "object" && e !== null && !Array.isArray(e) } function Zi(e) { return typeof e == "string" } var XL = "preload"; function dk(e) { return typeof e == "object" && e !== null && !x.isValidElement(e) && XL in e } function H6(e) { let t = x.lazy(e), n, r, i = x.forwardRef(function (s, a) { return x.createElement(r ?? t, a ? { ref: a, ...s } : s) }); return i.preload = () => (n || (n = e().then(o => (r = o.default, r))), n), i } function Gm(e, t) { if (t && e) return e.elements && t in e.elements ? e.elements[t] : t } function YL(e) { return /bot|-google|google-|yandex|ia_archiver/iu.test(e) } function hk(e) { if ("scheduler" in I) { if ("yield" in scheduler) return scheduler.yield(e); if ("postTask" in scheduler) return scheduler.postTask(() => { }, e) } return e?.priority === "user-blocking" ? Promise.resolve() : new Promise(t => { setTimeout(t) }) } async function KL(e, t) { return await hk(t), e() } function Va(e, t = !0) { return new Promise(n => { t && setTimeout(n, 100), requestAnimationFrame(() => { KL(n, e) }) }) } function qm(e, t, n, r = !1) { et(() => { (async () => { await Va(n, r), e() })() }, t) } var Iu = () => { }; async function QL(e, t, n, r, i, o, s) { var a, l, c; let u = e, f = !1, d = { ...o }, m = Array.from(u.matchAll(eo)), y = await Promise.all(m.map(async p => { var v; let w = p?.[0], C = p?.[1]; if (!w || !C) throw new Error("Failed to replace path variables: unexpected regex match group"); let S = o[C]; if (!S || !Zi(S)) throw new Error(`No slug found for path variable ${C}`); let R = await ((v = s?.[i]) === null || v === void 0 ? void 0 : v.call(s)); if (!R || !t) return S; let E = await R.getRecordIdBySlug(S, t); if (!E) return S; let L = await R.getSlugByRecordId(E, n); if (!L) { f = !0; let F = await R.getSlugByRecordId(E, r); return F && (d[C] = F), F ?? S } return d[C] = L, L })), g = 0, b = "", h = !1; for (let p = 0; p < m.length; p++) { let v = m[p], w = y[p]; !v || !w || (b += u.substring(g, v.index), g = ((a = v.index) !== null && a !== void 0 ? a : 0) + ((c = (l = v[0]) === null || l === void 0 ? void 0 : l.length) !== null && c !== void 0 ? c : 0), b += y[p], h = !0) } return h && (u = b), { path: u, pathVariables: d, isMissingInLocale: f } } async function ZL({ currentLocale: e, nextLocale: t, defaultLocale: n, route: r, pathVariables: i, collectionUtils: o, preserveQueryParams: s }) { let { path: a } = r, l = { path: a, pathVariables: i, isMissingInLocale: !1 }; if (!a) return l; if (i && r.collectionId) try { l = await QL(a, e, t, n, r.collectionId, i, o) } catch { } return t.slug && (l.path = "/" + t.slug + l.path), s && l.path && (l.path = fk(l.path)), l } function JL(e, t, { global: n, routes: r }) { var i; return ((i = r[e]) === null || i === void 0 ? void 0 : i[t]) || n } var eM = { global: void 0, routes: {} }, pk = x.createContext(eM); function G6({ children: e, value: t }) { return k(pk.Provider, { value: t, children: e }) } function tM() { return x.useContext(pk) } var Zp = 10, nM = 1e4; function rM(e) { let t = Zp, n = e.next(0), r = [n.value]; for (; !n.done && t < nM;)n = e.next(t), r.push(n.value), t += Zp; return r.length === 1 && r.push(n.value), { easing: `linear(${r.join(",")})`, duration: t - Zp } } var Br = e => `--view-transition-${e}`; function Sm(e) { return [parseFloat(e), e.endsWith("px") ? "px" : "%"] } function mk(e) { let { innerWidth: t, innerHeight: n } = I, [r, i] = Sm(e.x), [o, s] = Sm(e.y); return { x: i === "px" ? r : t * (r / 100), y: s === "px" ? o : n * (o / 100) } } var iM = {
    makeKeyframe: (e, t, n) => { let r = 0; return (n === "exit" && e.angularDirection === "clockwise" && t === "start" || n === "exit" && e.angularDirection === "counter-clockwise" && t === "end" || n === "enter" && e.angularDirection === "counter-clockwise" && t === "start" || n === "enter" && e.angularDirection === "clockwise" && t === "end") && (r = e.sweepAngle / 360 * 100), `${Br("conic-offset")}: ${r}%;` }, makeStyles: (e, t) => { let n = `var(${Br("conic-offset")})`, r = t === "exit" && e.angularDirection === "clockwise" || t === "enter" && e.angularDirection === "counter-clockwise", i = r ? "transparent" : "black", o = r ? "black" : "transparent", s = "conic-gradient(from "; return s += `${e.angle}deg at ${e.x} ${e.y}, `, s += `${i} 0%, ${i} ${n}, `, s += `${o} ${n}, ${o} 100%)`, `mask-image: ${s}; -webkit-mask-image: ${s};` }, makePropertyRules: () => `
        @property ${Br("conic-offset")} {
            syntax: '<percentage>';
            initial-value: 0%;
            inherits: false;
        }
    `}, oM = { makeKeyframe: (e, t) => { let { x: n, y: r } = mk(e); return t === "start" ? `clip-path: circle(0 at ${n}px ${r}px);` : `clip-path: circle(${Math.hypot(Math.max(n, I.innerWidth - n), Math.max(r, I.innerHeight - r))}px at ${n}px ${r}px);` } }, sM = { makeKeyframe: (e, t) => { let { x: n, y: r } = mk(e), i = I.innerHeight - r, o = I.innerWidth - n; return t === "start" ? `clip-path: inset(${r}px ${o}px ${i}px ${n}px round ${e.round}px);` : "clip-path: inset(0 round 0);" } }, aM = {
        makeKeyframe: (e, t, n) => { let [, r] = Sm(e.width), i = `0${r}`; return (t === "start" && n === "exit" || t === "end" && n === "enter") && (i = e.width), `${Br("blinds-width")}: ${i};` }, makeStyles: (e, t) => { let n = `var(${Br("blinds-width")})`, r = t === "exit" ? "transparent" : "black", i = t === "exit" ? "black" : "transparent", o = "repeating-linear-gradient("; return o += e.angle + 90 + "deg, ", o += `${r} 0px, ${r} ${n}, `, o += `${i} ${n}, ${i} ${e.width})`, `mask-image: ${o}; -webkit-mask-image: ${o};` }, makePropertyRules: () => `
            @property ${Br("blinds-width")} {
                syntax: '<length-percentage>';
                initial-value: 0px;
                inherits: false;
            }
        `}, lM = {
        makeKeyframe: (e, t, n) => { let r = t === "start" && n === "exit" || t === "end" && n === "enter" ? 1 : 0; return `${Br("wipe-offset")}: ${r};` }, makeStyles: (e, t) => { let n = `var(${Br("wipe-offset")})`, r = t === "exit" ? "transparent" : "black", i = t === "exit" ? "black" : "transparent", o = "linear-gradient("; return o += e.angle + 90 + "deg, ", o += `${r} calc(calc(0% - ${e.width}) + calc(calc(100% + ${e.width}) * ${n})), `, o += `${i} calc(calc(100% + ${e.width}) * ${n}))`, `mask-image: ${o}; -webkit-mask-image: ${o};` }, makePropertyRules: () => `
            @property ${Br("wipe-offset")} {
                syntax: '<number>';
                initial-value: 0;
                inherits: false;
            }
        `}, cM = { circle: oM, conic: iM, inset: sM, blinds: aM, wipe: lM }, uM = { opacity: 1, x: "0px", y: "0px", scale: 1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0 }; function M1(e, t, n, r) {
    var i; let o = `
      opacity: ${e.opacity};
      transform: translate(${e.x}, ${e.y}) scale(${e.scale}) rotateX(${e.rotateX}deg) rotateY(${e.rotateY}deg) rotateZ(${e.rotate}deg);
    `; return e.mask && (o += ((i = r?.makeKeyframe) === null || i === void 0 ? void 0 : i.call(r, e.mask, t, n)) || ""), o
} function fM(e) { return e ? cM[e] : void 0 } function O1(e, { transition: t, ...n }) {
    var r; let i = "view-transition-" + e, o = { duration: "0s", easing: "linear" }; if (t.type === "tween") o.duration = t.duration + "s", o.easing = `cubic-bezier(${t.ease.join(",")})`; else if (t.type === "spring") { let { easing: c, duration: u } = rM(Ds({ keyframes: [0, 1], stiffness: t.stiffness, damping: t.damping, mass: t.mass, restDelta: .001, restSpeed: 1e-4 })); o.duration = u + "ms", o.easing = c } let s = fM((r = n?.mask) === null || r === void 0 ? void 0 : r.type), a = M1(n, "start", e, s), l = M1({ ...uM, mask: n.mask }, "end", e, s); return e === "exit" && ([a, l] = [l, a]), `
        ${n.mask && s?.makePropertyRules ? s.makePropertyRules(n.mask) : ""}

        @keyframes ${i} {
            0% {
                ${a}
            }

            100% {
                ${l}
            }
        }

        ::view-transition-${e === "enter" ? "new" : "old"}(root) {
            animation-name: ${i};
            animation-duration: ${o.duration};
            animation-delay: ${t.delay}s;
            animation-timing-function: ${o.easing};
            animation-fill-mode: both;
            ${n.mask && s?.makeStyles ? s.makeStyles(n.mask, e) : ""}
        }
    `} var gk = "view-transition-styles", dM = { x: "0px", y: "0px", scale: 1, opacity: 1, rotate3d: !1, rotate: 0, rotateX: 0, rotateY: 0, mask: void 0, transition: { type: "tween", delay: 0, duration: .2, ease: [.27, 0, .51, 1], stiffness: 400, damping: 30, mass: 1 } }; function hM({ exit: e = dM, enter: t }) {
    let n = document.createElement("style"); n.id = gk; let r = `
        @media (prefers-reduced-motion) {
            ::view-transition-group(*),
            ::view-transition-old(*),
            ::view-transition-new(*) {
                animation: none !important;
            }
        }
    `; (e.mask || t.mask || e.opacity || t.opacity || e.transition.delay || t.transition.delay) && (r += `
            ::view-transition-old(*),
            ::view-transition-new(*) {
                mix-blend-mode: normal;
            }
        `), r += `
        ::view-transition-old(*),
        ::view-transition-new(*) {
            backface-visibility: hidden;
        }
    `, r += O1("exit", e), r += O1("enter", t), n.textContent = r, document.head.appendChild(n)
} function pM() { requestIdleCallback(() => { Y.render(() => { performance.mark("framer-vt-remove"); let e = document.getElementById(gk); e && document.head.removeChild(e) }) }) } var D1 = () => { }; function mM() { return !!document.startViewTransition } function gM(e) { return new Promise(t => { Y.render(() => { performance.mark("framer-vt-style"), hM(e), t() }) }) } async function A1(e, t, n) { if (!mM()) { e(); return } if (await gM(t), n?.aborted) return; performance.mark("framer-vt"); let r = document.startViewTransition(async () => { performance.mark("framer-vt-freeze"), !n?.aborted && (n?.addEventListener("abort", () => r.skipTransition()), await e()) }); return r.updateCallbackDone.then(() => { performance.mark("framer-vt-unfreeze") }).catch(D1), Promise.all([r.ready, r.finished]).then(() => { performance.mark("framer-vt-finished"), pM() }).catch(D1), r } function vk() { let e = tM(), t = A(void 0); return N(() => { t.current && (t.current(), t.current = void 0) }), se((n, r, i, o, s) => { let a = JL(n, r, e); if (a) { let l = new Promise(f => { t.current = f }), c = async () => { i(), await l }, u = async () => (await Va({ priority: "user-blocking", signal: s }, !1).catch(Iu), A1(c, a, s)); return o ? u() : A1(c, a) } else return i() }, [e]) } function yk(e, t = !1) { let n = `${e}-start`, r = `${e}-end`, i = A(void 0); return qm(() => { i.current && (i.current(), i.current = void 0) }, void 0, { priority: "user-blocking" }, t), se(() => { let o = new Promise(s => { i.current = s }); return performance.mark(n), o.finally(() => { performance.mark(r), performance.measure(e, n, r) }).catch(s => { console.error(s) }) }, [e, n, r]) } async function V1(e, t, { currentRoutePath: n, currentPathVariables: r, hash: i, pathVariables: o, localeId: s, preserveQueryParams: a }, l = !1, c = !1) { let { path: u } = t; if (u) try { let f = Xm(t, { currentRoutePath: n, currentPathVariables: r, hash: i, pathVariables: o, preserveQueryParams: a }), d = bk({ routeId: e, hash: i, pathVariables: o, localeId: s }, f, l, c); l || await d } catch { } } function vM(e) { let t = "routeId"; return Aa(e) && Zi(e[t]) } function yM(e, t, n = !1) { performance.mark("framer-history-replace"), (n ? I.history.__proto__.replaceState : I.history.replaceState).call(I.history, e, "", t) } async function bk(e, t, n = !1, r = !1) { if (n && await Va({ priority: "user-blocking" }), performance.mark("framer-history-push"), !r) { I.history.pushState(e, "", t); return } let i = !1, o = () => { i = !0 }; I.addEventListener("popstate", o, { once: !0 }), I.history.__proto__.pushState.call(I.history, e, "", t), queueMicrotask(() => { i || (I.removeEventListener("popstate", o), I.history.replaceState(e, "")) }) } function bM({ disabled: e, routeId: t, initialPathVariables: n, initialLocaleId: r }) { et(() => { e || (performance.mark("framer-history-set-initial-state"), yM({ routeId: t, pathVariables: n, localeId: r }, void 0, !0)) }, []) } function xM(e, t) { let n = vk(), r = yk("framer-route-change-popstate"), i = A(void 0), o = se(async ({ state: a }) => { var l, c, u, f, d, m; if (!((l = I.navigation) === null || l === void 0) && l.transition && ((u = (c = I.navigation) === null || c === void 0 ? void 0 : c.transition) === null || u === void 0 ? void 0 : u.navigationType) !== "traverse" || !Aa(a)) return; let { routeId: y, hash: g, pathVariables: b, localeId: h } = a; if (!Zi(y)) return; r(); let p = () => { t(y, Zi(h) ? h : void 0, Zi(g) ? g : void 0, Aa(b) ? b : void 0, !1, !0) }, v = await n(e.current, y, p, !1); v ? v.updateCallbackDone.then((f = i.current) === null || f === void 0 ? void 0 : f.resolve).catch((d = i.current) === null || d === void 0 ? void 0 : d.reject) : (m = i.current) === null || m === void 0 || m.resolve() }, [e, r, t, n]), s = se(a => { a.navigationType === "traverse" && a.intercept({ async handler() { await new Promise((l, c) => { i.current = { resolve: l, reject: c } }) }, scroll: "after-transition" }) }, []); N(() => { var a; return I.addEventListener("popstate", o), (a = I.navigation) === null || a === void 0 || a.addEventListener("navigate", s), () => { var l; I.removeEventListener("popstate", o), (l = I.navigation) === null || l === void 0 || l.removeEventListener("navigate", s) } }, [o, s]) } function wM(e, t, n) { let r = Gm(t, e); if (!r) return; let i = Object.assign({}, t?.elements, n); return r.replace(eo, (o, s) => { var a; return String((a = i[s]) !== null && a !== void 0 ? a : o) }) } function Xm(e, { currentRoutePath: t, currentPathVariables: n, hash: r, pathVariables: i, hashVariables: o, relative: s = !0, preserveQueryParams: a }) { var l; let c = t ?? "/"; n && (c = c.replace(eo, (y, g) => String(n[g] || y))); let f = (l = e?.path) !== null && l !== void 0 ? l : "/"; i && (f = f.replace(eo, (y, g) => String(i[g] || y))); let d = wM(r, e, o), m = c === f && d; return s && (f = uk(c, f)), (a || m) && (f = fk(f)), d && (f = `${f}#${d}`), f } async function SM(e, t, n) { if (!e.path || !t) return !1; let i = `${n.slug ? `/${n.slug}` : ""}${ck(e.path, t)}`; return (await fetch(i, { method: "HEAD", redirect: "manual" })).type === "opaqueredirect" ? (I.location.href = I.location.origin + i, !0) : !1 } async function kM(e) { let t = await ZL(e); if (t) { try { localStorage.setItem("preferredLocale", e.nextLocale.code) } catch { } try { if (!Zi(t.path)) throw new Error("Expected result.path to be a string"); if (t.isMissingInLocale && await SM(e.route, t.pathVariables, e.nextLocale)) return } catch { } return t } } function CM() { let e = A(Promise.resolve()), t = A(), n = se(r => { if (r.navigationType === "traverse") return; let i = t.current; i?.signal.addEventListener("abort", () => { i.abort("user aborted") }), r.intercept({ handler: () => e.current }) }, []); return se((r, i, o) => { if (!I.navigation) { i(); return } e.current = r, t.current = o, I.navigation.addEventListener("navigate", n), i(!0), r.catch(Iu).finally(() => { I.navigation.removeEventListener("navigate", n) }) }, [n]) } function Dr(e, t, n) { try { performance.measure(e, t, n) } catch (r) { console.warn(`Could not measure ${e}`, r) } } var $n = !1; function Y6() { $n = !0, performance.mark("framer-hydration-start") } var B1 = !1, z1 = !1, $1 = !1; function TM() { let e = "framer-hydration-router"; st(() => { B1 || !$n || (B1 = !0, performance.mark(`${e}-insertion-effect`)) }, []), et(() => { z1 || !$n || (z1 = !0, performance.mark(`${e}-layout-effect`)) }, []), N(() => { $1 || !$n || ($1 = !0, performance.mark(`${e}-effect`)) }, []) } var N1 = !1, H1 = !1, j1 = !1; function EM() { let e = "framer-hydration-", t = `${e}layout-effects-end`, n = `${e}effects-end`, r = `${e}browser-render-start`, i = `${e}render-end`; return st(() => { N1 || !$n || (N1 = !0, performance.mark(i), Dr(`${e}render`, `${e}start`, i), performance.mark(`${e}insertion-effects-start`)) }, []), et(() => { H1 || !$n || (H1 = !0, performance.mark(`${e}layout-effects-start`), requestAnimationFrame(() => { var o, s, a; performance.mark(r), Dr(`${e}uho`, (s = (o = performance.getEntriesByName(n)[0]) === null || o === void 0 ? void 0 : o.name) !== null && s !== void 0 ? s : (a = performance.getEntriesByName(t)[0]) === null || a === void 0 ? void 0 : a.name, r) })) }, []), N(() => { var o; if (j1 || !$n) return; j1 = !0; let s = `${e}effects-start`; performance.mark(s), ((o = performance.getEntriesByName(r)[0]) === null || o === void 0 ? void 0 : o.name) || (Dr(`${e}commit`, t, s), performance.mark(`${e}effects-sync`)) }, []), null } var W1 = !1, U1 = !1, G1 = !1, q1 = !1; function RM() { let e = "framer-hydration-", t = `${e}layout-effects-end`, n = `${e}effects-end`, r = `${e}browser-render-start`, i = `${e}start`, o = `${e}insertion-effects-end`, s = `${e}first-paint`, a = `${e}browser-raf-end`; return st(() => { W1 || !$n || (W1 = !0, performance.mark(o), Dr(`${e}insertion-effects`, `${e}insertion-effects-start`, o)) }, []), et(() => { U1 || !$n || (U1 = !0, performance.mark(t), Dr(`${e}layout-effects`, `${e}layout-effects-start`, t), requestAnimationFrame(() => { performance.mark(a), Dr(`${e}raf`, r, a) })) }, []), N(() => { var l, c, u; G1 || !$n || (G1 = !0, performance.mark(n), Dr(`${e}effects`, (c = (l = performance.getEntriesByName(s)[0]) === null || l === void 0 ? void 0 : l.name) !== null && c !== void 0 ? c : (u = performance.getEntriesByName(`${e}effects-start`)[0]) === null || u === void 0 ? void 0 : u.name, n)) }, []), qm(() => { q1 || !$n || (q1 = !0, performance.mark(s), Dr(`${e}time-to-first-paint`, i, s), Dr(`${e}browser-render`, a, s)) }, [], { priority: "user-blocking" }), null } function PM() { return EM(), null } function _M() { return RM(), null } var X1 = { Start: PM, End: _M }, Oa = ["mousedown", "mouseup", "touchcancel", "touchend", "touchstart", "auxclick", "dblclick", "pointercancel", "pointerdown", "pointerup", "dragend", "dragstart", "drop", "compositionend", "compositionstart", "keydown", "keypress", "keyup", "input", "textInput", "copy", "cut", "paste", "click", "change", "contextmenu", "reset"], xk = e => { var t, n; !((n = (t = e.target) === null || t === void 0 ? void 0 : t.closest) === null || n === void 0) && n.call(t, "#main") && (e.stopPropagation(), performance.mark("framer-react-event-handling-prevented")) }, wk = !1; function K6() { if (!Oa) return; wk = !0, performance.mark("framer-react-event-handling-start"); let e = { capture: !0 }; Oa.forEach(t => document.body.addEventListener(t, xk, e)) } function FM() { return qm(() => { if (!wk || !Oa) return; let e = { capture: !0 }; Oa.forEach(t => document.body.removeEventListener(t, xk, e)), Oa = void 0, performance.mark("framer-react-event-handling-end") }, [], { priority: "user-blocking" }), null } var Ym = !1; function Z6() { Ym = !0 } function IM() { Ym = !1 } function LM() { let e = A(typeof I > "u" || Ym); return N(() => { e.current = !1 }, []), e } function MM(e, t) { if (e.routeId !== t.routeId) return !1; if (e.pathVariables === t.pathVariables) return !0; let n = e.pathVariables || {}, r = t.pathVariables || {}; return n.length === r.length && Object.keys(n).every(i => n[i] === r[i]) } function Sk(e) { return x.useCallback(t => e[t], [e]) } var Km = (() => x.createContext({}))(); function OM({ api: e, children: t }) { return k(Km.Provider, { value: e, children: t }) } function Uu() { return x.useContext(Km) } function DM({ routes: e, children: t }) { let n = Sk(e); return k(Km.Provider, { value: { getRoute: n }, children: t }) } var AM = class extends Ee { constructor() { super(...arguments), this.state = { error: void 0 } } static getDerivedStateFromError(e) { return e instanceof xu || console.error("Derived error in SuspenseErrorBoundary", e), { error: e } } componentDidCatch(e, t) { var n; if (e instanceof xu) return; let r = t?.componentStack; if (console.error("Caught error in SuspenseErrorBoundary", e, r), typeof I < "u") { let i = e instanceof Error && typeof e.stack == "string" ? e.stack : null; (n = I.__framer_events) === null || n === void 0 || n.push(["published_site_load_recoverable_error", { message: String(e), stack: i, componentStack: i ? void 0 : r }]) } } render() { if (this.state.error === void 0) return this.props.children; if (this.state.error instanceof xu) throw this.state.error.cause; return k(ps, { children: this.props.fallbackChildren }) } }, VM = (() => typeof I < "u" ? new Promise(() => { }) : null)(); function BM() { if (typeof I > "u") return null; throw VM } function kk({ children: e }) { return k(AM, { fallbackChildren: e, children: k(ps, { fallback: k(BM, {}), children: e }) }) } var Y1 = "default"; function zM() { let [e, t] = x.useState(0); return [e, x.useCallback(() => t(n => n + 1), [])] } var $M = async () => { }, NM = { activeLocale: null, locales: [], setLocale: $M }, Ck = x.createContext(NM); function HM() { return x.useContext(Ck) } function K1(e, t, n) { let r = e && document.getElementById(e); if (r) { GM(r, t); return } n || I.scrollTo(0, 0) } function jM(e) { let t = A([]); return et(() => { var n; !((n = t.current) === null || n === void 0) && n.length && (t.current.forEach(r => r()), t.current = []) }, [e]), se(n => { t.current.push(n) }, []) } function WM(e) { let t = CM(), n = yk("framer-route-change", !0), r = A(void 0); return se(async (i, o, s = !0) => { var a; if (IM(), !e) return await o?.(), i(), n(), new Promise(m => { m() }); (a = r.current) === null || a === void 0 || a.abort(); let l = s ? new AbortController : void 0; r.current = l; let c = l?.signal, u = n(); if (!o) return r.current = void 0, i(c), u; i(c), await Va({ priority: "user-visible", signal: c }).catch(Iu), await Va({ priority: "user-visible", signal: c }).catch(Iu); let f, d = new Promise((m, y) => { f = m, c?.aborted ? y() : c?.addEventListener("abort", y) }); return t(d, o, l), u.then(() => { f() }) }, [e, n, t]) } function UM({ defaultPageStyle: e, disableHistory: t, initialPathVariables: n, initialRoute: r, notFoundPage: i, collectionUtils: o, routes: s, initialLocaleId: a, locales: l = [], preserveQueryParams: c = !1, enableAsyncURLUpdates: u = !1 }) { TM(), bM({ disabled: t, routeId: r, initialPathVariables: n, initialLocaleId: a }); let f = vk(), [d, m] = zM(), y = jM(d), g = WM(u), b = A(r), h = A(n), p = A(a), v = p.current, w = ae(() => { var W; return (W = l.find(({ id: ee }) => v ? ee === v : ee === Y1)) !== null && W !== void 0 ? W : null }, [v, l]), C = ae(() => ({ activeLocale: w, locales: l, setLocale: async W => { let ee; Zi(W) ? ee = W : Aa(W) && (ee = W.id); let te = l.find(({ id: re }) => re === Y1), q = l.find(({ id: re }) => re === ee); if (!q) return; let ne = b.current, be = s[ne]; if (be) try { let re = await kM({ currentLocale: w, nextLocale: q, route: be, routeId: ne, defaultLocale: te, pathVariables: h.current, collectionUtils: o, preserveQueryParams: c }); if (!re) return; let pe = h.current, ie = vM(I.history.state) ? I.history.state.paginationInfo : void 0, ht = re.path; h.current = re.pathVariables, p.current = q.id, g(() => { f(ne, ne, () => vr(m), u) }, async (Lt = !1) => { if (ht) return bk({ routeId: ne, pathVariables: pe, localeId: q.id, paginationInfo: ie }, ht, !1, Lt) }, !1) } catch { } } }), [w, o, u, m, l, c, s, g, f]), S = se((W, ee, te, q, ne = !1, be = !1, re) => { let pe = b.current; if (b.current = W, h.current = q, p.current = ee, y(() => { K1(te, ne, be) }), be) { vr(m); return } g(ie => { f(pe, W, () => vr(m), u, ie) }, re) }, [u, m, y, g, f]); xM(b, S); let R = se(async (W, ee, te, q) => { var ne, be; let re = s[W]; if (te) { let Se = new Set, Qt = (ne = re?.path) !== null && ne !== void 0 ? ne : "/"; for (let Pn of Qt.matchAll(eo)) { let _n = Pn[1]; if (_n === void 0) throw new Error("A matching path variable should not be undefined"); Se.add(_n) } te = Object.fromEntries(Object.entries(te).filter(([Pn]) => Se.has(Pn))) } let pe = Gm(re, ee), ie = h.current, ht = p.current; if (MM({ routeId: b.current, pathVariables: ie }, { routeId: W, pathVariables: te })) { K1(pe, q, !1); let Se = s[W]; if (((be = I.history.state) === null || be === void 0 ? void 0 : be.hash) === ee || t || !Se) return; let Qt = V1(W, Se, { currentRoutePath: Se.path, currentPathVariables: ie, pathVariables: te, hash: ee, localeId: ht, preserveQueryParams: c }, u); return u ? void 0 : await Qt } if (!re) return; let _e = s[b.current]; S(W, ht, pe, te, q, !1, t ? void 0 : async (Se = !1) => V1(W, re, { currentRoutePath: _e?.path, currentPathVariables: ie, hash: ee, pathVariables: te, localeId: ht, preserveQueryParams: c }, !1, Se)) }, [s, S, t, c, u]), E = Sk(s), L = b.current, F = h.current, z = ae(() => ({ navigate: R, getRoute: E, currentRouteId: L, currentPathVariables: F, routes: s, collectionUtils: o, preserveQueryParams: c }), [R, E, L, F, s, o, c]), D = s[b.current]; if (!D) throw new Error(`Router cannot find route for ${b.current}`); let K = !w || !D.includedLocales || D.includedLocales.includes(w.id), U = D.path && F ? ck(D.path, F) : D.path, $ = String(v) + U; return k(OM, { api: z, children: k(Ck.Provider, { value: C, children: ce(kk, { children: [k(jL, { notFoundPage: i, defaultPageStyle: e, forceUpdateKey: d, children: ce(mr, { children: [k(X1.Start, {}), K ? wm(D.page, e) : i && wm(i, e)] }, $) }), k(FM, {}), k(X1.End, {})] }) }) }) } function GM(e, t) { let n = t ? { behavior: "smooth", block: "start", inline: "nearest" } : void 0; e.scrollIntoView(n) } var fu, Jp, Q1; function qM(e) { if (Q1 !== e) { fu = {}; for (let [t, { path: n }] of Object.entries(e)) n && (fu[n] = { path: n, depth: XM(n), routeId: t }); Jp = Object.values(fu), Jp.sort(({ depth: t }, { depth: n }) => n - t), Q1 = e } return [fu, Jp] } function Tk(e, t, n = !0, r = []) { let [i, o] = qM(e), s, a, l = t; if (r.length > 0) { let d = l.split("/").find(Boolean); if (d && (s = r.find(({ slug: m }) => m === d), s && (a = s.id, l = l.substring(s.slug.length + 1))), !a) { let m = r.find(({ slug: y }) => y === ""); m && (a = m.id) } } let c = i[l]; if (c) { let d = Z1(l, c.path); if (d.isMatch) return { routeId: c.routeId, localeId: a, pathVariables: d.pathVariables } } for (let { path: d, routeId: m } of o) { let y = Z1(l, d); if (y.isMatch) return { routeId: m, localeId: a, pathVariables: y.pathVariables } } if (!n) throw new Error("No exact match found for path"); let u = i["/"]; if (u) return { routeId: u.routeId, localeId: a }; let f = Object.keys(e)[0]; if (!f) throw new Error("Router should not have undefined routes"); return { routeId: f, localeId: a } } function XM(e) { let t = e.replace(/^\/|\/$/gu, ""); return t === "" ? 0 : t.split("/").length } function Z1(e, t) { let n = [], i = YM(t).replace(eo, (c, u) => (n.push(u), "([^/]+)")), o = new RegExp(i + "$"), s = e.match(o); if (!s) return { isMatch: !1 }; if (s.length === 1) return { isMatch: !0 }; let a = {}, l = s.slice(1); for (let c = 0; c < n.length; ++c) { let u = n[c]; if (u === void 0) continue; let f = l[c], d = a[u]; if (d) { if (d !== f) return { isMatch: !1 }; continue } if (f === void 0) throw new Error("Path variable values cannot be undefined"); a[u] = f } return { isMatch: !0, pathVariables: a } } function YM(e) { return e.replace(/[|\\{}()[\]^$+*?.]/gu, "\\$&").replace(/-/gu, "\\x2d") } var KM = "page"; function J1(e) { return Aa(e) && KM in e && e.page !== void 0 } var QM = (() => x.createContext(void 0))(); function Qm() { var e; let t = Uu(), n = V(QM), r = n ?? t.currentRouteId; if (!r) return; let i = (e = t.getRoute) === null || e === void 0 ? void 0 : e.call(t, r); if (i) return { ...i, id: r, pathVariables: n ? void 0 : t.currentPathVariables } } var Zm = (() => typeof I < "u" && !YL(Ne.userAgent))(); function ZM(e, t = !0) { let { getRoute: n } = Uu(); N(() => { if (!(!n || !t || !Zm)) for (let r of e) Ek(n(r)) }, [e, n, t]) } async function Ek(e) { if (!Zm || !e) return; let t = e.page; if (!(!t || !dk(t))) { await hk(); try { await t.preload() } catch { } } } var eS = new Set; function Ba(e, ...t) { eS.has(e) || (eS.add(e), console.warn(e, ...t)) } function JM(e, t, n) { let r = n ? `, use ${n} instead` : "", i = `Deprecation warning: ${e} will be removed in version ${t}${r}.`; Ba(i) } var Rk = class { constructor() { T(this, "observers", new Set), T(this, "transactions", {}) } add(e) { this.observers.add(e); let t = !1; return () => { t || (t = !0, this.remove(e)) } } remove(e) { this.observers.delete(e) } notify(e, t) { if (t) { let n = this.transactions[t] || e; n.value = e.value, this.transactions[t] = n } else this.callObservers(e) } finishTransaction(e) { let t = this.transactions[e]; return delete this.transactions[e], this.callObservers(t, e) } callObservers(e, t) { let n = []; return new Set(this.observers).forEach(r => { typeof r == "function" ? r(e, t) : (r.update(e, t), n.push(r.finish)) }), n } }, rt = (() => { function e(t) { return JM("Animatable()", "2.0.0", "the new animation API (https://www.framer.com/api/animation/)"), Nn(t) ? t : new tO(t) } return e.transaction = t => { let n = Math.random(), r = new Set; t((s, a) => { s.set(a, n), r.add(s) }, n); let o = []; r.forEach(s => { o.push(...s.finishTransaction(n)) }), o.forEach(s => { s(n) }) }, e.getNumber = (t, n = 0) => e.get(t, n), e.get = (t, n) => t == null ? n : Nn(t) ? t.get() : t, e.objectToValues = t => { if (!t) return t; let n = {}; for (let r in t) { let i = t[r]; Nn(i) ? n[r] = i.get() : n[r] = i } return n }, e })(), tS = "onUpdate", nS = "finishTransaction"; function Nn(e) { return e !== null && typeof e == "object" && tS in e && e[tS] instanceof Function && nS in e && e[nS] instanceof Function } function eO(e, t) { return { interpolate(n, r) { let i = n.get(), o = r.get(), s = rt(i); return a => { let l = t.interpolate(i, o)(a); return s.set(l), s } }, difference(n, r) { let i = n.get(); return t.difference(i, r.get()) } } } var tO = class { constructor(e) { this.value = e, T(this, "observers", new Rk) } static interpolationFor(e, t) { if (Nn(e)) return eO(e, t) } get() { return this.value } set(e, t) { let n = this.value; Nn(e) && (e = e.get()), this.value = e; let r = { value: e, oldValue: n }; this.observers.notify(r, t) } finishTransaction(e) { return this.observers.finishTransaction(e) } onUpdate(e) { return this.observers.add(e) } }; function du(e, t) { let r = 10 ** Math.round(Math.abs(t)); return Math.round(e * r) / r } function rS(e, t) { return t === 0 ? Math.round(e) : (t -= t | 0, t < 0 && (t = 1 - t), Math.round(e - t) + t) } function fn(e, t) { return { x: e, y: t } } (e => { e.add = (...i) => i.reduce((o, s) => ({ x: o.x + s.x, y: o.y + s.y }), { x: 0, y: 0 }), e.subtract = (i, o) => ({ x: i.x - o.x, y: i.y - o.y }), e.multiply = (i, o) => ({ x: i.x * o, y: i.y * o }), e.divide = (i, o) => ({ x: i.x / o, y: i.y / o }), e.absolute = i => ({ x: Math.abs(i.x), y: Math.abs(i.y) }), e.reverse = i => ({ x: i.x * -1, y: i.y * -1 }), e.pixelAligned = (i, o = { x: 0, y: 0 }) => ({ x: rS(i.x, o.x), y: rS(i.y, o.y) }), e.distance = (i, o) => { let s = Math.abs(i.x - o.x), a = Math.abs(i.y - o.y); return Math.sqrt(s * s + a * a) }, e.angle = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI - 90, e.angleFromX = (i, o) => Math.atan2(o.y - i.y, o.x - i.x) * 180 / Math.PI, e.isEqual = (i, o) => i.x === o.x && i.y === o.y, e.rotationNormalizer = () => { let i; return o => { typeof i != "number" && (i = o); let s = i - o, a = Math.abs(s) + 180, l = Math.floor(a / 360); return s < 180 && (o -= l * 360), s > 180 && (o += l * 360), i = o, o } }; function t(i, o) { return { x: (i.x + o.x) / 2, y: (i.y + o.y) / 2 } } e.center = t; function n(i) { let o = 0, s = 0; i.forEach(c => { o += c.x, s += c.y }); let a = o / i.length, l = s / i.length; return { x: a, y: l } } e.centroid = n; function r(i) { let o = e.centroid(i), s = new Map; for (let a = 0; a < i.length; a++) { let l = i[a]; s.set(l, Math.atan2(l.x - o.x, l.y - o.y)) } return i.sort((a, l) => s.get(a) - s.get(l)) } e.sortClockwise = r })(fn || (fn = {})); var km = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }; function gi(e, t, n, r = !1) { let [i, o] = t, [s, a] = n, l = o - i; if (l === 0) return (a + s) / 2; let c = a - s; if (c === 0) return s; let u = s + (e - i) / l * c; if (r === !0) if (s < a) { if (u < s) return s; if (u > a) return a } else { if (u > s) return s; if (u < a) return a } return u } function rs(e) { return !isNaN(e) && isFinite(e) } function vi(e) { let t = Cm(e); return t !== void 0 ? e.includes("%") ? t / 100 : t : 0 } function Cm(e) { let t = /\d?\.?\d+/u.exec(e); return t ? Number(t[0]) : void 0 } var nO = (() => DL().Hsluv)(), Kt = new nO; function rO(e, t, n) { return Kt.rgb_r = e / 255, Kt.rgb_g = t / 255, Kt.rgb_b = n / 255, Kt.rgbToHsluv(), { h: Kt.hsluv_h, s: Kt.hsluv_s, l: Kt.hsluv_l } } function iO(e, t, n, r = 1) { return Kt.hsluv_h = e, Kt.hsluv_s = t, Kt.hsluv_l = n, Kt.hsluvToRgb(), { r: Kt.rgb_r * 255, g: Kt.rgb_g * 255, b: Kt.rgb_b * 255, a: r } } function hu(e, t, n, r) { let i = Math.round(e), o = Math.round(t * 100), s = Math.round(n * 100); return r === void 0 || r === 1 ? "hsv(" + i + ", " + o + "%, " + s + "%)" : "hsva(" + i + ", " + o + "%, " + s + "%, " + r + ")" } function oO(e, t, n) { return { r: rs(e) ? $t(e, 255) * 255 : 0, g: rs(t) ? $t(t, 255) * 255 : 0, b: rs(n) ? $t(n, 255) * 255 : 0 } } function iS(e, t, n, r) { let i = [tm(Math.round(e).toString(16)), tm(Math.round(t).toString(16)), tm(Math.round(n).toString(16))]; return r && i[0].charAt(0) === i[0].charAt(1) && i[1].charAt(0) === i[1].charAt(1) && i[2].charAt(0) === i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("") } function Jm(e, t, n) { let r, i, o = $t(e, 255), s = $t(t, 255), a = $t(n, 255), l = Math.max(o, s, a), c = Math.min(o, s, a), u = i = r = (l + c) / 2; if (l === c) u = i = 0; else { let f = l - c; switch (i = r > .5 ? f / (2 - l - c) : f / (l + c), l) { case o: u = (s - a) / f + (s < a ? 6 : 0); break; case s: u = (a - o) / f + 2; break; case a: u = (o - s) / f + 4; break }u /= 6 } return { h: u * 360, s: i, l: r } } function em(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function sO(e, t, n) { let r, i, o; if (e = $t(e, 360), t = $t(t * 100, 100), n = $t(n * 100, 100), t === 0) r = i = o = n; else { let s = n < .5 ? n * (1 + t) : n + t - n * t, a = 2 * n - s; r = em(a, s, e + 1 / 3), i = em(a, s, e), o = em(a, s, e - 1 / 3) } return { r: r * 255, g: i * 255, b: o * 255 } } function oS(e, t, n) { e = $t(e, 255), t = $t(t, 255), n = $t(n, 255); let r = Math.max(e, t, n), i = Math.min(e, t, n), o = r - i, s, a = r === 0 ? 0 : o / r, l = r; if (r === i) s = 0; else { switch (r) { case e: s = (t - n) / o + (t < n ? 6 : 0); break; case t: s = (n - e) / o + 2; break; case n: s = (e - t) / o + 4; break }s /= 6 } return { h: s, s: a, v: l } } function aO(e, t, n) { e = $t(e, 360) * 6, t = $t(t * 100, 100), n = $t(n * 100, 100); let r = Math.floor(e), i = e - r, o = n * (1 - t), s = n * (1 - i * t), a = n * (1 - (1 - i) * t), l = r % 6, c = [n, s, o, o, a, n][l], u = [a, n, n, s, o, o][l], f = [o, o, a, n, n, s][l]; return { r: c * 255, g: u * 255, b: f * 255 } } function $t(e, t) { let n, r; if (typeof t == "string" ? n = parseFloat(t) : n = t, typeof e == "string") { lO(e) && (e = "100%"); let i = cO(e); r = Math.min(n, Math.max(0, parseFloat(e))), i && (r = Math.floor(r * n) / 100) } else r = e; return Math.abs(r - n) < 1e-6 ? 1 : r % n / n } function lO(e) { return typeof e == "string" && e.includes(".") && parseFloat(e) === 1 } function cO(e) { return typeof e == "string" && e.includes("%") } function tm(e) { return e.length === 1 ? "0" + e : "" + e } var lr = (() => { let e = "[-\\+]?\\d+%?", n = "(?:" + "[-\\+]?\\d*\\.\\d+%?" + ")|(?:" + e + ")", r = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?", i = "[\\s|\\(]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")[,|\\s]+(" + n + ")\\s*\\)?"; return { rgb: new RegExp("rgb" + r), rgba: new RegExp("rgba" + i), hsl: new RegExp("hsl" + r), hsla: new RegExp("hsla" + i), hsv: new RegExp("hsv" + r), hsva: new RegExp("hsva" + i), hex3: /^([\da-f])([\da-f])([\da-f])$/iu, hex6: /^([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu, hex4: /^#?([\da-f])([\da-f])([\da-f])([\da-f])$/iu, hex8: /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu } })(); function eg(e) { if (e.includes("gradient(") || e.includes("var(")) return !1; let t = /^[\s,#]+/u, n = e.replace(t, "").trimEnd().toLowerCase(), r = km[n]; if (r && (n = r), n === "transparent") return { r: 0, g: 0, b: 0, a: 0, format: "name" }; let i; return (i = lr.rgb.exec(n)) ? { r: parseInt(i[1] ?? ""), g: parseInt(i[2] ?? ""), b: parseInt(i[3] ?? ""), a: 1, format: "rgb" } : (i = lr.rgba.exec(n)) ? { r: parseInt(i[1] ?? ""), g: parseInt(i[2] ?? ""), b: parseInt(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "rgb" } : (i = lr.hsl.exec(n)) ? { h: parseInt(i[1] ?? ""), s: vi(i[2] ?? ""), l: vi(i[3] ?? ""), a: 1, format: "hsl" } : (i = lr.hsla.exec(n)) ? { h: parseInt(i[1] ?? ""), s: vi(i[2] ?? ""), l: vi(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "hsl" } : (i = lr.hsv.exec(n)) ? { h: parseInt(i[1] ?? ""), s: vi(i[2] ?? ""), v: vi(i[3] ?? ""), a: 1, format: "hsv" } : (i = lr.hsva.exec(n)) ? { h: parseInt(i[1] ?? ""), s: vi(i[2] ?? ""), v: vi(i[3] ?? ""), a: parseFloat(i[4] ?? ""), format: "hsv" } : (i = lr.hex8.exec(n)) ? { r: un(i[1] ?? ""), g: un(i[2] ?? ""), b: un(i[3] ?? ""), a: sS(i[4] ?? ""), format: r ? "name" : "hex" } : (i = lr.hex6.exec(n)) ? { r: un(i[1] ?? ""), g: un(i[2] ?? ""), b: un(i[3] ?? ""), a: 1, format: r ? "name" : "hex" } : (i = lr.hex4.exec(n)) ? { r: un(`${i[1]}${i[1]}`), g: un(`${i[2]}${i[2]}`), b: un(`${i[3]}${i[3]}`), a: sS(i[4] + "" + i[4]), format: r ? "name" : "hex" } : (i = lr.hex3.exec(n)) ? { r: un(`${i[1]}${i[1]}`), g: un(`${i[2]}${i[2]}`), b: un(`${i[3]}${i[3]}`), a: 1, format: r ? "name" : "hex" } : !1 } function un(e) { return parseInt(e, 16) } function sS(e) { return un(e) / 255 } var aS = new Map, G = (() => { function e(o, s, a, l) { if (typeof o == "string") { let u = aS.get(o); return u || (u = t(o), u === void 0 ? { ...e("black"), isValid: !1 } : (aS.set(o, u), u)) } let c = t(o, s, a, l); return c !== void 0 ? c : { ...e("black"), isValid: !1 } } function t(o, s, a, l) { if (o === "") return; let c = uO(o, s, a, l); if (c) { let u = { r: c.r, g: c.g, b: c.b, a: c.a, h: c.h, s: c.s, l: c.l, initialValue: typeof o == "string" && c.format !== "hsv" ? o : void 0, roundA: Math.round(100 * c.a) / 100, format: c.format, mix: e.mix, toValue: () => e.toRgbString(u) }; return u } else return } let n = { isRGB(o) { return o === "rgb" || o === "rgba" }, isHSL(o) { return o === "hsl" || o === "hsla" } }; e.inspect = (o, s) => o.format === "hsl" ? `<${o.constructor.name} h:${o.h} s:${o.s} l:${o.l} a:${o.a}>` : o.format === "hex" || o.format === "name" ? `<${o.constructor.name} "${s}">` : `<${o.constructor.name} r:${o.r} g:${o.g} b:${o.b} a:${o.a}>`, e.isColor = o => typeof o == "string" ? e.isColorString(o) : e.isColorObject(o), e.isColorString = o => typeof o == "string" ? eg(o) !== !1 : !1, e.isColorObject = o => o && typeof o != "string" && typeof o.r == "number" && typeof o.g == "number" && typeof o.b == "number" && typeof o.h == "number" && typeof o.s == "number" && typeof o.l == "number" && typeof o.a == "number" && typeof o.roundA == "number" && typeof o.format == "string", e.toString = o => e.toRgbString(o), e.toHex = (o, s = !1) => iS(o.r, o.g, o.b, s), e.toHexString = (o, s = !1) => `#${e.toHex(o, s)}`, e.toRgbString = o => o.a === 1 ? "rgb(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ")" : "rgba(" + Math.round(o.r) + ", " + Math.round(o.g) + ", " + Math.round(o.b) + ", " + o.roundA + ")", e.toHusl = o => ({ ...rO(o.r, o.g, o.b), a: o.roundA }), e.toHslString = o => { let s = e.toHsl(o), a = Math.round(s.h), l = Math.round(s.s * 100), c = Math.round(s.l * 100); return o.a === 1 ? "hsl(" + a + ", " + l + "%, " + c + "%)" : "hsla(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")" }, e.toHsv = o => { let s = oS(o.r, o.g, o.b); return { h: s.h * 360, s: s.s, v: s.v, a: o.a } }, e.toHsvString = o => { let s = oS(o.r, o.g, o.b), a = Math.round(s.h * 360), l = Math.round(s.s * 100), c = Math.round(s.v * 100); return o.a === 1 ? "hsv(" + a + ", " + l + "%, " + c + "%)" : "hsva(" + a + ", " + l + "%, " + c + "%, " + o.roundA + ")" }, e.toName = o => { if (o.a === 0) return "transparent"; if (o.a < 1) return !1; let s = iS(o.r, o.g, o.b, !0); for (let a of Object.keys(km)) if (km[a] === s) return a; return !1 }, e.toHsl = o => ({ h: Math.round(o.h), s: o.s, l: o.l, a: o.a }), e.toRgb = o => ({ r: Math.round(o.r), g: Math.round(o.g), b: Math.round(o.b), a: o.a }), e.brighten = (o, s = 10) => { let a = e.toRgb(o); return a.r = Math.max(0, Math.min(255, a.r - Math.round(255 * -(s / 100)))), a.g = Math.max(0, Math.min(255, a.g - Math.round(255 * -(s / 100)))), a.b = Math.max(0, Math.min(255, a.b - Math.round(255 * -(s / 100)))), e(a) }, e.lighten = (o, s = 10) => { let a = e.toHsl(o); return a.l += s / 100, a.l = Math.min(1, Math.max(0, a.l)), e(a) }, e.darken = (o, s = 10) => { let a = e.toHsl(o); return a.l -= s / 100, a.l = Math.min(1, Math.max(0, a.l)), e(a) }, e.saturate = (o, s = 10) => { let a = e.toHsl(o); return a.s += s / 100, a.s = Math.min(1, Math.max(0, a.s)), e(a) }, e.desaturate = (o, s = 10) => { let a = e.toHsl(o); return a.s -= s / 100, a.s = Math.min(1, Math.max(0, a.s)), e(a) }, e.grayscale = o => e.desaturate(o, 100), e.hueRotate = (o, s) => { let a = e.toHsl(o); return a.h += s, a.h = a.h > 360 ? a.h - 360 : a.h, e(a) }, e.alpha = (o, s = 1) => e({ r: o.r, g: o.g, b: o.b, a: s }), e.transparent = o => e.alpha(o, 0), e.multiplyAlpha = (o, s = 1) => e({ r: o.r, g: o.g, b: o.b, a: o.a * s }), e.interpolate = (o, s, a = "rgb") => { if (!e.isColorObject(o) || !e.isColorObject(s)) throw new TypeError("Both arguments for Color.interpolate must be Color objects"); return l => e.mixAsColor(o, s, l, !1, a) }, e.mix = (o, s, { model: a = "rgb" } = {}) => { let l = typeof o == "string" ? e(o) : o, c = e.interpolate(l, s, a); return u => e.toRgbString(c(u)) }, e.mixAsColor = (o, s, a = .5, l = !1, c = "rgb") => { let u = null; if (n.isRGB(c)) u = e({ r: gi(a, [0, 1], [o.r, s.r], l), g: gi(a, [0, 1], [o.g, s.g], l), b: gi(a, [0, 1], [o.b, s.b], l), a: gi(a, [0, 1], [o.a, s.a], l) }); else { let f, d; n.isHSL(c) ? (f = e.toHsl(o), d = e.toHsl(s)) : (f = e.toHusl(o), d = e.toHusl(s)), f.s === 0 ? f.h = d.h : d.s === 0 && (d.h = f.h); let m = f.h, y = d.h, g = y - m; g > 180 ? g = y - 360 - m : g < -180 && (g = y + 360 - m); let b = { h: gi(a, [0, 1], [m, m + g], l), s: gi(a, [0, 1], [f.s, d.s], l), l: gi(a, [0, 1], [f.l, d.l], l), a: gi(a, [0, 1], [o.a, s.a], l) }; n.isHSL(c) ? u = e(b) : u = e(iO(b.h, b.s, b.l, b.a)) } return u }, e.random = (o = 1) => { function s() { return Math.floor(Math.random() * 255) } return e("rgba(" + s() + ", " + s() + ", " + s() + ", " + o + ")") }, e.grey = (o = .5, s = 1) => (o = Math.floor(o * 255), e("rgba(" + o + ", " + o + ", " + o + ", " + s + ")")), e.gray = e.grey, e.rgbToHsl = (o, s, a) => Jm(o, s, a), e.isValidColorProperty = (o, s) => !!((o.toLowerCase().slice(-5) === "color" || o === "fill" || o === "stroke") && typeof s == "string" && e.isColorString(s)), e.difference = (o, s) => { let a = (o.r + s.r) / 2, l = o.r - s.r, c = o.g - s.g, u = o.b - s.b, f = Math.pow(l, 2), d = Math.pow(c, 2), m = Math.pow(u, 2); return Math.sqrt(2 * f + 4 * d + 3 * m + a * (f - m) / 256) }, e.equal = (o, s, a = .1) => !(Math.abs(o.r - s.r) >= a || Math.abs(o.g - s.g) >= a || Math.abs(o.b - s.b) >= a || Math.abs(o.a - s.a) * 256 >= a); let r = xo([0, 255], [0, 1]); function i(o) { o = r(o); let s = Math.abs(o); return s < .04045 ? o / 12.92 : (Math.sign(o) || 1) * Math.pow((s + .055) / 1.055, 2.4) } return e.luminance = o => { let { r: s, g: a, b: l } = e.toRgb(o); return .2126 * i(s) + .7152 * i(a) + .0722 * i(l) }, e.contrast = (o, s) => { let a = e.luminance(o), l = e.luminance(s); return (Math.max(a, l) + .05) / (Math.min(a, l) + .05) }, e })(); function uO(e, t, n, r = 1) { let i; return typeof e == "number" && !Number.isNaN(e) && typeof t == "number" && !Number.isNaN(t) && typeof n == "number" && !Number.isNaN(n) ? i = Tm({ r: e, g: t, b: n, a: r }) : typeof e == "string" ? i = fO(e) : typeof e == "object" && (e.hasOwnProperty("r") && e.hasOwnProperty("g") && e.hasOwnProperty("b") ? i = Tm(e) : i = Pk(e)), i } function fO(e) { let t = eg(e); if (t) return t.format === "hsl" ? Pk(t) : t.format === "hsv" ? dO(t) : Tm(t) } function dO(e) { let t = aO(e.h, e.s, e.v); return { ...Jm(t.r, t.g, t.b), ...t, format: "rgb", a: e.a !== void 0 ? _k(e.a) : 1 } } function Tm(e) { let t = oO(e.r, e.g, e.b); return { ...Jm(t.r, t.g, t.b), ...t, format: "rgb", a: e.a !== void 0 ? _k(e.a) : 1 } } function Pk(e) { let t, n, r, i = { r: 0, g: 0, b: 0 }, o = { h: 0, s: 0, l: 0 }; return t = rs(e.h) ? e.h : 0, t = (t + 360) % 360, n = rs(e.s) ? e.s : 1, typeof e.s == "string" && (n = Cm(e.s)), r = rs(e.l) ? e.l : .5, typeof e.l == "string" && (r = Cm(e.l)), i = sO(t, n, r), o = { h: t, s: n, l: r }, { ...i, ...o, a: e.a === void 0 ? 1 : e.a, format: "hsl" } } function _k(e) { return e = parseFloat(e), e < 0 && (e = 0), (isNaN(e) || e > 1) && (e = 1), e } var lS = e => e instanceof As; var hO = (() => AL().EventEmitter)(), pO = class { constructor() { T(this, "_emitter", new hO) } eventNames() { return this._emitter.eventNames() } eventListeners() { let e = {}; for (let t of this._emitter.eventNames()) e[t] = this._emitter.listeners(t); return e } on(e, t) { this.addEventListener(e, t, !1, !1, this) } off(e, t) { this.removeEventListeners(e, t) } once(e, t) { this.addEventListener(e, t, !0, !1, this) } unique(e, t) { this.addEventListener(e, t, !1, !0, this) } addEventListener(e, t, n, r, i) { if (r) { for (let o of this._emitter.eventNames()) if (t === this._emitter.listeners(o)) return } n === !0 ? this._emitter.once(e, t, i) : this._emitter.addListener(e, t, i) } removeEventListeners(e, t) { e ? this._emitter.removeListener(e, t) : this.removeAllEventListeners() } removeAllEventListeners() { this._emitter.removeAllListeners() } countEventListeners(e, t) { if (e) return this._emitter.listeners(e).length; { let n = 0; for (let r of this._emitter.eventNames()) n += this._emitter.listeners(r).length; return n } } emit(e, ...t) { this._emitter.emit(e, ...t) } }, mO = { addEventListener: () => { }, removeEventListener: () => { }, dispatchEvent: () => !1, ResizeObserver: void 0, onpointerdown: !1, onpointermove: !1, onpointerup: !1, ontouchstart: !1, ontouchmove: !1, ontouchend: !1, onmousedown: !1, onmousemove: !1, onmouseup: !1, devicePixelRatio: 1, scrollX: 0, scrollY: 0, location: { href: "" }, document: { cookie: "" }, setTimeout: () => 0, clearTimeout: () => { }, setInterval: () => 0, clearInterval: () => { }, requestAnimationFrame: () => 0, cancelAnimationFrame: () => { }, getSelection: () => null, matchMedia: e => ({ matches: !1, media: e, onchange: () => { }, addEventListener: () => { }, removeEventListener: () => { }, addListener: () => { }, removeListener: () => { }, dispatchEvent: () => !1 }), innerHeight: 0, innerWidth: 0, SVGSVGElement: {}, open: function (e, t, n) { } }, ft = typeof I > "u" ? mO : I, gO = e => { setTimeout(e, 1 / 60) }, vO = (() => ft.requestAnimationFrame || gO)(), cS = e => vO(e), _a = (() => 1 / 60)(), yO = class extends pO { constructor(e = !1) { super(), T(this, "_started", !1), T(this, "_frame", 0), T(this, "_frameTasks", []), T(this, "tick", () => { this._started && (cS(this.tick), this.emit("update", this._frame, _a), this.emit("render", this._frame, _a), this._processFrameTasks(), this._frame++) }), e && this.start() } addFrameTask(e) { this._frameTasks.push(e) } _processFrameTasks() { var e; let t = this._frameTasks, n = t.length; if (n !== 0) { for (let r = 0; r < n; r++)(e = t[r]) == null || e.call(t); t.length = 0 } } static set TimeStep(e) { _a = e } static get TimeStep() { return _a } start() { return this._started ? this : (this._frame = 0, this._started = !0, cS(this.tick), this) } stop() { return this._started = !1, this } get frame() { return this._frame } get time() { return this._frame * _a } }, Fk = new yO, Lu = { target: "PREVIEW", zoom: 1 }; var le = { canvas: "CANVAS", export: "EXPORT", thumbnail: "THUMBNAIL", preview: "PREVIEW", current: () => Lu.target, hasRestrictions: () => { let e = Lu.target; return e === "CANVAS" || e === "EXPORT" } }; var pu = e => ({ correct: (t, { delta: n, treeScale: r }) => { if (typeof t == "string" && (t = parseFloat(t)), t === 0) return "0px"; let i = t; return n && r && (i = Math.round(t / n[e].scale / r[e]), i = Math.max(i, 1)), i + "px" } }); Yf({ borderTopWidth: pu("y"), borderLeftWidth: pu("x"), borderRightWidth: pu("x"), borderBottomWidth: pu("y") }); function H(e, ...t) {
    var n, r; if (e) return; let i = Error("Assertion Error" + (t.length > 0 ? ": " + t.join(" ") : "")); if (i.stack) try {
        let o = i.stack.split(`
`); (n = o[1]) != null && n.includes("assert") ? (o.splice(1, 1), i.stack = o.join(`
`)) : (r = o[0]) != null && r.includes("assert") && (o.splice(0, 1), i.stack = o.join(`
`))
    } catch { } throw i
} function xe(e, t) { throw t || new Error(e ? `Unexpected value: ${e}` : "Application entered invalid state") } var is = x.createContext({ getLayoutId: e => null, persistLayoutIdCache: () => { }, top: !1, enabled: !0 }); function bO({ children: e }) { if (V(is).top) return k(He, { children: e }); let n = A({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {}, count: { byId: {}, byName: {} } }), r = A({ byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {} }), i = A(new Set).current, o = se(({ id: l, name: c, duplicatedFrom: u }) => { if (!l) return null; let f = c ? "byName" : "byId", d = n.current[f][l]; if (d) return d; let m = c || l; if (!u && !i.has(m) && (!n.current.byLayoutId[m] || n.current.byLayoutId[m] === m)) return n.current.count[f][m] === void 0 && (n.current.count[f][m] = 0, n.current.byLayoutId[m] = m, r.current[f][l] = m), i.add(m), m; let y; if (u?.length) for (let S = u.length - 1; S >= 0; S--) { let R = u[S]; H(!!R, "duplicatedId must be defined"); let E = n.current[f][R], L = n.current.byLastId[R]; if (L && !y) { let D = n.current.byLayoutId[L], K = !D || D === c; L && !i.has(L) && (!c || K) && (y = [L, R]) } let F = E ? n.current.byLayoutId[E] : void 0, z = !F || F === c; if (E && !i.has(E) && (!c || z)) return r.current[f][l] = E, r.current.byLastId[R] = E, i.add(E), E } let g = n.current.byLastId[l]; if (g && !i.has(g)) return i.add(g), r.current.byId[l] = g, g; if (y) { let [S, R] = y; return r.current[f][l] = S, r.current.byLastId[R] = S, i.add(S), S } let b = n.current.byPossibleId[l]; if (b && !i.has(b)) return i.add(b), r.current.byId[l] = b, b; let h = u?.[0], p = c || h || l, v = (n.current.count[f][p] ?? -1) + 1, { layoutId: w, value: C } = xO(p, v, i); if (n.current.count[f][p] = C, r.current[f][l] = w, u?.length && !c) { let S = u[u.length - 1]; if (S && (r.current.byLastId[S] = w), u.length > 1) for (let R = 0; R < u.length - 1; R++) { let E = u[R]; E !== void 0 && (r.current.byPossibleId[E] || (r.current.byPossibleId[E] = w)) } } return r.current.byLayoutId[w] = m, i.add(w), w }, []), s = se(() => { n.current = { byId: { ...n.current.byId, ...r.current.byId }, byLastId: { ...n.current.byLastId, ...r.current.byLastId }, byPossibleId: { ...n.current.byPossibleId, ...r.current.byPossibleId }, byName: { ...n.current.byName, ...r.current.byName }, byLastName: { ...n.current.byLastName, ...r.current.byLastName }, byLayoutId: { ...n.current.byLayoutId, ...r.current.byLayoutId }, count: { ...n.current.count, byName: {} } }, r.current = { byId: {}, byName: {}, byLastId: {}, byPossibleId: {}, byLastName: {}, byLayoutId: {} }, i.clear() }, []), a = A({ getLayoutId: o, persistLayoutIdCache: s, top: !0, enabled: !0 }).current; return k(is.Provider, { value: a, children: e }) } function xO(e, t, n) { let r = t, i = r ? `${e}-${r}` : e; for (; n.has(i);)r++, i = `${e}-${r}`; return { layoutId: i, value: r } } function wO({ enabled: e = !0, ...t }) { let n = V(is), r = ae(() => ({ ...n, enabled: e }), [e]); return k(is.Provider, { ...t, value: r }) } function Rn(e) { let t = A(null); return t.current === null && (t.current = e()), t.current } var SO = { background: void 0, display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", lineHeight: "1.4em", textOverflow: "ellipsis", overflow: "hidden", minHeight: 0, width: "100%", height: "100%" }, kO = (() => ({ ...SO, border: "1px solid rgba(149, 149, 149, 0.15)", borderRadius: 6, fontSize: "12px", backgroundColor: "rgba(149, 149, 149, 0.1)", color: "#a5a5a5" }))(), Ik = { overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis", maxWidth: "100%", flexShrink: 0, padding: "0 10px" }, CO = (() => ({ ...Ik, fontWeight: 500 }))(), TO = (() => ({ ...Ik, whiteSpace: "pre", maxHeight: "calc(50% - calc(20px * var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)))", WebkitMaskImage: "linear-gradient(to bottom, black 80%, transparent 100%)" }))(); function wH(e) { let { error: t, file: n } = e, r = n ? `Error in ${EO(n)}` : "Error", i = t instanceof Error ? t.message : "" + t; return ce("div", { style: kO, children: [k("div", { className: "text", style: CO, children: r }), i && k("div", { className: "text", style: TO, children: i })] }) } function EO(e) { return e.startsWith("./") ? e.replace("./", "") : e } function J(e) { return typeof e == "number" && isFinite(e) } function RO(e) { return !e || !Object.keys(e).length && e.constructor === Object } function wu(e) { return typeof e != "string" && typeof e != "number" } function Su(e) { return e !== null && typeof e < "u" && typeof e != "boolean" && !RO(e) } function PO(e) { return e * (Math.PI / 180) } var Tn = (() => { function e(t, n) { return { a: t, b: n } } return e.offset = (t, n) => { let r = fn.angleFromX(t.a, t.b), i = PO(r), o = n * Math.sin(i), s = n * Math.cos(i); return e({ x: t.a.x + o, y: t.a.y - s }, { x: t.b.x + o, y: t.b.y - s }) }, e.intersection = (t, n, r) => { let i = t.a.x, o = t.a.y, s = t.b.x, a = t.b.y, l = n.a.x, c = n.a.y, u = n.b.x, f = n.b.y, d = (u - l) * (c - o) - (f - c) * (l - i), m = (u - l) * (a - o) - (f - c) * (s - i), y = (s - i) * (c - o) - (a - o) * (l - i); if (d === 0 && m === 0 || m === 0) return null; let g = d / m, b = y / m; return r && (g < 0 || g > 1 || b < 0 || b > 1) ? null : { x: i + g * (s - i), y: o + g * (a - o) } }, e.intersectionAngle = (t, n) => { let r = t.b.x - t.a.x, i = t.b.y - t.a.y, o = n.b.x - n.a.x, s = n.b.y - n.a.y; return Math.atan2(r * s - i * o, r * o + i * s) * (180 / Math.PI) }, e.isOrthogonal = t => t.a.x === t.b.x || t.a.y === t.b.y, e.perpendicular = (t, n) => { let r = t.a.x - t.b.x, i = t.a.y - t.b.y, o = fn(n.x - i, n.y + r); return e(o, n) }, e.projectPoint = (t, n) => { let r = e.perpendicular(t, n); return e.intersection(t, r) }, e.pointAtPercentDistance = (t, n) => { let r = e.distance(t), i = n * r / r; return { x: i * t.b.x + (1 - i) * t.a.x, y: i * t.b.y + (1 - i) * t.a.y } }, e.distance = t => fn.distance(t.a, t.b), e })(), Z = { equals: function (e, t) { return e === t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height }, atOrigin: e => ({ ...e, x: 0, y: 0 }), fromTwoPoints: (e, t) => ({ x: Math.min(e.x, t.x), y: Math.min(e.y, t.y), width: Math.abs(e.x - t.x), height: Math.abs(e.y - t.y) }), fromRect: e => ({ x: e.left, y: e.top, width: e.right - e.left, height: e.bottom - e.top }), multiply: (e, t) => ({ x: e.x * t, y: e.y * t, width: e.width * t, height: e.height * t }), divide: (e, t) => Z.multiply(e, 1 / t), offset: (e, t) => { let n = typeof t.x == "number" ? t.x : 0, r = typeof t.y == "number" ? t.y : 0; return { ...e, x: e.x + n, y: e.y + r } }, inflate: (e, t) => { if (t === 0) return e; let n = 2 * t; return { x: e.x - t, y: e.y - t, width: e.width + n, height: e.height + n } }, pixelAligned: e => { let t = Math.round(e.x), n = Math.round(e.y), r = Math.round(e.x + e.width), i = Math.round(e.y + e.height), o = Math.max(r - t, 0), s = Math.max(i - n, 0); return { x: t, y: n, width: o, height: s } }, halfPixelAligned: e => { let t = Math.round(e.x * 2) / 2, n = Math.round(e.y * 2) / 2, r = Math.round((e.x + e.width) * 2) / 2, i = Math.round((e.y + e.height) * 2) / 2, o = Math.max(r - t, 1), s = Math.max(i - n, 1); return { x: t, y: n, width: o, height: s } }, round: (e, t = 0) => { let n = du(e.x, t), r = du(e.y, t), i = du(e.width, t), o = du(e.height, t); return { x: n, y: r, width: i, height: o } }, roundToOutside: e => { let t = Math.floor(e.x), n = Math.floor(e.y), r = Math.ceil(e.x + e.width), i = Math.ceil(e.y + e.height), o = Math.max(r - t, 0), s = Math.max(i - n, 0); return { x: t, y: n, width: o, height: s } }, minX: e => e.x, maxX: e => e.x + e.width, minY: e => e.y, maxY: e => e.y + e.height, positions: e => ({ minX: e.x, midX: e.x + e.width / 2, maxX: Z.maxX(e), minY: e.y, midY: e.y + e.height / 2, maxY: Z.maxY(e) }), center: e => ({ x: e.x + e.width / 2, y: e.y + e.height / 2 }), boundingRectFromPoints: e => { let t = 1 / 0, n = -1 / 0, r = 1 / 0, i = -1 / 0; for (let o = 0; o < e.length; o++) { let s = e[o]; t = Math.min(t, s.x), n = Math.max(n, s.x), r = Math.min(r, s.y), i = Math.max(i, s.y) } return { x: t, y: r, width: n - t, height: i - r } }, fromPoints: e => { let [t, n, r, i] = e, { x: o, y: s } = t, a = fn.distance(t, n), l = fn.distance(t, i); return { x: o, y: s, width: a, height: l } }, merge: (...e) => { let t = { x: Math.min(...e.map(Z.minX)), y: Math.min(...e.map(Z.minY)) }, n = { x: Math.max(...e.map(Z.maxX)), y: Math.max(...e.map(Z.maxY)) }; return Z.fromTwoPoints(t, n) }, intersection: (e, t) => { let n = Math.max(e.x, t.x), r = Math.min(e.x + e.width, t.x + t.width), i = Math.max(e.y, t.y), o = Math.min(e.y + e.height, t.y + t.height); return { x: n, y: i, width: r - n, height: o - i } }, points: e => [{ x: Z.minX(e), y: Z.minY(e) }, { x: Z.minX(e), y: Z.maxY(e) }, { x: Z.maxX(e), y: Z.minY(e) }, { x: Z.maxX(e), y: Z.maxY(e) }], pointsAtOrigin: e => [{ x: 0, y: 0 }, { x: e.width, y: 0 }, { x: e.width, y: e.height }, { x: 0, y: e.height }], transform: (e, t) => { let { x: n, y: r } = t.transformPoint({ x: e.x, y: e.y }), { x: i, y: o } = t.transformPoint({ x: e.x + e.width, y: e.y }), { x: s, y: a } = t.transformPoint({ x: e.x + e.width, y: e.y + e.height }), { x: l, y: c } = t.transformPoint({ x: e.x, y: e.y + e.height }), u = Math.min(n, i, s, l), f = Math.max(n, i, s, l) - u, d = Math.min(r, o, a, c), m = Math.max(r, o, a, c) - d; return { x: u, y: d, width: f, height: m } }, containsPoint: (e, t) => !(t.x < Z.minX(e) || t.x > Z.maxX(e) || t.y < Z.minY(e) || t.y > Z.maxY(e) || isNaN(e.x) || isNaN(e.y)), containsRect: (e, t) => { for (let n of Z.points(t)) if (!Z.containsPoint(e, n)) return !1; return !0 }, toCSS: e => ({ display: "block", transform: `translate(${e.x}px, ${e.y}px)`, width: `${e.width}px`, height: `${e.height}px` }), inset: (e, t) => ({ x: e.x + t, y: e.y + t, width: Math.max(0, e.width - 2 * t), height: Math.max(0, e.height - 2 * t) }), intersects: (e, t) => !(t.x >= Z.maxX(e) || Z.maxX(t) <= e.x || t.y >= Z.maxY(e) || Z.maxY(t) <= e.y), overlapHorizontally: (e, t) => { let n = Z.maxX(e), r = Z.maxX(t); return n > t.x && r > e.x }, overlapVertically: (e, t) => { let n = Z.maxY(e), r = Z.maxY(t); return n > t.y && r > e.y }, doesNotIntersect: (e, t) => t.find(n => Z.intersects(n, e)) === void 0, isEqual: (e, t) => Z.equals(e, t), cornerPoints: e => { let t = e.x, n = e.x + e.width, r = e.y, i = e.y + e.height; return [{ x: t, y: r }, { x: n, y: r }, { x: n, y: i }, { x: t, y: i }] }, midPoints: e => { let t = e.x, n = e.x + e.width / 2, r = e.x + e.width, i = e.y, o = e.y + e.height / 2, s = e.y + e.height; return [{ x: n, y: i }, { x: r, y: o }, { x: n, y: s }, { x: t, y: o }] }, pointDistance: (e, t) => { let n = 0, r = 0; return t.x < e.x ? n = e.x - t.x : t.x > Z.maxX(e) && (n = t.x - Z.maxX(e)), t.y < e.y ? r = e.y - t.y : t.y > Z.maxY(e) && (r = t.y - Z.maxY(e)), fn.distance({ x: n, y: r }, { x: 0, y: 0 }) }, fromAny: (e, t = { x: 0, y: 0, width: 0, height: 0 }) => ({ x: e.x || t.x, y: e.y || t.y, width: e.width || t.width, height: e.height || t.height }), delta: (e, t) => { let n = { x: Z.minX(e), y: Z.minY(e) }, r = { x: Z.minX(t), y: Z.minY(t) }; return { x: n.x - r.x, y: n.y - r.y } }, withMinSize: (e, t) => { let { width: n, height: r } = t, i = e.width - n, o = e.height - r; return { width: Math.max(e.width, n), height: Math.max(e.height, r), x: e.width < n ? e.x + i / 2 : e.x, y: e.height < r ? e.y + o / 2 : e.y } }, anyPointsOutsideRect: (e, t) => { let n = Z.minX(e), r = Z.minY(e), i = Z.maxX(e), o = Z.maxY(e); for (let s of t) if (s.x < n || s.x > i || s.y < r || s.y > o) return !0; return !1 }, edges: e => { let [t, n, r, i] = Z.cornerPoints(e); return [Tn(t, n), Tn(n, r), Tn(r, i), Tn(i, t)] }, rebaseRectOnto: (e, t, n, r) => { let i = { ...e }; switch (n) { case "bottom": case "top": switch (r) { case "start": i.x = t.x; break; case "center": i.x = t.x + t.width / 2 - e.width / 2; break; case "end": i.x = t.x + t.width - e.width; break; default: xe(r) }break; case "left": i.x = t.x - e.width; break; case "right": i.x = t.x + t.width; break; default: xe(n) }switch (n) { case "left": case "right": switch (r) { case "start": i.y = t.y; break; case "center": i.y = t.y + t.height / 2 - e.height / 2; break; case "end": i.y = t.y + t.height - e.height; break; default: xe(r) }break; case "top": i.y = t.y - e.height; break; case "bottom": i.y = t.y + t.height; break; default: xe(n) }return i } }; var Lk = { quickfix: e => ((e.widthType === 2 || e.heightType === 2) && (e.aspectRatio = null), J(e.aspectRatio) && (e.left && e.right && (e.widthType = 0), e.top && e.bottom && (e.heightType = 0), e.left && e.right && e.top && e.bottom && (e.bottom = !1), e.widthType !== 0 && e.heightType !== 0 && (e.heightType = 0)), e.left && e.right && ((e.fixedSize || e.widthType === 2 || J(e.maxWidth)) && (e.right = !1), e.widthType = 0), e.top && e.bottom && ((e.fixedSize || e.heightType === 2 || J(e.maxHeight)) && (e.bottom = !1), e.heightType = 0), e) }; function Mu(e) { if (typeof e == "string") { let t = e.trim(); if (t === "auto") return 2; if (t.endsWith("fr")) return 3; if (t.endsWith("%")) return 1; if (t.endsWith("vw") || t.endsWith("vh")) return 4 } return 0 } var Mk = { fromProperties: e => { let { left: t, right: n, top: r, bottom: i, width: o, height: s, centerX: a, centerY: l, aspectRatio: c, autoSize: u } = e, f = Lk.quickfix({ left: J(t) || Nn(t), right: J(n) || Nn(n), top: J(r) || Nn(r), bottom: J(i) || Nn(i), widthType: Mu(o), heightType: Mu(s), aspectRatio: c || null, fixedSize: u === !0 }), d = null, m = null, y = 0, g = 0; if (f.widthType !== 0 && typeof o == "string") { let p = parseFloat(o); o.endsWith("fr") ? (y = 3, d = p) : o === "auto" ? y = 2 : (y = 1, d = p / 100) } else o !== void 0 && typeof o != "string" && (d = rt.getNumber(o)); if (f.heightType !== 0 && typeof s == "string") { let p = parseFloat(s); s.endsWith("fr") ? (g = 3, m = p) : s === "auto" ? g = 2 : (g = 1, m = parseFloat(s) / 100) } else s !== void 0 && typeof s != "string" && (m = rt.getNumber(s)); let b = .5, h = .5; return a && (b = parseFloat(a) / 100), l && (h = parseFloat(l) / 100), { left: f.left ? rt.getNumber(t) : null, right: f.right ? rt.getNumber(n) : null, top: f.top ? rt.getNumber(r) : null, bottom: f.bottom ? rt.getNumber(i) : null, widthType: y, heightType: g, width: d, height: m, aspectRatio: f.aspectRatio || null, centerAnchorX: b, centerAnchorY: h } }, toSize: (e, t, n, r) => { let i = null, o = null, s = t?.sizing ? rt.getNumber(t?.sizing.width) : null, a = t?.sizing ? rt.getNumber(t?.sizing.height) : null, l = uS(e.left, e.right); if (s && J(l)) i = s - l; else if (n && e.widthType === 2) i = n.width; else if (J(e.width)) switch (e.widthType) { case 0: i = e.width; break; case 3: i = r ? r.freeSpaceInParent.width / r.freeSpaceUnitDivisor.width * e.width : null; break; case 1: case 4: s && (i = s * e.width); break; case 2: break; default: xe(e.widthType) }let c = uS(e.top, e.bottom); if (a && J(c)) o = a - c; else if (n && e.heightType === 2) o = n.height; else if (J(e.height)) switch (e.heightType) { case 0: o = e.height; break; case 3: o = r ? r.freeSpaceInParent.height / r.freeSpaceUnitDivisor.height * e.height : null; break; case 1: case 4: a && (o = a * e.height); break; case 2: break; default: xe(e.heightType) }return MO(i, o, e, { height: a ?? 0, width: s ?? 0 }, t?.viewport) }, toRect: (e, t = null, n = null, r = !1, i = null) => { let o = e.left || 0, s = e.top || 0, { width: a, height: l } = Mk.toSize(e, t, n, i), c = t?.positioning ?? null, u = c ? rt.getNumber(c.width) : null, f = c ? rt.getNumber(c.height) : null; e.left !== null ? o = e.left : u && e.right !== null ? o = u - e.right - a : u && (o = e.centerAnchorX * u - a / 2), e.top !== null ? s = e.top : f && e.bottom !== null ? s = f - e.bottom - l : f && (s = e.centerAnchorY * f - l / 2); let d = { x: o, y: s, width: a, height: l }; return r ? Z.pixelAligned(d) : d } }, _O = 200, FO = 200; function Ou(e, t, n, r) { if (typeof t == "string") { if (t.endsWith("%") && n) switch (e) { case "maxWidth": case "minWidth": return parseFloat(t) / 100 * n.width; case "maxHeight": case "minHeight": return parseFloat(t) / 100 * n.height; default: break }if (t.endsWith("vh") && r) switch (e) { case "maxWidth": case "minWidth": return parseFloat(t) / 100 * r.width; case "maxHeight": case "minHeight": return parseFloat(t) / 100 * r.height; default: break }return parseFloat(t) } return t } function IO(e, t, n, r) { return t.minHeight && (e = Math.max(Ou("minHeight", t.minHeight, n, r), e)), t.maxHeight && (e = Math.min(Ou("maxHeight", t.maxHeight, n, r), e)), e } function LO(e, t, n, r) { return t.minWidth && (e = Math.max(Ou("minWidth", t.minWidth, n, r), e)), t.maxWidth && (e = Math.min(Ou("maxWidth", t.maxWidth, n, r), e)), e } function MO(e, t, n, r, i) { let o = LO(J(e) ? e : _O, n, r, i), s = IO(J(t) ? t : FO, n, r, i); return J(n.aspectRatio) && n.aspectRatio > 0 && (J(n.left) && J(n.right) ? s = o / n.aspectRatio : J(n.top) && J(n.bottom) ? o = s * n.aspectRatio : n.widthType !== 0 ? s = o / n.aspectRatio : o = s * n.aspectRatio), { width: o, height: s } } function uS(e, t) { return !J(e) || !J(t) ? null : e + t } function OO(e) { return typeof e.right == "string" || typeof e.bottom == "string" || typeof e.left == "string" && (!e.center || e.center === "y") || typeof e.top == "string" && (!e.center || e.center === "x") } function Ka(e) { return !e._constraints || OO(e) ? !1 : e._constraints.enabled } function DO(e) { let { size: t } = e, { width: n, height: r } = e; return J(t) && (n === void 0 && (n = t), r === void 0 && (r = t)), J(n) && J(r) ? { width: n, height: r } : null } function AO(e) { let t = DO(e); if (t === null) return null; let { left: n, top: r } = e; return J(n) && J(r) ? { x: n, y: r, ...t } : null } function za(e, t, n = !0) { if (e.positionFixed || e.positionAbsolute) return null; let r = t === 1 || t === 2; if (!Ka(e) || r) return AO(e); let i = VO(e), o = BO(t), s = o ? { sizing: o, positioning: o, viewport: null } : null; return Mk.toRect(i, s, null, n, null) } function VO(e) { let { left: t, right: n, top: r, bottom: i, center: o, _constraints: s, size: a } = e, { width: l, height: c } = e; l === void 0 && (l = a), c === void 0 && (c = a); let { aspectRatio: u, autoSize: f } = s, d = Lk.quickfix({ left: J(t), right: J(n), top: J(r), bottom: J(i), widthType: Mu(l), heightType: Mu(c), aspectRatio: u || null, fixedSize: f === !0 }), m = null, y = null, g = 0, b = 0; if (d.widthType !== 0 && typeof l == "string") { let v = parseFloat(l); l.endsWith("fr") ? (g = 3, m = v) : l === "auto" ? g = 2 : (g = 1, m = v / 100) } else l !== void 0 && typeof l != "string" && (m = l); if (d.heightType !== 0 && typeof c == "string") { let v = parseFloat(c); c.endsWith("fr") ? (b = 3, y = v) : c === "auto" ? b = 2 : (b = 1, y = parseFloat(c) / 100) } else c !== void 0 && typeof c != "string" && (y = c); let h = .5, p = .5; return (o === !0 || o === "x") && (d.left = !1, typeof t == "string" && (h = parseFloat(t) / 100)), (o === !0 || o === "y") && (d.top = !1, typeof r == "string" && (p = parseFloat(r) / 100)), { left: d.left ? t : null, right: d.right ? n : null, top: d.top ? r : null, bottom: d.bottom ? i : null, widthType: g, heightType: b, width: m, height: y, aspectRatio: d.aspectRatio || null, centerAnchorX: h, centerAnchorY: p, minHeight: e.minHeight, maxHeight: e.maxHeight, minWidth: e.minWidth, maxWidth: e.maxWidth } } var Ok = x.createContext({ parentSize: 0 }); function BO(e) { return e === 0 || e === 1 || e === 2 ? null : e } function Qa() { return x.useContext(Ok).parentSize } function Dk(e) { return typeof e == "object" } var zO = e => { let t = Qa(), { parentSize: n, children: r } = e, i = x.useMemo(() => ({ parentSize: n }), [$O(n), NO(n)]); return t === 1 ? r ? k(He, { children: r }) : null : k(Ok.Provider, { value: i, children: r }) }; function $O(e) { return Dk(e) ? e.width : e } function NO(e) { return Dk(e) ? e.height : e } function HO(e, t) { return k(zO, { parentSize: t, children: e }) } function jO(e) { let t = Qa(); return za(e, t, !0) } function Ak({ width: e, height: t }) { return e === "auto" || e === "min-content" || t === "auto" || t === "min-content" } var WO = (e => (e.Boolean = "boolean", e.Number = "number", e.String = "string", e.RichText = "richtext", e.FusedNumber = "fusednumber", e.Enum = "enum", e.SegmentedEnum = "segmentedenum", e.Color = "color", e.Image = "image", e.ResponsiveImage = "responsiveimage", e.File = "file", e.ComponentInstance = "componentinstance", e.Array = "array", e.EventHandler = "eventhandler", e.Transition = "transition", e.BoxShadow = "boxshadow", e.Link = "link", e.Date = "date", e.Object = "object", e.Font = "font", e.PageScope = "pagescope", e.ScrollSectionRef = "scrollsectionref", e.CustomCursor = "customcursor", e.Border = "border", e.Cursor = "cursor", e.Padding = "padding", e.BorderRadius = "borderradius", e.CollectionReference = "collectionreference", e.MultiCollectionReference = "multicollectionreference", e))(WO || {}), nm; function UO() { if (nm !== void 0) return nm; let e = document.createElement("div"); Object.assign(e.style, { position: "absolute", display: "flex", flexDirection: "column", rowGap: "1px" }), e.appendChild(document.createElement("div")), e.appendChild(document.createElement("div")), document.body.appendChild(e); let t = e.scrollHeight === 1; return e.parentNode && e.parentNode.removeChild(e), nm = t, t } var to = "flexbox-gap-not-supported", fS = !1; function EH() { fS || (fS = !0, !UO() && document.body.classList.add(to)) } var GO = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6,
[data-framer-component-type="DeprecatedRichText"] li,
[data-framer-component-type="DeprecatedRichText"] ol,
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] span:not([data-text-fill]) {
    font-family: var(--framer-font-family, Inter, Inter Placeholder, sans-serif);
    font-style: var(--framer-font-style, normal);
    font-weight: var(--framer-font-weight, 400);
    color: var(--framer-text-color, #000);
    font-size: var(--framer-font-size, 16px);
    letter-spacing: var(--framer-letter-spacing, 0);
    text-transform: var(--framer-text-transform, none);
    text-decoration: var(--framer-text-decoration, none);
    line-height: var(--framer-line-height, 1.2em);
    text-align: var(--framer-text-alignment, start);
}
`, qO = `
[data-framer-component-type="DeprecatedRichText"] p:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] div:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h1:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h2:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h3:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h4:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h5:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] h6:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ol:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] ul:not(:first-child),
[data-framer-component-type="DeprecatedRichText"] .framer-image:not(:first-child) {
    margin-top: var(--framer-paragraph-spacing, 0);
}
`, XO = `
[data-framer-component-type="DeprecatedRichText"] span[data-text-fill] {
    display: inline-block;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
`, YO = `
[data-framer-component-type="DeprecatedRichText"] a,
[data-framer-component-type="DeprecatedRichText"] a span:not([data-text-fill]) {
    font-family: var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
    font-style: var(--framer-link-font-style, var(--framer-font-style, normal));
    font-weight: var(--framer-link-font-weight, var(--framer-font-weight, 400));
    color: var(--framer-link-text-color, var(--framer-text-color, #000));
    font-size: var(--framer-link-font-size, var(--framer-font-size, 16px));
    text-transform: var(--framer-link-text-transform, var(--framer-text-transform, none));
    text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration, none));
}
`, KO = `
[data-framer-component-type="DeprecatedRichText"] a:hover,
[data-framer-component-type="DeprecatedRichText"] a:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, QO = `
a[data-framer-page-link-current],
a[data-framer-page-link-current] span:not([data-text-fill]) {
    font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
    font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
    font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
    color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
    font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)));
    text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
    text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
}
`, ZO = `
a[data-framer-page-link-current]:hover,
a[data-framer-page-link-current]:hover span:not([data-text-fill]) {
    font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
    font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
    font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
    color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
    font-size: var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))));
    text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
    text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
}
`, JO = `
[data-framer-component-type="DeprecatedRichText"] strong {
    font-weight: bolder;
}
`, eD = `
[data-framer-component-type="DeprecatedRichText"] em {
    font-style: italic;
}
`, tD = `
[data-framer-component-type="DeprecatedRichText"] .framer-image {
    display: block;
    max-width: 100%;
    height: auto;
}
`, nD = `
[data-framer-component-type="DeprecatedRichText"] p,
[data-framer-component-type="DeprecatedRichText"] div,
[data-framer-component-type="DeprecatedRichText"] h1,
[data-framer-component-type="DeprecatedRichText"] h2,
[data-framer-component-type="DeprecatedRichText"] h3,
[data-framer-component-type="DeprecatedRichText"] h4,
[data-framer-component-type="DeprecatedRichText"] h5,
[data-framer-component-type="DeprecatedRichText"] h6 {
    margin: 0;
    padding: 0;
}
`, rD = `
[data-framer-component-type="DeprecatedRichText"] .text-styles-preset-reset {
    --framer-font-family: Inter, Inter Placeholder, sans-serif;
    --framer-font-style: normal;
    --framer-font-weight: 500;
    --framer-text-color: #000;
    --framer-font-size: 16px;
    --framer-letter-spacing: 0;
    --framer-text-transform: none;
    --framer-text-decoration: none;
    --framer-line-height: 1.2em;
    --framer-text-alignment: start;
    --framer-font-open-type-features: normal;
}
`, iD = `
[data-framer-component-type="DeprecatedRichText"] ul,
[data-framer-component-type="DeprecatedRichText"] ol {
    display: table;
    width: 100%;
    padding-left: 0;
    margin: 0;
}
`, oD = `
[data-framer-component-type="DeprecatedRichText"] li {
    display: table-row;
    counter-increment: list-item;
    list-style: none;
}
`, sD = `
[data-framer-component-type="DeprecatedRichText"] ol > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: counter(list-item) ".";
    white-space: nowrap;
}
`, aD = `
[data-framer-component-type="DeprecatedRichText"] ul > li::before {
    display: table-cell;
    width: 2.25ch;
    box-sizing: border-box;
    padding-right: 0.75ch;
    content: "\u2022";
}
`, lD = ['[data-framer-component-type="DeprecatedRichText"] { cursor: inherit; }', rD, nD, GO, qO, XO, YO, KO, QO, ZO, JO, eD, tD, iD, oD, sD, aD], cD = [`
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        ol.framer-text,
        ul.framer-text {
            margin: 0;
            padding: 0;
        }
    `, `
        p.framer-text,
        div.framer-text,
        h1.framer-text,
        h2.framer-text,
        h3.framer-text,
        h4.framer-text,
        h5.framer-text,
        h6.framer-text,
        li.framer-text,
        ol.framer-text,
        ul.framer-text,
        span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-blockquote-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-blockquote-text-color, var(--framer-text-color, #000));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-text-transform, none));
            text-decoration: var(--framer-blockquote-text-decoration, var(--framer-text-decoration, none));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
            text-align: var(--framer-blockquote-text-alignment, var(--framer-text-alignment, start));
            -webkit-text-stroke-width: var(--framer-text-stroke-width, initial);
            -webkit-text-stroke-color: var(--framer-text-stroke-color, initial);
            -moz-font-feature-settings: var(--framer-font-open-type-features, initial);
            -webkit-font-feature-settings: var(--framer-font-open-type-features, initial);
            font-feature-settings: var(--framer-font-open-type-features, initial);
            text-wrap: var(--framer-text-wrap-override, var(--framer-text-wrap));
        }
    `, `
        .framer-fit-text .framer-text {
            white-space: nowrap;
            white-space-collapse: preserve;
        }
    `, `
        strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold, var(--framer-font-family-bold));
            font-style: var(--framer-blockquote-font-style-bold, var(--framer-font-style-bold));
            font-weight: var(--framer-blockquote-font-weight-bold, var(--framer-font-weight-bold, bolder));
        }
    `, `
        em.framer-text {
            font-family: var(--framer-blockquote-font-family-italic, var(--framer-font-family-italic));
            font-style: var(--framer-blockquote-font-style-italic, var(--framer-font-style-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-italic, var(--framer-font-weight-italic));
        }
    `, `
        em.framer-text > strong.framer-text {
            font-family: var(--framer-blockquote-font-family-bold-italic, var(--framer-font-family-bold-italic));
            font-style: var(--framer-blockquote-font-style-bold-italic, var(--framer-font-style-bold-italic, italic));
            font-weight: var(--framer-blockquote-font-weight-bold-italic, var(--framer-font-weight-bold-italic, bolder));
        }
    `, `
        p.framer-text:not(:first-child),
        div.framer-text:not(:first-child),
        h1.framer-text:not(:first-child),
        h2.framer-text:not(:first-child),
        h3.framer-text:not(:first-child),
        h4.framer-text:not(:first-child),
        h5.framer-text:not(:first-child),
        h6.framer-text:not(:first-child),
        ol.framer-text:not(:first-child),
        ul.framer-text:not(:first-child),
        blockquote.framer-text:not(:first-child),
        .framer-image.framer-text:not(:first-child) {
            margin-top: var(--framer-blockquote-paragraph-spacing, var(--framer-paragraph-spacing, 0));
        }
    `, `
        li.framer-text > ul.framer-text:nth-child(2),
        li.framer-text > ol.framer-text:nth-child(2) {
            margin-top: 0;
        }
    `, `
        .framer-text[data-text-fill] {
            display: inline-block;
            background-clip: text;
            -webkit-background-clip: text;
            /* make this a transparent color if you want to visualise the clipping  */
            -webkit-text-fill-color: transparent;
            padding: max(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / 2));
            margin: min(0em, calc(calc(1.3em - var(--framer-blockquote-line-height, var(--framer-line-height, 1.3em))) / -2));
        }
    `, `
        code.framer-text,
        code.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            letter-spacing: var(--framer-blockquote-letter-spacing, var(--framer-letter-spacing, 0));
            line-height: var(--framer-blockquote-line-height, var(--framer-line-height, 1.2em));
        }
    `, `
        blockquote.framer-text {
            margin-block-start: initial;
            margin-block-end: initial;
            margin-inline-start: initial;
            margin-inline-end: initial;
            unicode-bidi: initial;
        }
    `, `
        a.framer-text,
        a.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
            /* Cursor inherit to overwrite the user agent stylesheet on rich text links. */
            cursor: var(--framer-custom-cursors, pointer);
        }
    `, `
        code.framer-text a.framer-text,
        code.framer-text a.framer-text span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-blockquote-font-size, var(--framer-font-size, 16px)) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text:hover,
        a.framer-text:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-blockquote-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-blockquote-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-blockquote-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-blockquote-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-blockquote-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text:hover,
        code.framer-text a.framer-text:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-blockquote-font-family, var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-blockquote-font-style, var(--framer-code-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-blockquote-font-weight, var(--framer-code-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-hover-text-color, var(--framer-blockquote-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-blockquote-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current],
        a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif)));
            font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal)));
            font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400)));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000)));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none)));
            text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none)));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current],
        code.framer-text a.framer-text[data-framer-page-link-current] span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px))) * var(--framer-font-size-scale, 1));
        }
    `, `
        a.framer-text[data-framer-page-link-current]:hover,
        a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-link-hover-font-family, var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif))));
            font-style: var(--framer-link-hover-font-style, var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style, normal))));
            font-weight: var(--framer-link-hover-font-weight, var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight, 400))));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color, #000))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
            text-transform: var(--framer-link-hover-text-transform, var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform, none))));
            text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration, none))));
        }
    `, `
        code.framer-text a.framer-text[data-framer-page-link-current]:hover,
        code.framer-text a.framer-text[data-framer-page-link-current]:hover span.framer-text:not([data-text-fill]) {
            font-family: var(--framer-code-font-family, var(--framer-font-family, Inter, Inter Placeholder, sans-serif));
            font-style: var(--framer-code-font-style, var(--framer-font-style, normal));
            font-weight: var(--framer-code-font-weight, var(--framer-font-weight, 400));
            color: var(--framer-link-hover-text-color, var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-code-text-color, var(--framer-text-color, #000)))));
            font-size: calc(var(--framer-link-hover-font-size, var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size, 16px)))) * var(--framer-font-size-scale, 1));
        }
    `, `
        .framer-image.framer-text {
            display: block;
            max-width: 100%;
            height: auto;
        }
    `, `
        .text-styles-preset-reset.framer-text {
            --framer-font-family: Inter, Inter Placeholder, sans-serif;
            --framer-font-style: normal;
            --framer-font-weight: 500;
            --framer-text-color: #000;
            --framer-font-size: 16px;
            --framer-letter-spacing: 0;
            --framer-text-transform: none;
            --framer-text-decoration: none;
            --framer-line-height: 1.2em;
            --framer-text-alignment: start;
            --framer-font-open-type-features: normal;
        }
    `, `
        ol.framer-text {
            --list-style-type: decimal;
        }
    `, `
        ul.framer-text,
        ol.framer-text {
            display: table;
            width: 100%;
        }
    `, `
        li.framer-text {
            display: table-row;
            counter-increment: list-item;
            list-style: none;
        }
    `, `
        ol.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: counter(list-item, var(--list-style-type)) ".";
            white-space: nowrap;
        }
    `, `
        ul.framer-text > li.framer-text::before {
            display: table-cell;
            width: 2.25ch;
            box-sizing: border-box;
            padding-inline-end: 0.75ch;
            content: "\u2022";
        }
    `, `
        .framer-text-module[style*="aspect-ratio"] > :first-child {
            width: 100%;
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] {
                position: relative;
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"]::before {
                content: "";
                display: block;
                padding-bottom: calc(100% / calc(var(--aspect-ratio)));
            }
        }
    `, `
        @supports not (aspect-ratio: 1) {
            .framer-text-module[style*="aspect-ratio"] > :first-child {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
            }
        }
    `], uD = new Set, rm; function Vk(e, t, n = uD) { if (!(!e || n.has(e) || typeof document > "u")) { if (n.add(e), !t) { if (!rm) { let r = document.createElement("style"); if (r.setAttribute("type", "text/css"), r.setAttribute("data-framer-css", "true"), !document.head) { console.warn("not injecting CSS: the document is missing a <head> element"); return } if (document.head.appendChild(r), r.sheet) rm = r.sheet; else { console.warn("not injecting CSS: injected <style> element does not have a sheet", r); return } } t = rm } try { t.insertRule(e, t.cssRules.length) } catch { } } } var fD = ["[data-framer-component-type] { position: absolute; }"], dD = `
[data-framer-component-type="Text"] > * {
    text-align: var(--framer-text-alignment, start);
}`, hD = `
[data-framer-component-type="Text"] span span,
[data-framer-component-type="Text"] p span,
[data-framer-component-type="Text"] h1 span,
[data-framer-component-type="Text"] h2 span,
[data-framer-component-type="Text"] h3 span,
[data-framer-component-type="Text"] h4 span,
[data-framer-component-type="Text"] h5 span,
[data-framer-component-type="Text"] h6 span {
    display: block;
}`, pD = `
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span {
    display: unset;
}`, mD = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    font-family: var(--font-family);
    font-style: var(--font-style);
    font-weight: min(calc(var(--framer-font-weight-increase, 0) + var(--font-weight, 400)), 900);
    color: var(--text-color);
    letter-spacing: var(--letter-spacing);
    font-size: var(--font-size);
    text-transform: var(--text-transform);
    text-decoration: var(--text-decoration);
    line-height: var(--line-height);
}`, gD = `
[data-framer-component-type="Text"] div div span,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] span span span,
[data-framer-component-type="Text"] p span span,
[data-framer-component-type="Text"] h1 span span,
[data-framer-component-type="Text"] h2 span span,
[data-framer-component-type="Text"] h3 span span,
[data-framer-component-type="Text"] h4 span span,
[data-framer-component-type="Text"] h5 span span,
[data-framer-component-type="Text"] h6 span span,
[data-framer-component-type="Text"] a {
    --font-family: var(--framer-font-family);
    --font-style: var(--framer-font-style);
    --font-weight: var(--framer-font-weight);
    --text-color: var(--framer-text-color);
    --letter-spacing: var(--framer-letter-spacing);
    --font-size: var(--framer-font-size);
    --text-transform: var(--framer-text-transform);
    --text-decoration: var(--framer-text-decoration);
    --line-height: var(--framer-line-height);
}`, vD = `
[data-framer-component-type="Text"] a,
[data-framer-component-type="Text"] a div span,
[data-framer-component-type="Text"] a span span span,
[data-framer-component-type="Text"] a p span span,
[data-framer-component-type="Text"] a h1 span span,
[data-framer-component-type="Text"] a h2 span span,
[data-framer-component-type="Text"] a h3 span span,
[data-framer-component-type="Text"] a h4 span span,
[data-framer-component-type="Text"] a h5 span span,
[data-framer-component-type="Text"] a h6 span span {
    --font-family: var(--framer-link-font-family, var(--framer-font-family));
    --font-style: var(--framer-link-font-style, var(--framer-font-style));
    --font-weight: var(--framer-link-font-weight, var(--framer-font-weight));
    --text-color: var(--framer-link-text-color, var(--framer-text-color));
    --font-size: var(--framer-link-font-size, var(--framer-font-size));
    --text-transform: var(--framer-link-text-transform, var(--framer-text-transform));
    --text-decoration: var(--framer-link-text-decoration, var(--framer-text-decoration));
}`, yD = `
[data-framer-component-type="Text"] a:hover,
[data-framer-component-type="Text"] a div span:hover,
[data-framer-component-type="Text"] a span span span:hover,
[data-framer-component-type="Text"] a p span span:hover,
[data-framer-component-type="Text"] a h1 span span:hover,
[data-framer-component-type="Text"] a h2 span span:hover,
[data-framer-component-type="Text"] a h3 span span:hover,
[data-framer-component-type="Text"] a h4 span span:hover,
[data-framer-component-type="Text"] a h5 span span:hover,
[data-framer-component-type="Text"] a h6 span span:hover {
    --font-family: var(--framer-link-hover-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-hover-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-hover-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-hover-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-hover-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-hover-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-hover-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`, bD = `
[data-framer-component-type="Text"].isCurrent a,
[data-framer-component-type="Text"].isCurrent a div span,
[data-framer-component-type="Text"].isCurrent a span span span,
[data-framer-component-type="Text"].isCurrent a p span span,
[data-framer-component-type="Text"].isCurrent a h1 span span,
[data-framer-component-type="Text"].isCurrent a h2 span span,
[data-framer-component-type="Text"].isCurrent a h3 span span,
[data-framer-component-type="Text"].isCurrent a h4 span span,
[data-framer-component-type="Text"].isCurrent a h5 span span,
[data-framer-component-type="Text"].isCurrent a h6 span span {
    --font-family: var(--framer-link-current-font-family, var(--framer-link-font-family, var(--framer-font-family)));
    --font-style: var(--framer-link-current-font-style, var(--framer-link-font-style, var(--framer-font-style)));
    --font-weight: var(--framer-link-current-font-weight, var(--framer-link-font-weight, var(--framer-font-weight)));
    --text-color: var(--framer-link-current-text-color, var(--framer-link-text-color, var(--framer-text-color)));
    --font-size: var(--framer-link-current-font-size, var(--framer-link-font-size, var(--framer-font-size)));
    --text-transform: var(--framer-link-current-text-transform, var(--framer-link-text-transform, var(--framer-text-transform)));
    --text-decoration: var(--framer-link-current-text-decoration, var(--framer-link-text-decoration, var(--framer-text-decoration)));
}`, xD = ['[data-framer-component-type="Text"] { cursor: inherit; }', "[data-framer-component-text-autosized] * { white-space: pre; }", dD, hD, pD, mD, gD, vD, yD, bD], wD = `
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > *,
:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-legacy-stack-gap-enabled] > [data-framer-component-type] {
    position: relative;
}`, SD = (() => [`[data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: var(--stack-native-row-gap);
        column-gap: var(--stack-native-column-gap);
    }`, `.${to} [data-framer-stack-content-wrapper][data-framer-stack-gap-enabled="true"] {
        row-gap: unset;
        column-gap: unset;
    }`])(), kD = (() => `
.${to} [data-framer-legacy-stack-gap-enabled="true"] > *, [data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"] {
    margin-top: calc(var(--stack-gap-y) / 2);
    margin-bottom: calc(var(--stack-gap-y) / 2);
    margin-right: calc(var(--stack-gap-x) / 2);
    margin-left: calc(var(--stack-gap-x) / 2);
}
`)(), CD = (() => `
.${to}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child,
.${to}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child {
    margin-top: 0;
    margin-left: 0;
}`)(), TD = (() => `
.${to}
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:last-child,
[data-framer-stack-direction-reverse="false"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:last-child,
.${to}
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"]
> *:first-child,
[data-framer-stack-direction-reverse="true"]
[data-framer-legacy-stack-gap-enabled="true"][data-framer-stack-flexbox-gap="false"]
> *:first-child {
    margin-right: 0;
    margin-bottom: 0;
}`)(), ED = (() => [wD, kD, ...SD, CD, TD])(), RD = [`
NavigationContainer
[data-framer-component-type="NavigationContainer"] > *,
[data-framer-component-type="NavigationContainer"] > [data-framer-component-type] {
    position: relative;
}`], PD = ['[data-framer-component-type="Scroll"]::-webkit-scrollbar { display: none; }', '[data-framer-component-type="ScrollContentWrapper"] > * { position: relative; }'], _D = ['[data-framer-component-type="NativeScroll"] { -webkit-overflow-scrolling: touch; }', '[data-framer-component-type="NativeScroll"] > * { position: relative; }', '[data-framer-component-type="NativeScroll"].direction-both { overflow-x: scroll; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-vertical { overflow-x: hidden; overflow-y: scroll; }', '[data-framer-component-type="NativeScroll"].direction-horizontal { overflow-x: scroll; overflow-y: hidden; }', '[data-framer-component-type="NativeScroll"].direction-vertical > * { width: 100% !important; }', '[data-framer-component-type="NativeScroll"].direction-horizontal > * { height: 100% !important; }', '[data-framer-component-type="NativeScroll"].scrollbar-hidden::-webkit-scrollbar { display: none; }'], FD = ['[data-framer-component-type="DeviceComponent"].no-device > * { width: 100% !important; height: 100% !important; }'], ID = ['[data-framer-component-type="PageContentWrapper"] > *, [data-framer-component-type="PageContentWrapper"] > [data-framer-component-type] { position: relative; }'], LD = ['[data-is-present="false"], [data-is-present="false"] * { pointer-events: none !important; }'], MD = ['[data-framer-cursor="pointer"] { cursor: pointer; }', '[data-framer-cursor="grab"] { cursor: grab; }', '[data-framer-cursor="grab"]:active { cursor: grabbing; }'], OD = ['[data-framer-component-type="Frame"] *, [data-framer-component-type="Stack"] * { pointer-events: auto; }', "[data-framer-generated] * { pointer-events: unset }"], DD = [`[data-reset="button"] {
        border-width: 0;
        padding: 0;
        background: none;
}`], AD = ['[data-hide-scrollbars="true"]::-webkit-scrollbar { width: 0px; height: 0px; }', '[data-hide-scrollbars="true"]::-webkit-scrollbar-thumb { background: transparent; }'], im = "--framer-will-change-override", VD = "(background: -webkit-named-image(i))", BD = "(grid-template-rows: subgrid)", zD = e => e ? [`body { ${im}: none; }`, `@supports ${VD} and (not ${BD}) { body { ${im}: transform; } }`] : [`body { ${im}: none; }`], $D = e => e ? OD : [], ND = [".svgContainer svg { display: block; }"], Bk = e => [...zD(e), ...fD, ...xD, ...cD, ...lD, ...ED, ...RD, ...PD, ..._D, ...ID, ...FD, ...LD, ...MD, ...$D(e), ...ND, ...DD, ...AD], HD = Bk(!1), jD = Bk(!0), dS = !1; function Za() { if (dS) return; dS = !0; let e = le.current() === le.preview ? jD : HD; for (let t of e) Vk(t, void 0, void 0) } function ki(e) { return typeof e == "function" } function Gu(e) { return typeof e == "boolean" } function fe(e) { return typeof e == "string" } function Ae(e) { return Number.isFinite(e) } function Ja(e) { return Array.isArray(e) } function Me(e) { return e !== null && typeof e == "object" && !Ja(e) } function it(e) { return typeof e > "u" } function oe(e) { return e === null } function os(e) { return e == null } function tg(e) { return e instanceof Date && !isNaN(e.getTime()) } function WD(e) { return Me(e) || ki(e) } var hS = "optional"; function UD(e) { return !!e && hS in e && e[hS] === !0 } function GD(e) { try { switch (e.type) { case "string": case "collectionreference": case "multicollectionreference": case "color": case "date": case "link": case "boxshadow": case "padding": case "borderradius": return fe(e.defaultValue) ? e.defaultValue : void 0; case "boolean": return Gu(e.defaultValue) ? e.defaultValue : void 0; case "enum": return it(e.defaultValue) ? void 0 : e.options.includes(e.defaultValue) ? e.defaultValue : void 0; case "fusednumber": case "number": return Ae(e.defaultValue) ? e.defaultValue : void 0; case "transition": return Me(e.defaultValue) ? e.defaultValue : void 0; case "border": return Me(e.defaultValue) ? e.defaultValue : void 0; case "font": return Me(e.defaultValue) ? e.defaultValue : void 0; case "object": { let t = Me(e.defaultValue) ? e.defaultValue : {}; return Me(e.controls) && zk(t, e.controls), t } case "array": return Ja(e.defaultValue) ? e.defaultValue : void 0; case "file": case "image": case "richtext": case "pagescope": case "eventhandler": case "segmentedenum": case "responsiveimage": case "componentinstance": case "scrollsectionref": case "customcursor": case "cursor": return; default: return } } catch { return } } function zk(e, t) { for (let n in t) { let r = t[n]; if (!r) continue; let i = e[n]; if (!it(i) || UD(r)) continue; let o = GD(r); it(o) || (e[n] = o) } } function qD(e) { if (Me(e.defaultProps)) return e.defaultProps; let t = {}; return e.defaultProps = t, t } function XD(e, t) { if (!WD(e)) return; let n = qD(e); zk(n, t) } function RH(e, t) { Object.assign(e, { propertyControls: t }), XD(e, t) } function YD(e) { return e.propertyControls } var Je = e => e; function KD(e) { let t = Object.create(Object.prototype); return n => (t[n] === void 0 && (t[n] = e(n)), t[n]) } var QD = /^(?:children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|[dkrxyz]|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y1|y2|yChannelSelector|zoomAndPan|for|class|autofocus|(?:[Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*)$/, ZD = KD(e => QD.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91), pS = e => () => { Ba(e) }, JD = () => () => { }, eA = { useImageSource(e) { return e.src ?? "" }, useImageElement(e, t, n) { let r = new Image; return r.src = ut.useImageSource(e, t, n), e.srcSet && (r.srcset = e.srcSet), r }, canRenderOptimizedCanvasImage() { return !1 } }, tA = !1, nA = { get(e, t, n) { return Reflect.has(e, t) ? Reflect.get(e, t, n) : ["getLogger"].includes(String(t)) ? JD() : pS(tA ? `${String(t)} is not available in this version of Framer.` : `${String(t)} is only available inside of Framer. https://www.framer.com/`) } }, ut = new Proxy(eA, nA); function rA(e, t, n = 1) { let { width: r, height: i } = t, o = e.pixelWidth ?? e.intrinsicWidth ?? 0, s = e.pixelHeight ?? e.intrinsicHeight ?? 0; if (r < 1 || i < 1 || o < 1 || s < 1) return; r *= n, i *= n; let a = r / i, l = o / s; switch (e.fit) { case "fill": return l > a ? s / i : o / r; case "fit": case "stretch": return Math.max(o / r, s / i) } } function mS(e, t) { return t && Math.max(1, e) > t ? "pixelated" : "auto" } var gS = { position: "absolute", borderRadius: "inherit", top: 0, right: 0, bottom: 0, left: 0 }, iA = { backgroundRepeat: "repeat", backgroundPosition: "left top", backgroundSize: "126px auto", backgroundImage: "url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTI2IiBoZWlnaHQ9IjEyNiI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0xMjYgMHYyMS41ODRMMjEuNTg0IDEyNkgwdi0xNy41ODVMMTA4LjQxNSAwSDEyNlptMCAxMDguNDE0VjEyNmgtMTcuNTg2TDEyNiAxMDguNDE0Wm0wLTg0djM5LjE3MUw2My41ODUgMTI2SDI0LjQxNEwxMjYgMjQuNDE0Wm0wIDQydjM5LjE3TDEwNS41ODQgMTI2aC0zOS4xN0wxMjYgNjYuNDE0Wk0xMDUuNTg2IDAgMCAxMDUuNTg2VjY2LjQxNUw2Ni40MTUgMGgzOS4xNzFabS00MiAwTDAgNjMuNTg2VjI0LjQxNUwyNC40MTUgMGgzOS4xNzFabS00MiAwTDAgMjEuNTg2VjBoMjEuNTg2WiIvPjwvZGVmcz48dXNlIHhsaW5rOmhyZWY9IiNhIiBmaWxsPSIjODg4IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)", opacity: .2 }; function oA(e) { switch (e) { case "fit": return "contain"; case "stretch": return "fill"; default: return "cover" } } function $k(e, t) { let n = e ?? "center", r = t ?? "center"; return n === "center" && r === "center" ? "center" : n + " " + r } function sA(e, t) { if (!t) return "auto"; let n = le.current() === le.canvas ? ft.devicePixelRatio : 1, r = rA(e, t, n); return le.current() === le.canvas ? mS(1, r) : mS(Lu.zoom, r) } function ng(e, t) { return { display: "block", width: "100%", height: "100%", borderRadius: "inherit", objectPosition: $k(e.positionX, e.positionY), objectFit: oA(e.fit), imageRendering: sA(e, t) } } function aA({ image: e, containerSize: t, nodeId: n, alt: r }) { let i = ut.useImageSource(e, t, n), o = ng(e, t), s = x.useRef(null); return k("img", { ref: s, decoding: "async", loading: e.loading, sizes: e.sizes, srcSet: e.srcSet, src: i, alt: r ?? e.alt, style: o }) } function lA({ image: e, containerSize: t, nodeId: n }) { let r = x.useRef(null), i = ut.useImageElement(e, t, n), o = ng(e, t); return x.useLayoutEffect(() => { let s = r.current; if (s !== null) return s.appendChild(i), () => { s.removeChild(i) } }, [i]), Object.assign(i.style, o), k("div", { ref: r, style: { display: "contents", borderRadius: "inherit" } }) } function cA({ nodeId: e, image: t, containerSize: n }) { let r = x.useRef(null), i = ut.useImageSource(t, n, e); return x.useLayoutEffect(() => { let o = r.current; if (o === null) return; let s = ng(t, n); ut.renderOptimizedCanvasImage(o, i, s, e) }, [e, t, i, n]), k("div", { ref: r, style: { display: "contents", borderRadius: "inherit" } }) } function Nk({ layoutId: e, image: t, ...n }) { e && (e = e + "-background"); let r = { ...gS, ...iA }, i = null; if (fe(t.src)) if (t.fit === "tile" && t.pixelWidth && t.pixelHeight) { let o = Ae(t.backgroundSize) ? t.backgroundSize : 1, s = { width: Math.round(o * t.pixelWidth), height: Math.round(o * t.pixelHeight) }, a = ut.useImageSource(t, s); r.backgroundImage = `url(${a})`, r.backgroundRepeat = "repeat", r.backgroundPosition = $k(t.positionX, t.positionY), r.opacity = void 0, r.border = 0, r.backgroundSize = `${(o * (t.pixelWidth / 2)).toFixed(2)}px auto`, i = null } else le.current() !== le.canvas ? i = k(aA, { image: t, ...n }) : ut.canRenderOptimizedCanvasImage(ut.useImageSource(t)) ? i = k(cA, { image: t, ...n }) : i = k(lA, { image: t, ...n }); return k(gn.div, { layoutId: e, style: i ? gS : r, "data-framer-background-image-wrapper": !0, children: i }) } var uA = "src", Ki = { isImageObject: function (e) { return !e || typeof e == "string" ? !1 : uA in e } }; function fA(e, t) { let { _forwardedOverrideId: n, _forwardedOverrides: r, id: i } = t, o = n ?? i, s = r && o ? r[o] : void 0; return s && typeof s == "string" && (e = { ...e, src: s }), e } function dA(e) { let { background: t, image: n } = e; if (n !== void 0 && t && !Ki.isImageObject(t)) return; let r = null; if (fe(n) ? r = { alt: "", src: n } : r = rt.get(t, null), !!Ki.isImageObject(r)) return fA(r, e) } function hA(e, t, n = !0) { let { borderWidth: r, borderStyle: i, borderColor: o } = e; if (!r) return; let s, a, l, c; if (typeof r == "number" ? s = a = l = c = r : (s = r.top || 0, a = r.bottom || 0, l = r.left || 0, c = r.right || 0), !(s === 0 && a === 0 && l === 0 && c === 0)) { if (n && s === a && s === l && s === c) { t.border = `${s}px ${i} ${o}`; return } t.borderStyle = e.borderStyle, t.borderColor = e.borderColor, t.borderTopWidth = `${s}px`, t.borderBottomWidth = `${a}px`, t.borderLeftWidth = `${l}px`, t.borderRightWidth = `${c}px` } } function pA(e) { let t = e.layoutId ? `${e.layoutId}-border` : void 0; if (!e.borderWidth) return null; let n = { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, borderRadius: "inherit", pointerEvents: "none" }; return e.border ? (n.border = e.border, k(gn.div, { style: n })) : (hA(e, n, !1), k(gn.div, { "data-frame-border": !0, style: n, layoutId: t })) } function el(e) { return e && e !== "search" && e !== "slot" && e !== "template" ? gn[e] : gn.div } var mA = Zn(Um(), 1), En = typeof Ne < "u" ? Ne : void 0, zr = () => typeof document == "object"; var gA = () => En && /Chrome/.test(En.userAgent) && /Google Inc/.test(En.vendor) && !xA(), vA = () => En && /Safari/.test(En.userAgent) && /Apple Computer/.test(En.vendor), yA = () => En && /Firefox\/\d+\.\d+$/.test(En.userAgent), bA = () => En && /FramerX/.test(En.userAgent), xA = () => En && /Edg\//.test(En.userAgent); var wA = () => mA.default.env.NODE_ENV === "test"; var SA = gA(); function Hk(e) { let t = {}; return !SA || le.current() !== le.canvas || ((e === !0 || e === "x") && (t["data-framer-layout-hint-center-x"] = !0), (e === !0 || e === "y") && (t["data-framer-layout-hint-center-y"] = !0)), t } function rg(e) { return e.replace(/^id_/, "").replace(/\\/g, "") } function kA(e, t) { if (!t && (t = e.children, !t)) return { props: e, children: t }; let n = e._forwardedOverrides; return n ? (t = x.Children.map(t, r => x.isValidElement(r) ? x.cloneElement(r, { _forwardedOverrides: n }) : r), { props: e, children: t }) : { props: e, children: t } } function qu(e) { return (t, n) => e === !0 ? `translate(-50%, -50%) ${n}` : e === "x" ? `translateX(-50%) ${n}` : e === "y" ? `translateY(-50%) ${n}` : n || "none" } function tl(e, { specificLayoutId: t, postfix: n } = {}) { let { name: r, layoutIdKey: i, duplicatedFrom: o, __fromCodeComponentNode: s = !1, drag: a } = e, { getLayoutId: l, enabled: c } = V(is); return ae(() => { if (!c) return e.layoutId; let u = t || e.layoutId; if (!u && (a || !i || s)) return; let f = u || l({ id: i, name: r, duplicatedFrom: o }); if (f) return n ? `${f}-${n}` : f }, [c]) } var jk = typeof document < "u" ? et : N, cs = x.createContext(!1); function Xu() { let [e, t] = x.useState(0); return x.useCallback(() => t(n => n + 1), []) } var CA = (() => VL().ResizeObserver)(); var TA = class { constructor() { T(this, "sharedResizeObserver"), T(this, "callbacks", new WeakMap); let e = ft.ResizeObserver ?? CA; this.sharedResizeObserver = new e(this.updateResizedElements.bind(this)) } updateResizedElements(e) { for (let t of e) { let n = this.callbacks.get(t.target); n && n(t.contentRect) } } observeElementWithCallback(e, t) { this.sharedResizeObserver.observe(e), this.callbacks.set(e, t) } unobserve(e) { this.sharedResizeObserver.unobserve(e), this.callbacks.delete(e) } }, mu = (() => zr() ? new TA : void 0)(); function EA(e) { let t = Xu(); N(() => { let n = e?.current; if (n) return mu?.observeElementWithCallback(e.current, t), () => { mu?.unobserve(n) } }, [e, t]) } var RA = "data-framer-size-compatibility-wrapper"; function PA(e) { return [...e.firstElementChild && e.firstElementChild.hasAttribute(RA) ? e.firstElementChild.children : e.children].filter(Wk).map(Uk) } function Wk(e) { return e instanceof HTMLBaseElement || e instanceof HTMLHeadElement || e instanceof HTMLLinkElement || e instanceof HTMLMetaElement || e instanceof HTMLScriptElement || e instanceof HTMLStyleElement || e instanceof HTMLTitleElement ? !1 : e instanceof HTMLElement || e instanceof SVGElement } function Uk(e) { if (!(e instanceof HTMLElement) || e.children.length === 0 || e.style.display !== "contents") return e; let t = [...e.children].find(Wk); return t ? Uk(t) : e } function Yu(e, t, n = () => [], r = {}) { let { id: i, visible: o, _needsMeasure: s } = e, { skipHook: a = !1 } = r, l = !!V(cs), c = le.current() === le.canvas; jk(() => { !c || l || a || t.current && i && o && s && ut.queueMeasureRequest(rg(i), t.current, n(t.current)) }) } function _A(e) { let t = e.closest("[data-framer-component-container]"); t && ut.queueMeasureRequest(rg(t.id), t, PA(t)) } var no = Object.keys; function $a(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function vS(e) { return $a(e, "equals") ? typeof e.equals == "function" : !1 } function ig(e, t) { return e === t ? !0 : e !== e && t !== t } function FA(e, t) { let n = e.length; if (n !== t.length) return !1; for (let r = n; r-- !== 0;)if (!ig(e[r], t[r])) return !1; return !0 } function IA(e, t) { let n = e.length; if (n !== t.length) return !1; for (let r = n; r-- !== 0;)if (!Ku(e[r], t[r], !0)) return !1; return !0 } function LA(e, t) { if (e.size !== t.size) return !1; for (let [n, r] of e.entries()) if (!ig(r, t.get(n))) return !1; return !0 } function MA(e, t) { if (e.size !== t.size) return !1; for (let [n, r] of e.entries()) if (!Ku(r, t.get(n), !0)) return !1; return !0 } function OA(e, t) { if (e.size !== t.size) return !1; for (let n of e.keys()) if (!t.has(n)) return !1; return !0 } function DA(e, t) { let n = no(e); if (n.length !== no(t).length) return !1; for (let r of n) { if (!$a(t, r)) return !1; if (!(r === "_owner" && $a(e, "$$typeof") && e.$$typeof) && !ig(e[r], t[r])) return !1 } return !0 } function AA(e, t) { let n = no(e); if (n.length !== no(t).length) return !1; for (let r of n) { if (!$a(t, r)) return !1; if (!(r === "_owner" && $a(e, "$$typeof") && e.$$typeof) && !Ku(e[r], t[r], !0)) return !1 } return !0 } function Ku(e, t, n) { if (e === t) return !0; if (!e || !t) return e !== e && t !== t; let r = typeof e; if (r !== typeof t || r !== "object") return !1; let o = Array.isArray(e), s = Array.isArray(t); if (o && s) return n ? IA(e, t) : FA(e, t); if (o !== s) return !1; let a = e instanceof Map, l = t instanceof Map; if (a && l) return n ? MA(e, t) : LA(e, t); if (a !== l) return !1; let c = e instanceof Set, u = t instanceof Set; if (c && u) return OA(e, t); if (c !== u) return !1; let f = e instanceof Date, d = t instanceof Date; if (f && d) return e.getTime() === t.getTime(); if (f !== d) return !1; let m = e instanceof RegExp, y = t instanceof RegExp; return m && y ? e.toString() === t.toString() : m !== y ? !1 : vS(e) && vS(t) ? e.equals(t) : n ? AA(e, t) : DA(e, t) } function qe(e, t, n = !0) { try { return Ku(e, t, n) } catch (r) { if (r instanceof Error && /stack|recursion/iu.exec(r.message)) return console.warn("Warning: isEqual does not handle circular references.", r.name, r.message), !1; throw r } } var Gk = "0.000001px", om = (() => ` translateZ(${Gk})`)(), qk = (() => bA() || vA() || wA())(); function VA(e) { e.willChange = "transform"; let t = le.current() === le.canvas; qk && t && (e.translateZ = Gk) } function og(e) { e.willChange = "transform", BA(e, !0) } function BA(e, t) { let n = le.current() === le.canvas; if (!qk || !n) return; let r = fe(e.transform) && e.transform || ""; t ? r.includes(om) || (e.transform = r + om) : e.transform = r.replace(om, "") } function Xk(e, t, n, r = !0) { if (!e) return; let i = Je(e.style), o = n || i[t], s = () => { i[t] = o }; i[t] = null, r ? Promise.resolve().then(s) : setTimeout(s, 0) } var ku = (() => { class e extends Ee { constructor() { super(...arguments), T(this, "layerElement", null), T(this, "setLayerElement", n => { this.layerElement = n }) } static applyWillChange(n, r, i) { n.willChangeTransform && (i ? VA(r) : og(r)) } shouldComponentUpdate(n, r) { return n._needsMeasure || this.state !== r || !qe(this.props, n) } componentDidUpdate(n) { Je(this.props).clip && Je(this.props).radius === 0 && Je(n).radius !== 0 && Xk(this.layerElement, "overflow", "hidden", !1) } } return T(e, "defaultProps", {}), e })(); function zA(e, t) { if (e.size < t) return; let r = Math.round(Math.random()); for (let i of e.keys()) (++r & 1) !== 1 && e.delete(i) } function $A(e, t, n, r) { let i = t.get(n); if (i) return i; zA(t, e); let o = r(n); return t.set(n, o), o } var Yk = e => { let t = 0, n, r; if (e.length === 0) return t; for (n = 0; n < e.length; n++)r = e.charCodeAt(n), t = (t << 5) - t + r, t |= 0; return t }, sg = { hueRotate: (e, t) => G.toHslString(G.hueRotate(G(e), t)), setAlpha: (e, t) => G.toRgbString(G.alpha(G(e), t)), getAlpha: e => { let t = eg(e); return t ? t.a : 1 }, multiplyAlpha: (e, t) => G.toRgbString(G.multiplyAlpha(G(e), t)), toHex: e => G.toHexString(G(e)).toUpperCase(), toRgb: e => G.toRgb(G(e)), toRgbString: e => G.toRgbString(G(e)), toHSV: e => G.toHsv(G(e)), toHSL: e => G.toHsl(G(e)), toHslString: e => G.toHslString(G(e)), toHsvString: e => G.toHsvString(G(e)), hsvToHSLString: e => G.toHslString(G(hu(e.h, e.s, e.v, e.a))), hsvToHex: e => G.toHexString(G(hu(e.h, e.s, e.v, e.a))).toUpperCase(), hsvToRgbString: e => G.toRgbString(G(hu(e.h, e.s, e.v, e.a))), hsvToString: e => hu(e.h, e.s, e.v), rgbaToString: e => G.toRgbString(G(e)), rgbToHexString: e => G.toHexString(G(e)), hslToString: e => G.toHslString(G(e)), hslToRgbString: e => G.toRgbString(G(e)), toColorPickerSquare: e => G.toRgbString(G({ h: e, s: 1, l: .5, a: 1 })), isValid: e => G(e).isValid !== !1, equals: (e, t) => (typeof e == "string" && (e = G(e)), typeof t == "string" && (t = G(t)), G.equal(e, t)), toHexOrRgbaString: e => { let t = G(e); return t.a !== 1 ? G.toRgbString(t) : G.toHexString(t) } }, NA = /var\(.+\)/, HA = new Map; function jA(e, t) { let n = [e, t]; return NA.test(e) ? e : $A(1e3, HA, n, () => sg.multiplyAlpha(e, t)) } function nl(e, t = 1) { let n; return "stops" in e ? n = e.stops : n = [{ value: e.start, position: 0 }, { value: e.end, position: 1 }], t === 1 ? n : n.map(r => ({ ...r, value: jA(r.value, t) })) } function Kk(e, t) { let n = 0; return nl(e, t).forEach(r => { n ^= Yk(r.value) ^ r.position }), n } var WA = ["stops"]; function Qk(e) { return e && WA.every(t => t in e) } var UA = ["start", "end"]; function Zk(e) { return e && UA.every(t => t in e) } var GA = ["angle", "alpha"], Na = { isLinearGradient: e => e && GA.every(t => t in e) && (Zk(e) || Qk(e)), hash: e => e.angle ^ Kk(e, e.alpha), toCSS: (e, t) => { let n = nl(e, e.alpha), r = t !== void 0 ? t : e.angle, i = n.map(o => `${o.value} ${o.position * 100}%`); return `linear-gradient(${r}deg, ${i.join(", ")})` } }, qA = ["widthFactor", "heightFactor", "centerAnchorX", "centerAnchorY", "alpha"], Ha = { isRadialGradient: e => e && qA.every(t => t in e) && (Zk(e) || Qk(e)), hash: e => e.centerAnchorX ^ e.centerAnchorY ^ e.widthFactor ^ e.heightFactor ^ Kk(e, e.alpha), toCSS: e => { let { alpha: t, widthFactor: n, heightFactor: r, centerAnchorX: i, centerAnchorY: o } = e, s = nl(e, t), a = s.map((l, c) => { let u = s[c + 1], f = l.position === 1 && u?.position === 1 ? l.position - 1e-4 : l.position; return `${l.value} ${f * 100}%` }); return `radial-gradient(${n * 100}% ${r * 100}% at ${i * 100}% ${o * 100}%, ${a.join(", ")})` } }; function XA({ background: e, backgroundColor: t }, n) { t ? typeof t == "string" || lS(t) ? n.backgroundColor = t : G.isColorObject(e) && (n.backgroundColor = e.initialValue || G.toRgbString(e)) : e && (e = rt.get(e, null), typeof e == "string" || lS(e) ? n.background = e : Na.isLinearGradient(e) ? n.background = Na.toCSS(e) : Ha.isRadialGradient(e) ? n.background = Ha.toCSS(e) : G.isColorObject(e) && (n.backgroundColor = e.initialValue || G.toRgbString(e))) } function ye(e, t, n, r) { if (r === void 0 && (r = t), e[t] !== void 0) { n[r] = e[t]; return } } function YA(e) { return e ? e.left !== void 0 && e.right !== void 0 : !1 } function KA(e) { return e ? e.top !== void 0 && e.bottom !== void 0 : !1 } function QA(e) { if (!e) return {}; let t = {}; return e.preserve3d === !0 ? t.transformStyle = "preserve-3d" : e.preserve3d === !1 && (t.transformStyle = "flat"), e.backfaceVisible === !0 ? t.backfaceVisibility = "visible" : e.backfaceVisible === !1 && (t.backfaceVisibility = "hidden"), t.backfaceVisibility && (t.WebkitBackfaceVisibility = t.backfaceVisibility), e.perspective !== void 0 && (t.perspective = t.WebkitPerspective = e.perspective), e.__fromCanvasComponent || (e.center === !0 ? (t.left = "50%", t.top = "50%") : e.center === "x" ? t.left = "50%" : e.center === "y" && (t.top = "50%")), ye(e, "size", t), ye(e, "width", t), ye(e, "height", t), ye(e, "minWidth", t), ye(e, "minHeight", t), ye(e, "top", t), ye(e, "right", t), ye(e, "bottom", t), ye(e, "left", t), ye(e, "position", t), ye(e, "overflow", t), ye(e, "opacity", t), (!e._border || !e._border.borderWidth) && ye(e, "border", t), ye(e, "borderRadius", t), ye(e, "radius", t, "borderRadius"), ye(e, "color", t), ye(e, "shadow", t, "boxShadow"), ye(e, "x", t), ye(e, "y", t), ye(e, "z", t), ye(e, "rotate", t), ye(e, "rotateX", t), ye(e, "rotateY", t), ye(e, "rotateZ", t), ye(e, "scale", t), ye(e, "scaleX", t), ye(e, "scaleY", t), ye(e, "skew", t), ye(e, "skewX", t), ye(e, "skewY", t), ye(e, "originX", t), ye(e, "originY", t), ye(e, "originZ", t), XA(e, t), t } function ZA(e) { for (let t in e) if (t === "drag" || t.startsWith("while") || typeof Je(e)[t] == "function" && t.startsWith("on") && !t.includes("Animation")) return !0; return !1 } var yS = ["onClick", "onDoubleClick", "onMouse", "onMouseDown", "onMouseUp", "onTapDown", "onTap", "onTapUp", "onPointer", "onPointerDown", "onPointerUp", "onTouch", "onTouchDown", "onTouchUp"], JA = (() => new Set([...yS, ...yS.map(e => `${e}Capture`)]))(); function eV(e) { if (e.drag) return "grab"; for (let t in e) if (JA.has(t)) return "pointer" } var sm = "overflow"; function tV(e) { return bS(e) ? !0 : e.style ? !!bS(e.style) : !1 } function bS(e) { return sm in e && (e[sm] === "scroll" || e[sm] === "auto") } function Jk(e) { let { left: t, top: n, bottom: r, right: i, width: o, height: s, center: a, _constraints: l, size: c, widthType: u, heightType: f, positionFixed: d, positionAbsolute: m } = e, y = Tt(e.minWidth), g = Tt(e.minHeight), b = Tt(e.maxWidth), h = Tt(e.maxHeight); return { top: Tt(n), left: Tt(t), bottom: Tt(r), right: Tt(i), width: Tt(o), height: Tt(s), size: Tt(c), center: a, _constraints: l, widthType: u, heightType: f, positionFixed: d, positionAbsolute: m, minWidth: y, minHeight: g, maxWidth: b, maxHeight: h } } var xS = { x: 0, y: 0, width: 200, height: 200 }; function nV(e) { x.useInsertionEffect(() => { Za() }, []); let t = !!V(cs), { style: n, _initialStyle: r, __fromCanvasComponent: i, size: o } = e, s = Jk(e), a = jO(s), l = { display: "block", flex: n?.flex ?? "0 0 auto", userSelect: le.current() !== le.preview ? "none" : void 0 }; e.__fromCanvasComponent || (l.backgroundColor = e.background === void 0 ? "rgba(0, 170, 255, 0.3)" : void 0); let c = !ZA(e) && !e.__fromCanvasComponent && !tV(e), u = e.style ? !("pointerEvents" in e.style) : !0; c && u && (l.pointerEvents = "none"); let d = x.Children.count(e.children) > 0 && x.Children.toArray(e.children).every(h => typeof h == "string" || typeof h == "number") && { display: "flex", alignItems: "center", justifyContent: "center", textAlign: "center" }, m = QA(e); o === void 0 && !i && (YA(m) || (l.width = xS.width), KA(m) || (l.height = xS.height)), s.minWidth !== void 0 && (l.minWidth = s.minWidth), s.minHeight !== void 0 && (l.minHeight = s.minHeight); let y = {}; Ka(s) && a && !Ak(e) && (y = { left: a.x, top: a.y, width: a.width, height: a.height, right: void 0, bottom: void 0 }), Object.assign(l, d, r, m, y, n), Object.assign(l, { overflowX: l.overflowX ?? l.overflow, overflowY: l.overflowY ?? l.overflow, overflow: void 0 }), ku.applyWillChange(e, l, !0); let g = l; l.transform || (g = { x: 0, y: 0, ...l }); let b = le.current() === le.canvas; return e.positionSticky ? (!b || t) && (g.position = "sticky", g.willChange = "transform", g.zIndex = 1, g.top = e.positionStickyTop, g.right = e.positionStickyRight, g.bottom = e.positionStickyBottom, g.left = e.positionStickyLeft) : b && (e.positionFixed || e.positionAbsolute) && (g.position = "absolute"), "rotate" in g && g.rotate === void 0 && delete g.rotate, [g, a] } var rV = new Set(["width", "height", "opacity", "overflow", "radius", "background", "color", "x", "y", "z", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "skew", "skewX", "skewY", "originX", "originY", "originZ"]); function iV(e) { let t = {}; for (let n in e) (po(n) || ZD(n)) && !rV.has(n) ? t[n] = Je(e)[n] : (n === "positionTransition" || n === "layoutTransition") && (t.layout = !0, typeof Je(e)[n] != "boolean" && !e.transition && (t.transition = Je(e)[n])); return t } function oV(e) { return "data-framer-name" in e } var sV = Ve(function (t, n) { let { name: r, center: i, border: o, _border: s, __portal: a } = t, { props: l, children: c } = kA(t), u = iV(l), f = tl(t), d = eV(t), m = A(null), y = n ?? m, g = { "data-framer-component-type": t.componentType ?? "Frame", "data-framer-cursor": d, "data-framer-highlight": d === "pointer" ? !0 : void 0, "data-layoutid": f, "data-framer-offset-parent-id": Je(t)["data-framer-offset-parent-id"] }; !oV(t) && r && (Je(g)["data-framer-name"] = r); let [b, h] = nV(l), p = Jk(l), v = Ak(p); i && !(h && !v && Ka(p)) ? (u.transformTemplate || (u.transformTemplate = qu(i)), Object.assign(g, Hk(i))) : u.transformTemplate || (u.transformTemplate = void 0), Yu(t, y); let w = dA(t), C = !!V(cs), S = aV(l, p, h, C), R = HO(ce(He, { children: [w ? k(Nk, { alt: t.alt ?? "", image: w, containerSize: h ?? void 0, nodeId: t.id && rg(t.id), layoutId: f }) : null, c, k(pA, { ...s, border: o, layoutId: f })] }), S), E = el(t.as), { size: L, radius: F, shadow: z } = b; return L !== void 0 && (delete b.size, b.height === void 0 && (b.height = L), b.width === void 0 && (b.width = L)), F !== void 0 && (delete b.radius, b.borderRadius = F), z !== void 0 && (delete b.shadow, b.boxShadow = z), ce(E, { ...g, ...u, layoutId: f, style: b, ref: y, children: [R, a] }) }), Cu = Ve(function (t, n) { let { visible: r = !0 } = t; return r ? k(sV, { ...t, ref: n }) : null }); function aV(e, t, n, r) { if (r) return n ? { width: n.width, height: n.height } : 1; let { _usesDOMRect: i } = e, { widthType: o = 0, heightType: s = 0, width: a, height: l } = t; return n && !i ? n : o === 0 && s === 0 && typeof a == "number" && typeof l == "number" ? { width: a, height: l } : i || e.positionFixed || e.positionAbsolute ? 2 : 0 } var ag = "__LAYOUT_TREE_ROOT", eC = x.createContext({ schedulePromoteTree: () => { }, scheduleProjectionDidUpdate: () => { }, initLead: () => { } }), lV = class extends Ee { constructor() { super(...arguments), T(this, "shouldAnimate", !1), T(this, "transition"), T(this, "lead"), T(this, "follow"), T(this, "scheduledPromotion", !1), T(this, "scheduledDidUpdate", !1), T(this, "scheduleProjectionDidUpdate", () => { this.scheduledDidUpdate = !0 }), T(this, "schedulePromoteTree", (e, t, n) => { this.follow = this.lead, this.shouldAnimate = n, this.lead = e, this.transition = t, this.scheduledPromotion = !0 }), T(this, "initLead", (e, t) => { this.follow = this.lead, this.lead = e, this.follow && t && (this.follow.layoutMaybeMutated = !0) }), T(this, "sharedLayoutContext", { schedulePromoteTree: this.schedulePromoteTree, scheduleProjectionDidUpdate: this.scheduleProjectionDidUpdate, initLead: this.initLead }) } getSnapshotBeforeUpdate() { var e; if (!this.scheduledPromotion || !this.lead || !this.follow) return null; let t = !!((e = this.lead) != null && e.layoutMaybeMutated) && !this.shouldAnimate; return this.lead.projectionNodes.forEach(n => { var r; n?.promote({ needsReset: t, transition: this.shouldAnimate ? this.transition : void 0, preserveFollowOpacity: n.options.layoutId === ag && !((r = this.follow) != null && r.isExiting) }) }), this.shouldAnimate ? this.follow.layoutMaybeMutated = !0 : this.scheduleProjectionDidUpdate(), this.lead.layoutMaybeMutated = !1, this.transition = void 0, this.scheduledPromotion = !1, null } componentDidUpdate() { var e, t; if (!this.lead) return null; this.scheduledDidUpdate && ((t = (e = this.lead.rootProjectionNode) == null ? void 0 : e.root) == null || t.didUpdate(), this.scheduledDidUpdate = !1) } render() { return k(eC.Provider, { value: this.sharedLayoutContext, children: this.props.children }) } }, cV = { width: "100%", height: "100%", backgroundColor: "none" }; function uV(e) { return k(gn.div, { layoutId: ag, style: cV, children: e.children }) } var fV = class { constructor(e) { T(this, "sharedIntersectionObserver"), T(this, "callbacks", new WeakMap), document && (this.sharedIntersectionObserver = new IntersectionObserver(this.resizeObserverCallback.bind(this), e)) } resizeObserverCallback(e, t) { for (let n of e) { let r = this.callbacks.get(n.target); r && r([n], t) } } observeElementWithCallback(e, t) { this.sharedIntersectionObserver && (this.sharedIntersectionObserver.observe(e), this.callbacks.set(e, t)) } unobserve(e) { this.sharedIntersectionObserver && (this.sharedIntersectionObserver.unobserve(e), this.callbacks.delete(e)) } get root() { var e; return (e = this.sharedIntersectionObserver) == null ? void 0 : e.root } }, dV = x.createContext(new Map); function hV(e, t, n) { if (typeof IntersectionObserver > "u") return; let r = Rn(() => `${n.rootMargin}`), i = x.useContext(dV), { enabled: o } = n; x.useEffect(() => { var s; let a = e.current; if (!o || !a) return; let l = i.get(r); if (!l || l.root !== ((s = n.root) == null ? void 0 : s.current)) { let { root: c, ...u } = n; l = new fV({ ...u, root: c?.current }), i.set(r, l) } return l.observeElementWithCallback(a, t), () => l?.unobserve(a) }, [o]) } var pV = new Array(100).fill(void 0).map((e, t) => t * .01), mV = x.createContext(null); function gV(e, t, n) { let r = x.useRef({ isInView: !1, hasAnimatedOnce: !1 }), { enabled: i, animateOnce: o, threshold: s, rootMargin: a = "0px 0px 0px 0px" } = n, l = x.useCallback(([c]) => { if (!c) return; let { isInView: u, hasAnimatedOnce: f } = r.current, d = yV(c, s?.y ?? 0); if (d && !u) { if (o && f) return; r.current.hasAnimatedOnce = !0, r.current.isInView = !0, t(!0); return } if (!d && u) { if (r.current.isInView = !1, o) return; t(!1); return } }, [o, s?.y, t]); hV(e, l, { threshold: pV, rootMargin: a, enabled: i ?? !0 }) } function vV(e, t) { return t.height === 0 ? 0 : e.height / Math.min(t.height, ft.innerHeight) } function yV({ boundingClientRect: e, intersectionRect: t, isIntersecting: n }, r) { return e.height === 0 ? n : n && vV(t, e) >= r } var nj = Zn(Wu(), 1); var ij = Zn(Wu(), 1); var wS = (e, t) => Object.prototype.hasOwnProperty.call(e, t), Ar = Symbol("private"), am = (() => { function e(t = {}, n = !1, r = !0) { let i = { [Ar]: { makeAnimatables: n, observeAnimatables: r, observers: new Rk, reset() { for (let s in o) if (wS(o, s)) { let a = wS(t, s) ? Je(t)[s] : void 0; a !== void 0 ? o[s] = a : delete o[s] } }, transactions: new Set } }, o = new Proxy(i, xV); return Object.assign(o, t), o } return e.resetObject = t => t[Ar].reset(), e.addObserver = (t, n) => t[Ar].observers.add(n), e })(), bV = class { constructor() { T(this, "set", (e, t, n, r) => { if (t === Ar) return !1; let i = e[Ar], o, s; if (Nn(n) ? (o = n, s = o.get()) : s = n, i.makeAnimatables && typeof n != "function" && typeof n != "object" && !o && (o = rt(n)), i.observeAnimatables && o) { let u = i.transactions; o.onUpdate({ update: (f, d) => { d && u.add(d), i.observers.notify({ value: r }, d) }, finish: f => { u.delete(f) && i.observers.finishTransaction(f) } }) } let a = !1, l = !0, c = Je(e)[t]; if (c !== void 0) { Nn(c) ? (l = c.get() !== s, c.set(s)) : (l = c !== s, Je(e)[t] = s); let u = s !== null && typeof s == "object"; (Array.isArray(s) || u) && (l = !0), a = !0 } else o && (n = o), a = Reflect.set(e, t, n); return l && i.observers.notify({ value: r }), a }), T(this, "get", (e, t, n) => { if (t === Ar) return Je(e)[t]; let r = Reflect.get(e, t, n); return typeof r == "function" ? r.bind(n) : r }) } deleteProperty(e, t) { let n = Reflect.deleteProperty(e, t); return e[Ar].observers.notify({ value: e }), n } ownKeys(e) { let t = Reflect.ownKeys(e), n = t.indexOf(Ar); return n !== -1 && t.splice(n, 1), t } getOwnPropertyDescriptor(e, t) { if (t !== Ar) return Reflect.getOwnPropertyDescriptor(e, t) } }, xV = new bV; var wV = "opacity"; function SV(e) { return wV in e } function kV(e, t) { if (!SV(e)) return; let n = rt.getNumber(e.opacity); n !== 1 && (t.opacity = n) } function CV(e) { let t = []; if (e && e.length) { let n = e.map(r => `drop-shadow(${r.x}px ${r.y}px ${r.blur}px ${r.color})`); t.push(...n) } return t } function tC(e, t) { if (!e.shadows || e.shadows.length === 0) return; let n = e.shadows.map(r => `${r.x}px ${r.y}px ${r.blur}px ${r.color}`).join(", "); n && (t.textShadow = n) } function TV(e, t) { let n = []; J(e.brightness) && n.push(`brightness(${e.brightness / 100})`), J(e.contrast) && n.push(`contrast(${e.contrast / 100})`), J(e.grayscale) && n.push(`grayscale(${e.grayscale / 100})`), J(e.hueRotate) && n.push(`hue-rotate(${e.hueRotate}deg)`), J(e.invert) && n.push(`invert(${e.invert / 100})`), J(e.saturate) && n.push(`saturate(${e.saturate / 100})`), J(e.sepia) && n.push(`sepia(${e.sepia / 100})`), J(e.blur) && n.push(`blur(${e.blur}px)`), e.dropShadows && n.push(...CV(e.dropShadows)), n.length !== 0 && (t.filter = t.WebkitFilter = n.join(" ")) } function EV(e, t) { J(e.backgroundBlur) && (t.backdropFilter = t.WebkitBackdropFilter = `blur(${e.backgroundBlur}px)`) } function lg(e, t) { EV(e, t), TV(e, t) } var RV = class extends Ee { constructor() { super(...arguments), T(this, "layoutMaybeMutated"), T(this, "projectionNodes", new Map), T(this, "rootProjectionNode"), T(this, "isExiting"), T(this, "shouldPreserveFollowOpacity", e => e.options.layoutId === ag && !this.props.isExiting), T(this, "switchLayoutGroupContext", { register: e => this.addChild(e), deregister: e => this.removeChild(e), transition: this.props.isLead !== void 0 && this.props.animatesLayout ? this.props.transition : void 0, shouldPreserveFollowOpacity: this.shouldPreserveFollowOpacity }) } componentDidMount() { this.props.isLead && this.props.sharedLayoutContext.initLead(this, !!this.props.animatesLayout) } shouldComponentUpdate(e) { let { isLead: t, isExiting: n, isOverlayed: r, animatesLayout: i, transition: o, sharedLayoutContext: s } = e; if (this.isExiting = n, t === void 0) return !0; let a = !this.props.isLead && !!t, l = this.props.isExiting && !n, c = a || l, u = !!this.props.isLead && !t, f = this.props.isOverlayed !== r; return (c || u) && this.projectionNodes.forEach(d => d?.willUpdate()), c ? s.schedulePromoteTree(this, o, !!i) : f && s.scheduleProjectionDidUpdate(), !!c && !!i } addChild(e) { let t = e.options.layoutId; t && (this.projectionNodes.set(t, e), this.setRootChild(e)) } setRootChild(e) { if (!this.rootProjectionNode) return this.rootProjectionNode = e; this.rootProjectionNode = this.rootProjectionNode.depth < e.depth ? this.rootProjectionNode : e } removeChild(e) { let t = e.options.layoutId; t && this.projectionNodes.delete(t) } render() { return k(Ll.Provider, { value: this.switchLayoutGroupContext, children: this.props.children }) } }, PV = e => { let t = x.useContext(eC); return k(RV, { ...e, sharedLayoutContext: t }) }, _V = x.createContext(!0); function FV() { return new Map } function IV() { return Rn(FV) } var LV = ke({ register: () => { }, deregister: () => { } }), MV = ({ isCurrent: e, isOverlayed: t, children: n }) => { let r = IV(), i = se(a => { if (r.has(a)) { console.warn("NavigationTargetWrapper: already registered"); return } r.set(a, void 0) }, [r]), o = se(a => { let l = r.get(a); l?.(), r.delete(a) }, [r]), s = A({ register: i, deregister: o }).current; return N(() => (r.forEach((a, l) => { let c = l(e, t); r.set(l, ki(c) ? c : void 0) }), () => { r.forEach((a, l) => { a && (a(), r.set(l, void 0)) }) }), [e, t, r]), k(LV.Provider, { value: s, children: n }) }; var lm = x.memo(function ({ isLayeredContainer: t, isCurrent: n, isPrevious: r, isOverlayed: i = !1, visible: o, transitionProps: s, children: a, backdropColor: l, onTapBackdrop: c, backfaceVisible: u, exitBackfaceVisible: f, animation: d, exitAnimation: m, instant: y, initialProps: g, exitProps: b, position: h = { top: 0, right: 0, bottom: 0, left: 0 }, withMagicMotion: p, index: v, areMagicMotionLayersPresent: w, id: C, isInitial: S }) { let R = lb(), E = V(go), { persistLayoutIdCache: L } = V(is), F = A({ wasCurrent: void 0, wasPrevious: !1, wasBeingRemoved: !1, wasReset: !0, origins: SS({}, g, s) }), z = A(null), D = E !== null && !E.isPresent; n && F.current.wasCurrent === void 0 && L(), N(() => { if (t || !R) return; if (D) { F.current = { ...F.current, wasBeingRemoved: D }; return } let { wasPrevious: pe, wasCurrent: ie } = F.current, ht = n && !ie || !D && F.current.wasBeingRemoved && n, _e = r && !pe, Lt = SS(F.current.origins, g, s), Se = F.current.wasReset; ht || _e ? (R.stop(), R.start({ zIndex: v, ...Lt, ...s }), Se = !1) : Se === !1 && (R.stop(), R.set({ zIndex: v, ...Qi, opacity: 0 }), Se = !0), F.current = { wasCurrent: !!n, wasPrevious: !!r, wasBeingRemoved: !1, wasReset: Se, origins: Lt } }, [n, r, D]); let K = y ? { type: !1 } : "velocity" in d ? { ...d, velocity: 0 } : d, U = y ? { type: !1 } : m || d, $ = { ...h }; ($.left === void 0 || $.right === void 0) && ($.width = "auto"), ($.top === void 0 || $.bottom === void 0) && ($.height = "auto"); let ee = (kS(s) || kS(g)) && (t || n || r) ? 1200 : void 0, te = { ...Qi, ...F.current.origins }, q = t ? { initial: { ...te, ...g }, animate: { ...te, ...s, transition: K }, exit: { ...te, ...b, transition: d } } : { animate: R, exit: { ...te, ...b, transition: U } }, ne = !(D || w === !1), be = !!n && ne; return ce(Cu, { "data-framer-component-type": "NavigationContainerWrapper", width: "100%", height: "100%", style: { position: "absolute", transformStyle: "flat", backgroundColor: "transparent", overflow: "hidden", zIndex: t || D || n && p ? v : void 0, pointerEvents: void 0, visibility: o ? "visible" : "hidden", perspective: ee }, children: [t && k(Cu, { width: "100%", height: "100%", "data-framer-component-type": "NavigationContainerBackdrop", transition: d, initial: { opacity: y && o ? 1 : 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, backgroundColor: l || "transparent", onTap: D ? void 0 : c }), k(Cu, { ...$, ...q, transition: { default: K, originX: { type: !1 }, originY: { type: !1 }, originZ: { type: !1 } }, backgroundColor: "transparent", backfaceVisible: D ? f : u, "data-framer-component-type": "NavigationContainer", "data-framer-is-current-navigation-target": !!n, style: { pointerEvents: void 0, opacity: n && S || t || n && p ? 1 : 0 }, "data-is-present": ne ? void 0 : !1, ref: z, children: k(mV.Provider, { value: z, children: k(_V.Provider, { value: be, children: k(MV, { isCurrent: be, isOverlayed: i, children: k(PV, { isLead: n, animatesLayout: !!p, transition: K, isExiting: !ne, isOverlayed: i, id: C, children: a }) }) }) }) })] }) }, OV); function OV(e, t) { return !(t.isCurrent === void 0 || e.isCurrent !== t.isCurrent || e.isPrevious !== t.isPrevious || t.isCurrent && e.isOverlayed !== t.isOverlayed) } function SS(e, t, n) { let r = { ...e }; return t && (J(t.originX) && (r.originX = t.originX), J(t.originY) && (r.originY = t.originY), J(t.originZ) && (r.originZ = t.originZ)), n && (J(n.originX) && (r.originX = n.originX), J(n.originY) && (r.originY = n.originY), J(n.originZ) && (r.originZ = n.originZ)), r } function kS(e) { var t, n, r; if (!e || !("rotateX" in e || "rotateY" in e || "z" in e)) return !1; let o = e.rotateX !== 0 || e.rotateY !== 0 || e.z !== 0, s = ((t = e?.transition) == null ? void 0 : t.rotateX.from) !== 0 || ((n = e?.transition) == null ? void 0 : n.rotateY.from) !== 0 || ((r = e?.transition) == null ? void 0 : r.z.from) !== 0; return o || s } var Qi = { x: 0, y: 0, z: 0, rotate: 0, rotateX: 0, rotateY: 0, rotateZ: 0, scale: 1, scaleX: 1, scaleY: 1, scaleZ: 1, skew: 0, skewX: 0, skewY: 0, originX: .5, originY: .5, originZ: 0, opacity: 1 }, DV = class { constructor() { T(this, "warning", () => { Ba("The Navigator API is only available inside of Framer: https://www.framer.com/") }), T(this, "goBack", () => this.warning()), T(this, "instant", () => this.warning()), T(this, "fade", () => this.warning()), T(this, "push", () => this.warning()), T(this, "modal", () => this.warning()), T(this, "overlay", () => this.warning()), T(this, "flip", () => this.warning()), T(this, "customTransition", () => this.warning()), T(this, "magicMotion", () => this.warning()) } }, AV = new DV, VV = ke(AV), ct = { Fade: { exit: { opacity: 0 }, enter: { opacity: 0 } }, PushLeft: { exit: { x: "-30%" }, enter: { x: "100%" } }, PushRight: { exit: { x: "30%" }, enter: { x: "-100%" } }, PushUp: { exit: { y: "-30%" }, enter: { y: "100%" } }, PushDown: { exit: { y: "30%" }, enter: { y: "-100%" } }, Instant: { animation: { type: !1 }, enter: { opacity: 0 } }, Modal: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { center: !0 }, enter: { opacity: 0, scale: 1.2 } }, OverlayLeft: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { right: 0, top: 0, bottom: 0 }, enter: { x: "100%" } }, OverlayRight: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { left: 0, top: 0, bottom: 0 }, enter: { x: "-100%" } }, OverlayUp: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { bottom: 0, left: 0, right: 0 }, enter: { y: "100%" } }, OverlayDown: { overCurrentContext: !0, goBackOnTapOutside: !0, position: { top: 0, left: 0, right: 0 }, enter: { y: "-100%" } }, FlipLeft: { backfaceVisible: !1, exit: { rotateY: -180 }, enter: { rotateY: 180 } }, FlipRight: { backfaceVisible: !1, exit: { rotateY: 180 }, enter: { rotateY: -180 } }, FlipUp: { backfaceVisible: !1, exit: { rotateX: 180 }, enter: { rotateX: -180 } }, FlipDown: { backfaceVisible: !1, exit: { rotateX: -180 }, enter: { rotateX: 180 } }, MagicMotion: { withMagicMotion: !0 } }; function BV(e) { switch (e && e.appearsFrom ? e.appearsFrom : "right") { case "right": return ct.PushLeft; case "left": return ct.PushRight; case "bottom": return ct.PushUp; case "top": return ct.PushDown } } function zV(e) { switch (e && e.appearsFrom ? e.appearsFrom : "bottom") { case "right": return ct.OverlayLeft; case "left": return ct.OverlayRight; case "bottom": return ct.OverlayUp; case "top": return ct.OverlayDown } } function $V(e) { switch (e && e.appearsFrom ? e.appearsFrom : "bottom") { case "right": return ct.FlipLeft; case "left": return ct.FlipRight; case "bottom": return ct.FlipUp; case "top": return ct.FlipDown } } var NV = () => ({ current: -1, previous: -1, currentOverlay: -1, previousOverlay: -1, visualIndex: 0, overlayItemId: 0, historyItemId: 0, history: [], overlayStack: [], containers: {}, containerIndex: {}, containerVisualIndex: {}, containerIsRemoved: {}, transitionForContainer: {}, previousTransition: null }); function CS(e, t) { switch (t.type) { case "addOverlay": return jV(e, t.transition, t.component); case "removeOverlay": return WV(e); case "add": return nC(e, t.key, t.transition, t.component); case "remove": return rC(e); case "update": return HV(e, t.key, t.component); case "back": return UV(e); case "forward": return GV(e); default: return } } function HV(e, t, n) { return { ...e, containers: { ...e.containers, [t]: n } } } function jV(e, t, n) { let r = e.overlayStack[e.currentOverlay]; if (r && r.component === n) return; let i = e.overlayItemId + 1, o = [...e.overlayStack, { key: `stack-${i}`, component: n, transition: t }]; return { ...e, overlayStack: o, overlayItemId: i, currentOverlay: Math.max(0, Math.min(e.currentOverlay + 1, o.length - 1)), previousOverlay: e.currentOverlay } } function WV(e) { return { ...e, overlayStack: [], currentOverlay: -1, previousOverlay: e.currentOverlay } } function nC(e, t, n, r) { e.containers[t] || (e.containers[t] = r), e.history = e.history.slice(0, e.current + 1), e.visualIndex = Math.max(e.history.length, 0); let i = e.history[e.history.length - 1], o = i && i.key === t; if (e.overlayStack = [], o && e.currentOverlay > -1) return { ...e, currentOverlay: -1, previousOverlay: e.currentOverlay }; if (o) return; let s = e.containerVisualIndex[t], a = e.containerIsRemoved[t], l = i?.key && n.withMagicMotion ? KV(t, s, a, e.history) : !0; e.history.push({ key: t, transition: n, visualIndex: l ? Math.max(e.visualIndex, 0) : e.containerVisualIndex[t] }); let c = e.current + 1, u = e.current; for (let y in e.containerIndex) e.containerIndex[y] === c && (e.containerIndex[y] = YV(y, e.history)); e.containerIndex[t] = c; let { containerVisualIndex: f, containerIsRemoved: d } = qV(e, t, l), m = iC(c, u, e.history, e.containerIndex, e.transitionForContainer); return { ...e, current: c, previous: u, containerVisualIndex: f, containerIsRemoved: d, transitionForContainer: m, previousTransition: null, currentOverlay: -1, historyItemId: e.historyItemId + 1, previousOverlay: e.currentOverlay } } function UV(e) { let t = { ...e.containers }, n = rC(e); if (n) return n.containers = t, n } function GV(e) { let t = e.history[e.current + 1]; if (!t) return; let { key: n, transition: r, component: i } = t, o = [...e.history], s = nC(e, n, r, i); if (s) return s.history = o, s } function rC(e) { let t = [...e.history.slice(0, e.current + 1)]; if (t.length === 1) return; let n = t.pop(); if (!n) return; let r = t[t.length - 1]; H(r, "The navigation history must have at least one component"), e.containerIndex[r.key] = t.length - 1, t.every(d => d.key !== n.key) && delete e.containers[n.key]; let o = e.current - 1, s = e.current, { containerIsRemoved: a, containerVisualIndex: l, previousTransition: c, visualIndex: u } = XV(e, r, n), f = iC(o, s, e.history, e.containerIndex, e.transitionForContainer); return { ...e, current: o, previous: s, containerIsRemoved: a, containerVisualIndex: l, previousTransition: c, visualIndex: u, transitionForContainer: f } } function qV(e, t, n) { let r = { containerVisualIndex: { ...e.containerVisualIndex }, containerIsRemoved: { ...e.containerIsRemoved } }; if (n) r.containerVisualIndex[t] = e.history.length - 1, r.containerIsRemoved[t] = !1; else { let i = e.containerVisualIndex[t]; for (let [o, s] of Object.entries(e.containerVisualIndex)) i !== void 0 && s > i && (r.containerIsRemoved[o] = !0) } return r } function XV(e, t, n) { let r = [t.key, n.key], i = e.history[e.history.length - 2], o = e.previousTransition === null ? null : { ...e.previousTransition }, s = { containerIsRemoved: { ...e.containerIsRemoved }, containerVisualIndex: { ...e.containerVisualIndex }, previousTransition: o, visualIndex: e.visualIndex }; i && r.push(i.key); let a = e.containerVisualIndex[t.key], l = e.containerVisualIndex[n.key], c = a !== void 0 && l !== void 0 && a <= l || t.visualIndex !== void 0 && t.visualIndex < e.history.length - 1, u = t.visualIndex; return c ? (s.containerIsRemoved[n.key] = !0, s.containerVisualIndex[t.key] = u !== void 0 ? u : e.history.length - 1) : (s.visualIndex = e.visualIndex + 1, s.containerVisualIndex[t.key] = e.visualIndex + 1), n.transition.withMagicMotion && (s.previousTransition = n.transition || null), e.containerIsRemoved[t.key] = !1, s } function YV(e, t) { var n; for (let r = t.length; r > t.length; r--)if (((n = t[r]) == null ? void 0 : n.key) === e) return r; return -1 } function iC(e, t, n, r, i) { let o = { ...i }; for (let [s, a] of Object.entries(r)) { let l = QV(a, { current: e, previous: t, history: n }); l && (o[s] = l) } return o } function KV(e, t, n, r) { return n || t === void 0 ? !0 : t === 0 ? !1 : r.slice(t, r.length).findIndex(s => s.key === e) > -1 ? !0 : !(r.slice(0, t - 1).findIndex(s => s.key === e) > -1) } function QV(e, t) { let { current: n, previous: r, history: i } = t; if (!(e !== n && e !== r)) { if (e === n && n > r) { let o = i[e]; return gu("enter", o?.transition.enter, o?.transition.animation) } if (e === r && n > r) { let o = i[e + 1]; return gu("exit", o?.transition.exit, o?.transition.animation) } if (e === n && n < r) { let o = i[e + 1]; return gu("enter", o?.transition.exit, o?.transition.animation) } if (e === r && n < r) { let o = i[e]; return gu("exit", o?.transition.enter, o?.transition.animation) } } } var ZV = no(Qi); function gu(e, t, n) { let r = {}, i = {}; return ZV.forEach(o => { r[o] = Qi[o], i[o] = { ...n, from: Qi[o] } }), t && Object.keys(t).forEach(o => { if (t[o] === void 0) return; let s = t[o], a = typeof t[o] == "string" ? `${Je(Qi)[o]}%` : Je(Qi)[o]; Je(r)[o] = e === "enter" ? a : s, i[o] = { ...n, from: e === "enter" ? s : a, velocity: 0 } }), { ...r, transition: { ...i } } } var JV = x.createContext(void 0); var oC = x.createContext(void 0), e3 = (() => { var e, t, n, r, i, o, s, a, l; return t = class extends Ee { constructor(c) { var u; super(c), en(this, n), en(this, i), en(this, a), en(this, e, null), T(this, "state", NV()), en(this, s, b => { if (!this.props.enabled && this.state.history.length > 0) return; let h = CS(this.state, b); if (!h) return; let { skipLayoutAnimation: p } = this.props, v = h.history[h.current], w = b.type === "add" && b.transition.withMagicMotion || b.type === "forward" && v?.transition.withMagicMotion || b.type === "remove" && !!h.previousTransition, C = () => { var S; this.setState(h), v?.key && ((S = this.context) == null || S.call(this, v.key)) }; p && !w ? p(C) : C() }), T(this, "goBack", () => { var b; if (!Wt(this, i, o).call(this)) return Wf(this, e, ((b = globalThis.event) == null ? void 0 : b.timeStamp) || null), this.state.currentOverlay !== -1 ? ue(this, s).call(this, { type: "removeOverlay" }) : ue(this, s).call(this, { type: "remove" }) }); let f = this.props.children; if (!f || !Su(f) || !wu(f)) return; let d = { ...ct.Instant }, y = { type: "add", key: ((u = f.key) == null ? void 0 : u.toString()) || `stack-${this.state.historyItemId + 1}`, transition: d, component: f }, g = CS(this.state, y); g && (this.state = g) } componentDidMount() { var c; let u = this.state.history[this.state.current]; u && ((c = this.context) == null || c.call(this, u.key)) } UNSAFE_componentWillReceiveProps(c) { var u; let f = c.children; if (!Su(f) || !wu(f)) return; let d = (u = f.key) == null ? void 0 : u.toString(); d && (this.state.history.length === 0 ? Wt(this, a, l).call(this, f, ct.Instant) : ue(this, s).call(this, { type: "update", key: d, component: f })) } componentWillUnmount() { var c, u; (u = (c = this.props).resetProjection) == null || u.call(c) } instant(c) { Wt(this, a, l).call(this, c, ct.Instant, void 0) } fade(c, u) { Wt(this, a, l).call(this, c, ct.Fade, u) } push(c, u) { Wt(this, a, l).call(this, c, BV(u), u) } modal(c, u) { Wt(this, a, l).call(this, c, ct.Modal, u) } overlay(c, u) { Wt(this, a, l).call(this, c, zV(u), u) } flip(c, u) { Wt(this, a, l).call(this, c, $V(u), u) } magicMotion(c, u) { Wt(this, a, l).call(this, c, ct.MagicMotion, u) } customTransition(c, u) { Wt(this, a, l).call(this, c, u) } render() { var c, u, f, d, m; let y = Wt(this, n, r).call(this, { overCurrentContext: !1 }), g = Wt(this, n, r).call(this, { overCurrentContext: !0 }), b = t3(g), h = g.current > -1, p = this.state.history.length === 1, v = []; for (let [C, S] of Object.entries(this.state.containers)) { let R = this.state.containerIndex[C]; H(R !== void 0, "Container's index must be registered"); let E = this.state.containerVisualIndex[C]; H(E !== void 0, "Container's visual index must be registered"); let L = this.state.containerIsRemoved[C], F = this.state.history[R], z = this.state.transitionForContainer[C], D = R === this.state.current, K = R === this.state.previous, U = D ? !1 : L, $ = ((c = F?.transition) == null ? void 0 : c.withMagicMotion) || D && !!this.state.previousTransition; v.push(k(lm, { id: C, index: E, isInitial: p, isCurrent: D, isPrevious: K, isOverlayed: h, visible: D || K, position: (u = F?.transition) == null ? void 0 : u.position, instant: ES(R, y), transitionProps: z, animation: TS(R, y), backfaceVisible: l3(R, y), exitAnimation: (f = F?.transition) == null ? void 0 : f.animation, exitBackfaceVisible: (d = F?.transition) == null ? void 0 : d.backfaceVisible, exitProps: (m = F?.transition) == null ? void 0 : m.enter, withMagicMotion: $, areMagicMotionLayersPresent: U ? !1 : void 0, children: k(uV, { children: RS({ component: S, transition: F?.transition }) }) }, C)) } let w = this.state.overlayStack.map((C, S) => k(lm, { isLayeredContainer: !0, isCurrent: S === this.state.currentOverlay, position: C.transition.position, initialProps: a3(S, g), transitionProps: c3(S, g), instant: ES(S, g, !0), animation: TS(S, g), exitProps: C.transition.enter, visible: u3(S, g), backdropColor: o3(C.transition), backfaceVisible: s3(S, g), onTapBackdrop: f3(C.transition, this.goBack), index: this.state.current + 1 + S, children: RS({ component: C.component, transition: C.transition }) }, C.key)); return k(Cu, { "data-framer-component-type": "NavigationRoot", top: 0, left: 0, width: "100%", height: "100%", position: "relative", style: { overflow: "hidden", backgroundColor: "unset", pointerEvents: void 0, ...this.props.style }, children: k(VV.Provider, { value: this, children: ce(oC.Provider, { value: p, children: [k(lm, { isLayeredContainer: !0, position: void 0, initialProps: {}, instant: !1, transitionProps: n3(b), animation: r3(b), backfaceVisible: i3(b), visible: !0, backdropColor: void 0, onTapBackdrop: void 0, index: 0, children: k(bO, { children: k(lV, { children: k(Ld, { presenceAffectsLayout: !1, children: v }) }) }) }), k(Ld, { children: w })] }) }) }) } }, e = new WeakMap, n = new WeakSet, r = function (c) { let { current: u, previous: f, currentOverlay: d, previousOverlay: m } = this.state; return c.overCurrentContext ? { current: d, previous: m, history: this.state.overlayStack } : { current: u, previous: f, history: this.state.history } }, i = new WeakSet, o = function () { return globalThis.event ? ue(this, e) === globalThis.event.timeStamp : !1 }, s = new WeakMap, a = new WeakSet, l = function (c, u, f) { var d, m; if (Wt(this, i, o).call(this) || (Wf(this, e, ((d = globalThis.event) == null ? void 0 : d.timeStamp) || null), !c || !Su(c) || !wu(c))) return; let y = { ...u, ...f }; if (!!y.overCurrentContext) return ue(this, s).call(this, { type: "addOverlay", transition: y, component: c }); let b = ((m = c.key) == null ? void 0 : m.toString()) || `stack-${this.state.historyItemId + 1}`; ue(this, s).call(this, { type: "add", key: b, transition: y, component: c }) }, T(t, "defaultProps", { enabled: !0 }), T(t, "contextType", JV), t })(), sC = { stiffness: 500, damping: 50, restDelta: 1, type: "spring" }; function t3(e) { let t, n; return e.current !== -1 ? t = e.history[e.current] : n = e.history[e.previous], { currentOverlayItem: t, previousOverlayItem: n } } function n3({ currentOverlayItem: e }) { return e && e.transition.exit } function r3({ currentOverlayItem: e, previousOverlayItem: t }) { return e && e.transition.animation ? e.transition.animation : t && t.transition.animation ? t.transition.animation : sC } function i3({ currentOverlayItem: e, previousOverlayItem: t }) { return e ? e.transition.backfaceVisible : t && t.transition.backfaceVisible } function o3(e) { if (e.backdropColor) return e.backdropColor; if (e.overCurrentContext) return "rgba(4,4,15,.4)" } function s3(e, t) { let { current: n, history: r } = t; if (e === n) { let i = r[e]; return i && i.transition ? i.transition.backfaceVisible : !0 } else if (e < n) { let i = r[e + 1]; return i && i.transition ? i.transition.backfaceVisible : !0 } else { let i = r[e]; return i && i.transition ? i.transition.backfaceVisible : !0 } } function a3(e, t) { let n = t.history[e]; if (n) return n.transition.enter } function l3(e, t) { var n, r, i, o; let { current: s, previous: a, history: l } = t; return e === a && s > a || e === s && s < a ? (r = (n = l[e + 1]) == null ? void 0 : n.transition) == null ? void 0 : r.backfaceVisible : (o = (i = l[e]) == null ? void 0 : i.transition) == null ? void 0 : o.backfaceVisible } function c3(e, t) { let { current: n, history: r } = t; if (e !== n) if (e < n) { let i = r[e + 1]; if (i && i.transition) return i.transition.exit } else { let i = r[e]; if (i && i.transition) return i.transition.enter } } function TS(e, t) { let { current: n, previous: r, history: i } = t, o = r > n ? r : n; if (e < o) { let s = i[e + 1]; if (s && s.transition.animation) return s.transition.animation } else if (e !== o) { let s = i[e]; if (s && s.transition.animation) return s.transition.animation } else { let s = i[e]; if (s?.transition.animation) return s.transition.animation } return sC } function ES(e, t, n) { let { current: r, previous: i, history: o } = t; return !!(n && o.length > 1 || e !== i && e !== r || r === i) } function u3(e, t) { let { current: n, previous: r } = t; return e > n && e > r ? !1 : e === n } function RS(e) { return x.Children.map(e.component, n => { var r; if (!Su(n) || !wu(n) || !n.props) return n; let i = { style: n.props.style ?? {} }, o = (r = e?.transition) == null ? void 0 : r.position, s = !o || o.left !== void 0 && o.right !== void 0, a = !o || o.top !== void 0 && o.bottom !== void 0, l = "style" in n.props ? Me(n.props.style) : !0; return s && ("width" in n.props && (i.width = "100%"), l && (i.style.width = "100%")), a && ("height" in n.props && (i.height = "100%"), l && (i.style.height = "100%")), x.cloneElement(n, i) }) } function f3(e, t) { if (e.goBackOnTapOutside !== !1) return t } function d3(e) { let t = fb(), n = Vd(); return x.useInsertionEffect(() => { Za() }, []), k(e3, { ...e, resetProjection: t, skipLayoutAnimation: n, children: e.children }) } var xj = Zn(Wu(), 1); var Tj = Zn(Um(), 1); function h3(e, t) { let n, r = (...o) => { ft.clearTimeout(n), n = ft.setTimeout(e, t, ...o) }, i = () => { ft.clearTimeout(n) }; return r.cancel = i, r } function Du(...e) { return e.filter(Boolean).join(" ") } var p3 = (() => { function e(t = {}) { let n = am(t, !1, !1); return e.addData(n), n } return e._stores = [], e.addData = t => { e._stores.push(t) }, e.reset = () => { e._stores.forEach(t => am.resetObject(t)) }, e.addObserver = (t, n) => am.addObserver(t, n), e })(), cm = p3; var m3 = { update: 0 }, g3 = x.createContext({ update: NaN }); var v3 = class extends Ee { constructor() { super(...arguments), T(this, "observers", []), T(this, "state", m3), T(this, "taskAdded", !1), T(this, "frameTask", () => { this.setState({ update: this.state.update + 1 }), this.taskAdded = !1 }), T(this, "observer", () => { this.taskAdded || (this.taskAdded = !0, Fk.addFrameTask(this.frameTask)) }) } componentWillUnmount() { this.observers.map(e => e()), cm.reset() } render() { let { children: e } = this.props; return this.observers.map(t => t()), this.observers = [], cm._stores.forEach(t => { let n = cm.addObserver(t, this.observer); this.observers.push(n) }), k(g3.Provider, { value: { ...this.state }, children: e }) } }, Qj = Zn(Wu(), 1); var aC = "__framer__", y3 = (() => aC.length)(); function b3(e) { if (e.startsWith(aC)) return e.substr(y3) } var dr = ["opacity", "x", "y", "scale", "rotate", "rotateX", "rotateY", "skewX", "skewY", "transformPerspective"], Au = e => ({ x: Ue(e?.x ?? 0), y: Ue(e?.y ?? 0), opacity: Ue(e?.opacity ?? 1), scale: Ue(e?.scale ?? 1), rotate: Ue(e?.rotate ?? 0), rotateX: Ue(e?.rotateX ?? 0), rotateY: Ue(e?.rotateY ?? 0), skewX: Ue(e?.skewX ?? 0), skewY: Ue(e?.skewY ?? 0), transformPerspective: Ue(e?.transformPerspective ?? 0) }), Ke = { x: 0, y: 0, scale: 1, opacity: 1, rotate: 0, rotateX: 0, rotateY: 0, skewX: 0, skewY: 0, transformPerspective: 0 }; function lC(e) { return e in Ke } function cC(e, t) { let n = Rn(() => ({ values: Au(t ? e : void 0) })); return x.useEffect(() => { if (!t) for (let r of dr) { let i = Ke[r]; it(i) || n.values[r].set(i) } }, [n, t]), n } var x3 = new Set(["loopEffectEnabled", "loopTransition", "loop", "loopRepeatType", "loopRepeatDelay"]), w3 = () => { let e = A(); return N(() => () => { clearTimeout(e.current) }, []), async t => new Promise(n => { e.current = setTimeout(() => { n(!0) }, t * 1e3) }) }; function S3({ loopEffectEnabled: e, loopRepeatDelay: t, loopTransition: n, loopRepeatType: r, loop: i }) { let o = Li(), s = Rn(() => ({ values: Au() })), a = x.useRef(!1), l = w3(), c = async () => { if (!i) return; let d = n || void 0, m = a.current && r === "mirror", y = m ? Ke : i, g = m ? i : Ke; return a.current = !a.current, Promise.all(dr.map(b => { if (!(o && b !== "opacity")) return s.values[b].set(g[b] ?? Ke[b]), new Promise(h => { let p = { ...d, onComplete: () => h() }; tr(s.values[b], y[b] ?? g[b], p) }) })) }, u = async () => { e && (await c(), await l(t ?? 0), await u()) }, f = se(() => { dr.forEach(d => { s.values[d].stop() }), dr.forEach(d => { s.values[d].set(Ke[d]) }), a.current = !1 }, [s]); return x.useEffect(() => (e && i ? u() : f(), () => f()), [e]), s } function k3(e, t, n, r, i) { let o = n / 100 - 1, s = i ? (t - r) * o : 0, a = -e * o; return s + a } var C3 = new Set(["speed", "adjustPosition", "offset", "parallaxTransformEnabled"]); function T3(e, t, n) { let { speed: r = 100, offset: i = 0, adjustPosition: o = !1, parallaxTransformEnabled: s } = e, a = x.useRef(null), l = Li(), c = x.useCallback(y => a.current === null || r === 100 ? 0 : k3(y, a.current, r, i, o), [a, r, i, o]); x.useLayoutEffect(() => { Y.read(() => { var y, g; a.current = ((g = (y = t.current) == null ? void 0 : y.getBoundingClientRect()) == null ? void 0 : g.top) ?? 0 }), Y.update(() => { f.set(c(u.get())), o && d.set(n ?? "initial") }) }, [t, a, o]); let { scrollY: u } = tb(), f = Dt(u, c), d = er(o && a.current === null ? "hidden" : n), m = er(0); return { values: { y: l || !s ? m : f }, style: s ? { visibility: d } : void 0 } } function E3(e) { if (!(fe(e) || !Me(e))) return e?.transition } async function um(e, t, n, r, i, o) { let s = E3(e); return Promise.all(dr.map(a => new Promise(l => { if (n && a !== "opacity") return l(); let c = t.values[a]; c.stop(); let u = Me(e) ? e?.[a] ?? Ke[a] : Ke[a]; if (Oe(u) && (u = u.get()), !Ae(u)) return l(); let f = kr.get(r.current); f && f.setBaseTarget(a, u); let d; if (fe(i) && !c?.hasAnimated && ft.MotionHandoffAnimation) { let m = ft.MotionHandoffAnimation(i, a, Y); m && (d = m) } o ? c.set(u) : tr(c, u, { ...s, velocity: 0, startTime: d, onComplete: () => l() }) }))) } var R3 = new Set(["presenceInitial", "presenceAnimate", "presenceExit"]); function P3({ initial: e, animate: t, exit: n, presenceInitial: r, presenceAnimate: i, presenceExit: o }, s, a, l, c) { let u = r ?? e, f = i ?? t, d = o ?? n, [m, y] = Sd(), g = A({ lastPresence: !1, lastAnimate: f, hasMounted: !1, running: !1 }), b = Rn(() => { let p = u ?? l; if (!Me(p)) return { values: Au() }; let v = {}; for (let w in p) { let C = Me(p) ? p[w] : void 0; Ae(C) && (v[w] = C) } return { values: Au(v) } }); et(() => { let { hasMounted: p } = g.current; if (p && f) return; let v = kr.get(s.current); if (v) { Object.assign(g.current, { hasMounted: !0 }); for (let w in b.values) { if (!lC(w)) continue; let C = l?.[w]; v.setBaseTarget(w, Ae(C) ? C : Ke[w]) } } }, [f]); let h = Li(); return et(() => { if (!a) { y?.(); return } if (m !== g.current.lastPresence) Object.assign(g.current, { lastPresence: m }), m ? u && f && (Object.assign(g.current, { running: !0 }), um(f, b, h, s, c).then(() => Object.assign(g.current, { running: !1 }))) : d ? (Object.assign(g.current, { running: !0 }), um(d, b, h, s, c).then(() => Object.assign(g.current, { running: !1 })).then(() => y())) : y(); else { let { lastAnimate: p, running: v } = g.current; if (!!qe(f, p) || !f) return; Object.assign(g.current, { lastAnimate: f }), um(f, b, h, s, c, !v).then(() => Object.assign(g.current, { running: !1 })) } }), b } function _3(e, t) { let n = 0, r = e; for (; r && r !== t && r instanceof HTMLElement;)n += r.offsetTop, r = r.offsetParent; return n } var F3 = 1; function uC(e, t = 0, n) { var r; let i = [], o = []; for (let s = e.length; s >= 0; s--) { let { ref: a, offset: l } = e[s] ?? {}; if (!a || !a.current) continue; let u = _3(a.current, document.documentElement) - F3 - (l ?? 0) - t, f = ((r = a.current) == null ? void 0 : r.clientHeight) ?? 0, d = i[i.length - 1], m = Math.max(u + f, 0); i.push(u), o.unshift(Math.max(u, 0), d === void 0 ? m : Math.min(m, Math.max(d - 1, 0))), n?.(s) } return o } function I3(e, t = 0) { return e < t ? "up" : "down" } var L3 = 4; function M3(e, t, n = {}) { let { direction: r, target: i } = e ?? {}, { repeat: o = !0, enabled: s = !0 } = n; x.useEffect(() => { if (!r || !s) return; let a, l = 0, c, u; return wo(({ y: f }) => { if (!o && u === i || f.current > f.scrollLength || f.current < 0) return; let d = I3(f.current, a); a = f.current; let m = d !== c; if (c = d, m) l = f.current; else { if (Math.abs(f.current - l) < L3) return; let g = d === r ? i : void 0; g !== u && t(g), u = g } }) }, [r, o, i, s, t]) } var O3 = new Set(["threshold", "animateOnce", "opacity", "targetOpacity", "x", "y", "scale", "transition", "rotate", "rotateX", "rotateY", "perspective", "enter", "exit", "animate", "styleAppearEffectEnabled", "targets", "scrollDirection"]), D3 = ["animate", "animate"], PS = { inputRange: [], outputRange: [] }; function A3(e, t, n) { let r = uC(e, t), i = [...D3], o = r[0]; if (!Ae(o)) return PS; if (o > 1 && (r.unshift(0, o - 1), i.unshift("initial", "initial")), n) { let s = r.length - 1, a = r[s]; if (!Ae(a)) return PS; r.push(a + 1), i.push("exit") } return { inputRange: r, outputRange: i } } function fm(e) { return { x: e?.x ?? Ke.x, y: e?.y ?? Ke.y, scale: e?.scale ?? Ke.scale, opacity: e?.opacity ?? Ke.opacity, transformPerspective: e?.transformPerspective ?? Ke.transformPerspective, rotate: e?.rotate ?? Ke.rotate, rotateX: e?.rotateX ?? Ke.rotateX, rotateY: e?.rotateY ?? Ke.rotateY, skewX: e?.skewX ?? Ke.skewX, skewY: e?.skewY ?? Ke.skewY, transition: e?.transition ?? void 0 } } function V3({ opacity: e, targetOpacity: t, perspective: n, enter: r, exit: i, animate: o, ...s }) { return x.useMemo(() => ({ initial: r ?? fm({ ...s, opacity: e ?? t ?? 1, transformPerspective: n }), animate: o ?? fm({ opacity: t }), exit: i ?? fm() }), [o, s, r, i, e, t, n]) } function B3(e, t) { let n = Li(), r = V3(e), i = e.styleAppearEffectEnabled, o = cC(i ? r.initial : r.animate, i), s = x.useRef({ isPlaying: !1, scheduledAppearState: void 0, lastAppearState: !e.styleAppearEffectEnabled }), a = x.useRef(), l = x.useCallback(async ({ transition: d, ...m }, y) => { let g = d ?? r.animate.transition ?? e.transition; await a.current, a.current = Promise.all(dr.map(b => { y && o.values[b].set(r.initial[b] ?? Ke[b]); let h = m[b] ?? Ke[b], p = kr.get(t.current); return p && typeof h != "object" && p.setBaseTarget(b, h), new Promise(v => { if (n && b !== "opacity") Ae(h) && o.values[b].set(h), v(); else { let w = { restDelta: b === "scale" ? .001 : void 0, ...g, onComplete: () => v() }; tr(o.values[b], h, w) } }) })) }, []), c = e.animateOnce && s.current.lastAppearState === !0, u = !e.targets && e.styleAppearEffectEnabled && !e.scrollDirection && !c; gV(t, d => { let { isPlaying: m, lastAppearState: y } = s.current; if (m) { s.current.scheduledAppearState = d; return } s.current.scheduledAppearState = void 0, s.current.lastAppearState = d, y !== d && l(d ? r.animate : r.exit, d) }, { enabled: u, animateOnce: !!e.animateOnce, threshold: { y: e.threshold } }); let f = e.targets && i && !e.scrollDirection; return x.useEffect(() => { if (!f) return; let d = { initial: !0 }, m = "initial"; return wo(({ y }) => { let { targets: g } = e; if (!g || !g[0] || g[0].ref && !g[0].ref.current) return; let { inputRange: b, outputRange: h } = A3(g, (e.threshold ?? 0) * y.containerLength, !!e.exit); if (b.length === 0 || b.length !== h.length) return; let p = Vs(y.current, b, h); if (e.animateOnce && d[p] || (d[p] = !0, m === p)) return; m = p; let v = Je(r)[p]; v && l(v) }) }, [f]), M3(e.scrollDirection, d => l(d ?? r.animate), { enabled: i, repeat: !e.animateOnce }), o } var z3 = new Set(["transformViewportThreshold", "styleTransformEffectEnabled", "transformTargets", "spring", "transformTrigger"]), $3 = (e, t) => { var n; let r = (n = e?.[0]) == null ? void 0 : n.target; return t ? { opacity: r?.opacity ?? 1 } : r }, fC = () => ({ opacity: [], x: [], y: [], scale: [], rotate: [], rotateX: [], rotateY: [], skewX: [], skewY: [], transformPerspective: [] }); function N3(e, t) { let n = x.useRef({}); x.useEffect(() => { if (t !== void 0) for (let r of no(e)) { let i = e[r]; i.attach((o, s) => { let a = n.current[r]; if (a && a.stop(), n.current[r] = dd({ keyframes: [i.get(), o], velocity: i.getVelocity(), ...t, restDelta: .001, onUpdate: s }), !We.isProcessing) { let l = performance.now() - We.timestamp; l < 40 && (n.current[r].time = l / 1e3) } return i.get() }) } }, [JSON.stringify(t)]) } function H3(e, t) { let n = fC(); return { inputRange: uC(e, t, i => { var o, s, a; let l = (o = e[i - 1]) == null ? void 0 : o.target, c = (s = e[i]) == null ? void 0 : s.target; for (let u of dr) (a = n[u]) == null || a.unshift(l?.[u] ?? 0, c?.[u] ?? 0) }), effectKeyOutputRange: n } } function j3(e) { var t; let n = fC(); for (let { target: r } of e) for (let i of dr) (t = n[i]) == null || t.push(r[i]); return n } var _S = [0, 1]; function W3({ transformTrigger: e, styleTransformEffectEnabled: t, transformTargets: n, spring: r, transformViewportThreshold: i = 0 }, o) { let s = Li(), a = cC($3(n, s), t); return x.useLayoutEffect(() => { if (!(!t || !n)) if (e !== "onScrollTarget") { let l = j3(n); return wo(({ y: c }) => { for (let u of dr) s && u !== "opacity" || _S.length === l[u].length && l[u][0] !== void 0 && a.values[u].set(Vs(c.progress, _S, l[u])) }, e === "onInView" ? { target: o.current ?? void 0, offset: ["start end", "end end"] } : void 0) } else return wo(({ y: l }) => { if (!n[0] || n[0].ref && !n[0].ref.current) return; let { inputRange: c, effectKeyOutputRange: u } = H3(n, i * l.containerLength); if (c.length !== 0) for (let f of dr) s && f !== "opacity" || c.length === u[f].length && u[f][0] !== void 0 && a.values[f].set(Vs(l.current, c, u[f])) }) }, [s, e, o, i, t, a, n]), N3(a.values, r), a } var dC = { parallax: C3, styleAppear: O3, styleTransform: z3, loop: x3, presence: R3 }, U3 = no(dC); function FS(e, t, n) { return !(e in n) && t in n || n[e] === !0 } function G3(e) { let t = { parallax: {}, styleAppear: {}, styleTransform: {}, presence: { animate: e.animate, initial: e.initial, exit: e.exit }, loop: {}, forwardedProps: {} }; for (let n in e) { let r = b3(n); if (r) for (let i of U3) { let o = dC[i]; if (o?.has(r)) { t[i][r] = Je(e)[n]; break } } else t.forwardedProps[n] = Je(e)[n] } return t.parallax.parallaxTransformEnabled = FS("parallaxTransformEnabled", "speed", t.parallax), t.styleAppear.styleAppearEffectEnabled = FS("styleAppearEffectEnabled", "animateOnce", t.styleAppear), t } var yi = e => e.reduce((t, n) => t += n, 0), IS = e => e.reduce((t, n) => t = t * n, 1), q3 = "current"; function X3(e) { return Me(e) && q3 in e } function Y3(e, t) { if (!e || !Me(e)) return t; for (let n in e) { let r = e[n]; !Oe(r) || !lC(n) || Ae(r.get()) && t[n].push(r) } } function Fa(e) { return fe(e) || Array.isArray(e) } var K3 = e => x.forwardRef((t, n) => { if (t.__withFX) return k(e, { ...t, animate: void 0, initial: void 0, exit: void 0, ref: n }); if (le.current() === le.canvas) { let pe = Fa(t.animate) ? t.animate : void 0, ie = Fa(t.initial) ? t.initial : void 0; return k(e, { ...t, animate: pe, initial: ie, exit: void 0, ref: n }) } let r = x.useRef(null), i = n ?? r, { parallax: o = {}, styleAppear: s = {}, styleTransform: a = {}, presence: l = {}, loop: c = {}, forwardedProps: u } = G3(t), { __targetOpacity: f, __perspectiveFX: d, __smartComponentFX: m = !1 } = t, y = er(f ?? 1), { values: g } = P3(l, i, m, t.style, t[Fl]), { values: b, style: h } = T3(o, i), { values: p } = W3(a, i), { values: v } = B3(s, i), { values: w } = S3(c), C = x.useMemo(() => ({ scale: [v.scale, w.scale, g.scale, p.scale], opacity: [v.opacity, w.opacity, g.opacity, y, p.opacity], x: [v.x, w.x, g.x, p.x], y: [v.y, w.y, b.y, g.y, p.y], rotate: [v.rotate, w.rotate, g.rotate, p.rotate], rotateX: [v.rotateX, w.rotateX, g.rotateX, p.rotateX], rotateY: [v.rotateY, w.rotateY, g.rotateY, p.rotateY], skewX: [v.skewX, w.skewX, g.skewX, p.skewX], skewY: [v.skewY, w.skewY, g.skewY, p.skewY], transformPerspective: [p.transformPerspective, v.transformPerspective] }), [y, p, b, v, w, g]); Y3(t.style, C); let S = Dt(C.scale, IS), R = Dt(C.opacity, IS), E = Dt(C.x, yi), L = Dt(C.y, yi), F = Dt(C.rotate, yi), z = Dt(C.rotateX, yi), D = Dt(C.rotateY, yi), K = Dt(C.skewX, yi), U = Dt(C.skewY, yi), $ = Dt(C.transformPerspective, yi), { drag: W, dragConstraints: ee } = u; EA(W && X3(ee) ? ee : void 0); let te = { opacity: R, scale: S, x: E, y: L, rotate: F, rotateX: z, rotateY: D, skewX: K, skewY: U }; it(d) && (te.transformPerspective = $); let q = Fa(t.animate) ? t.animate : void 0, ne = Fa(t.initial) ? t.initial : void 0, be = Fa(t.exit) ? t.exit : void 0, re = m && !l.presenceInitial ? { initial: ne, animate: q, exit: be } : {}; return k(e, { ...u, ...re, __withFX: !0, style: { ...t.style, ...h, ...te }, values: g, ref: i }) }); var c8 = K3; function Em(e, t) { ki(e) ? e(t) : hC(e) && (e.current = t) } function hC(e) { return Me(e) && "current" in e } function LS(e, t) { return { get current() { return e.current }, set current(n) { e.current = n, t(n) } } } function Q3(...e) { return t => e.forEach(n => Em(n, t)) } function pC(e) { let t = Rn(() => Z3(e)); return t.useSetup(e), t.cloneAsElement } function Z3(e) { let t = { forwardedRef: e, childRef: null, ref: null }; t.ref = MS(t); let n = (s, a) => { if (!t.forwardedRef && t.forwardedRef === s) { t.ref = a; return } let l = !1; t.childRef !== a && (t.childRef = a, l = !0), t.forwardedRef !== s && (t.forwardedRef = s, l = !0), l && (t.ref = MS(t)) }, r = !1; function i(s, a) { if (r) throw new ReferenceError("useCloneChildrenWithPropsAndRef: You should not call cloneChildrenWithPropsAndRef more than once during the render cycle."); return r = !0, qn.count(s) > 1 && e && (t.forwardedRef = void 0, t.ref = t.childRef), qn.map(s, l => { if (Nt(l)) { let c = "ref" in l ? l.ref : void 0; n(t.forwardedRef, c); let u = t.ref !== c ? { ...a, ref: t.ref } : a; return gr(l, u) } return l }) } let o = function (a, l) { return k(He, { children: i(a, l) }) }; return o.cloneAsArray = i, { useSetup: s => { r = !1, n(s, t.childRef) }, cloneAsElement: o } } function MS(e) { if (!e.forwardedRef) return e.childRef; let { forwardedRef: t, childRef: n } = e; return r => { Em(n, r), Em(t, r) } } var J3 = x.createContext({}); function m8() { return x.useContext(J3) } var e5 = e => x.forwardRef((t, n) => { let r = tl(t); return k(e, { layoutId: r, ...t, layoutIdKey: void 0, duplicatedFrom: void 0, ref: n }) }), t5 = class extends Ee { constructor() { super(...arguments), T(this, "state", { hasError: !1 }) } componentDidCatch(e, t) { var n; let r = t?.componentStack; if (console.error("Error in component (see previous log). This component has been hidden. Please check any custom code or code overrides to fix.", r), this.setState({ hasError: !0 }), typeof I < "u" && Math.random() <= .01) { let i = e instanceof Error && typeof e.stack == "string" ? e.stack : null; (n = I.__framer_events) == null || n.push(["published_site_load_recoverable_error", { message: String(e), stack: i, componentStack: i ? void 0 : r }]) } } render() { let { children: e } = this.props, { hasError: t } = this.state; return t ? null : e } }, n5 = x.forwardRef(({ children: e, layoutId: t, as: n, ...r }, i) => { let o = Rn(() => t ? `${t}-container` : void 0), s = el(n); return k(s, { layoutId: o, ...r, ref: i, children: k(cs.Provider, { value: !0, children: k(wO, { enabled: !1, children: k(Q0, { id: t ?? "", inherit: "id", children: k(t5, { children: x.Children.map(e, a => x.isValidElement(a) ? x.cloneElement(a, { layoutId: t }) : a) }) }) }) }) }) }), w8 = e5(n5), r5 = x.createContext(void 0), i5 = (() => { var e; if (!zr()) return new Set; let t = (e = document.querySelector("style[data-framer-css-ssr-minified]")) == null ? void 0 : e.getAttribute("data-framer-components"); return t ? new Set(t.split(" ")) : new Set })(), o5 = "data-framer-css-ssr", mC = (e, t, n) => x.forwardRef((r, i) => {
    let { sheet: o, cache: s } = x.useContext(r5) ?? {}; if (!zr()) {
        let a = Array.isArray(t) ? t.join(`
`) : t; return ce(He, { children: [k("style", { [o5]: !0, "data-framer-component": n, dangerouslySetInnerHTML: { __html: a } }), k(e, { ...r, ref: i })] })
    } return x.useInsertionEffect(() => {
        if (n && i5.has(n)) return; (Array.isArray(t) ? t : t.split(`
`)).forEach(l => l && Vk(l, o, s))
    }, []), k(e, { ...r, ref: i })
}), cg = x.createContext({ onRegisterCursors: () => () => { }, registerCursors: () => { } }), Vu = "framer-cursor-none", Rm = "framer-pointer-events-none", s5 = x.memo(function ({ children: t }) { let n = Rn(() => { let i = new Set, o = {}; return { onRegisterCursors: s => (s(o), i.add(s), () => i.delete(s)), registerCursors: s => { let a = {}; for (let l in s) { let c = o[l] ?? s[l]; c && (a[l] = c) } o = a; for (let l of i) l(o) } } }), r = Li(); return ce(cg.Provider, { value: n, children: [t, !r && k(d5, {})] }) }), a5 = (() => mC(s5, [`.${Vu}, .${Vu} * { cursor: none !important; }`, `.${Rm}, .${Rm} * { pointer-events: none !important; }`]))(), l5 = (() => ({ position: "fixed", top: 0, left: 0, zIndex: 12 + 1, pointerEvents: "none" }))(); function c5(e) { return !(!e || e.placement || e.alignment) } function vu(e) { switch (e) { case "start": return "0%"; case "center": return "-50%"; case "end": return "-100%"; default: xe(e) } } function u5(e, t = "center") { switch (e) { case "top": return `${vu(t)}, -100%`; case "right": return `0%, ${vu(t)}`; case "bottom": return `${vu(t)}, 0%`; case "left": return `-100%, ${vu(t)}`; default: return "-50%, -50%" } } var OS = "data-framer-portal-id"; function DS(e, t) { let n = document.elementFromPoint(e, t); for (; n;) { if (n === document.body) return; let r = n.getAttribute("data-framer-cursor"); if (r) return r; if (n.hasAttribute(OS)) { let i = n.getAttribute(OS); n = n.parentElement, i && (n = document.getElementById(i) ?? n) } else n = n.parentElement } } function f5(e) { for (let t in e) return !1; return !0 } var d5 = x.memo(function () { let { onRegisterCursors: t } = V(cg), n = er(0), r = er(0), i = er(0), o = x.useRef(null), s = x.useRef({ cursors: {}, cursorHash: void 0 }), a = Xu(), l = !f5(s.current.cursors); x.useEffect(() => { let S = 0, R = 0; function E() { n.set(S), r.set(R), tr(i, 1, { type: "tween", duration: .2 }) } function L(D) { D.pointerType !== "touch" && (S = D.clientX, R = D.clientY, Y.update(E)) } let F = () => { if (!l) return; let D = DS(S, R); D !== s.current.cursorHash && (s.current.cursorHash = D, Y.update(() => a())) }; Y.read(F, !0); function z(D) { if (D.target === o.current || !o.current) return; let K = new PointerEvent(D.type, { bubbles: !0, cancelable: D.cancelable, pointerType: D.pointerType, pointerId: D.pointerId, composed: D.composed, isPrimary: D.isPrimary, buttons: D.buttons, button: D.button }); Y.update(() => { var U; (U = o.current) == null || U.dispatchEvent(K) }) } return ft.addEventListener("pointermove", L), document.addEventListener("pointerdown", z), document.addEventListener("pointerup", z), () => { ft.removeEventListener("pointermove", L), document.removeEventListener("pointerdown", z), document.removeEventListener("pointerup", z), Ht(F) } }, [i, n, r, l, a]), x.useEffect(() => { function S() { tr(i, 0, { type: "tween", duration: .2 }) } return document.addEventListener("mouseleave", S), ft.addEventListener("blur", S), () => { document.removeEventListener("mouseleave", S), ft.removeEventListener("blur", S) } }, [i]), x.useLayoutEffect(() => { function S(E) { s.current.cursors = E, s.current.cursorHash = DS(n.get(), r.get()), a() } let R = t(S); return () => { R(), document.body.classList.toggle(Vu, !1) } }, [n, r, t, a]); let { cursors: c, cursorHash: u } = s.current, f = u ? c[u] : null, d = c5(f); x.useLayoutEffect(() => { document.body.classList.toggle(Vu, d) }, [d]); let m = f?.component, y = f?.transition ?? { duration: 0 }, g = Od(n, y), b = Od(r, y), h = Dt(() => { var S; return g.get() + (((S = f?.offset) == null ? void 0 : S.x) ?? 0) }), p = Dt(() => { var S; return b.get() + (((S = f?.offset) == null ? void 0 : S.y) ?? 0) }), v = f?.alignment, w = f?.placement, C = x.useCallback((S, R) => `translate(${u5(w, v)}) ${R}`, [v, w]); return !f || !m ? null : k(m, { transformTemplate: C, style: { ...l5, x: h, y: p, opacity: i }, globalTapTarget: !0, variant: f?.variant, ref: o, className: Rm }) }); function R8(e) { let { registerCursors: t } = V(cg), n = Rn(() => e); x.useLayoutEffect(() => { t(n) }, [n, t]) } var gC = x.createContext(void 0), ug = class { constructor(e) { this.resolver = e, T(this, "status") } static is(e) { return e instanceof ug } preload() { if (this.status) { let t = this.status; return t.type !== "pending" ? void 0 : t.promise } let e = this.resolver().then(t => { this.status = { type: "fulfilled", value: t } }, t => { this.status = { type: "rejected", error: t } }); return this.status = { type: "pending", promise: e }, e } waitFor() { return this.resolver() } read() { let e = this.status; if (!e) throw new Error("Need to call preload() before read()"); switch (e.type) { case "pending": throw new Error("Need to wait for preload() to resolve"); case "fulfilled": return e.value; case "rejected": throw e.error; default: xe(e) } } }, vC = x.createContext(void 0), M8 = (() => vC.Provider)(), yC = () => x.useContext(vC) ?? {}; function fg(e, t) { return e instanceof HTMLAnchorElement ? e : e instanceof Element ? e === t ? null : fg(e.parentElement, t) : null } function h5({ children: e }) { let { useGranularSuspense: t } = yC(); return t ? k(kk, { children: e }) : e } function p5(e) { return Ve(function (n, r) { return k(h5, { children: k(e, { ...n, ref: r }) }) }) } var AS = "element", m5 = "collection", g5 = "collectionItemId", v5 = "pathVariables", bC = "framer/page-link,"; function xC(e) { return fe(e) && e.startsWith(`data:${bC}`) } function dg(e) { if (xC(e)) try { let t = new URL(e), n = t.pathname.substring(bC.length), r = t.searchParams, i = r.has(AS) ? r.get(AS) : void 0, o, s = r.get(m5), a = r.get(g5), l = r.get(v5); if (s && a && l) { let c = Object.fromEntries(new URLSearchParams(l).entries()); o = { collection: s, collectionItemId: a, pathVariables: c } } return { target: n === "none" ? null : n, element: i === "none" ? void 0 : i, collectionItem: o } } catch { return } } function y5(e, t, n) { var r; let i = t.getAttribute("data-framer-page-link-target"), o, s; if (i) { o = t.getAttribute("data-framer-page-link-element") ?? void 0; let l = t.getAttribute("data-framer-page-link-path-variables"); l && (s = Object.fromEntries(new URLSearchParams(l).entries())) } else { let l = t.getAttribute("href"); if (!l) return !1; let c = dg(l); if (!c || !c.target) return !1; i = c.target, o = c.element ?? void 0, s = (r = c.collectionItem) == null ? void 0 : r.pathVariables } let a = o ? t.dataset.framerSmoothScroll !== void 0 : void 0; return e(i, o, Object.assign({}, n, s), a), !0 } var b5 = 500, x5 = .9, w5 = 1.7, S5 = 4, k5 = 1 / 0, Qo = new WeakMap, yu = new Set, Zo = new Map; function C5() { var e; let t = Ne.connection || Ne.mozConnection || Ne.webkitConnection || {}, n = Ne.deviceMemory && Ne.deviceMemory > w5, r, i, o; function s() { r = t.effectiveType || "", i = t.saveData || r.includes("2g"), o = r === "3g" || n ? S5 : k5 } (e = t.addEventListener) == null || e.call(t, "change", s), s(); let a = new IntersectionObserver(u, { threshold: x5 }), l = 0; async function c(f, d) { if (i) return; let m = Zo.get(f); if (!m?.size || yu.has(f)) return; ++l, yu.add(f); let y = Ek(f).catch(() => { }); a.unobserve(d), Qo.delete(d); for (let g of m) a.unobserve(g), Qo.delete(g); m.clear(), Zo.delete(f), await y, --l } function u(f) { var d; for (let m of f) { let y = m.target, g = Qo.get(y); if (!g || yu.has(g)) { a.unobserve(y), Qo.delete(y); continue } let b = Zo.get(g), h = ((d = Zo.get(g)) == null ? void 0 : d.size) ?? 0; if (m.isIntersecting) { if (l >= o) continue; b ? b.add(y) : Zo.set(g, new Set([y])), setTimeout(c.bind(void 0, g, y), b5) } else b && b.delete(y), h <= 1 && Zo.delete(g) } } return (f, d) => { if (!yu.has(f)) return Qo.set(d, f), a.observe(d), () => { Qo.delete(d), a.unobserve(d) } } } var T5 = !Zm || typeof IntersectionObserver > "u" ? null : C5(), dm = {}, bu = new WeakMap; function E5(e, t, n) { var r, i; let o = (i = (r = bu?.get(n ?? dm)) == null ? void 0 : r.get(e.collectionId)) == null ? void 0 : i.get(e.collectionItemId); if (o) return o; let s = bu.get(n ?? dm) ?? new Map; bu.set(n ?? dm, s); let a = s.get(e.collectionId) ?? new Map; s.set(e.collectionId, a); let l = new ug(async () => { try { let c = t[e.collectionId]; if (!c) throw new Error(`Key not found in collection utils for collection id: "${e.collectionId}`); let u = await c(); if (!u) throw new Error("Collection does not contain utility functions"); return await u.getSlugByRecordId(e.collectionItemId, n ?? void 0) } catch (c) { console.warn(`Failed to resolve slug: ${c instanceof Error ? c.message : "Unknown error"}`); return } }); return a.set(e.collectionItemId, l), l } var R5 = "webPageId"; function VS(e) { return !!(e && typeof e == "object" && R5 in e) } function P5(e) { if (!e) return; let t = {}; for (let n in e.pathVariables) { let r = e.pathVariables[n]; r && (t[n] = r) } return t } function Pm(e) { if (!xC(e)) return e; let t = dg(e); if (!t) return; let { target: n, element: r, collectionItem: i } = t; if (n) return { webPageId: n, hash: r ?? void 0, pathVariables: P5(i) } } var wC = /:([a-z]\w*)/gi, _5 = ke(void 0); function SC() { var e; let t = V(_5), n = (e = Qm()) == null ? void 0 : e.pathVariables; return t || n } function kC(e, { webPageId: t, hash: n, pathVariables: r }, i) { if (t !== e.id || n) return !1; if (e.path && e.pathVariables) { let o = Object.assign({}, i, r); for (let [, s] of e.path.matchAll(wC)) if (!s || e.pathVariables[s] !== o[s]) return !1 } return !0 } function hg(e) { return e === void 0 ? !1 : !!(e.startsWith("#") || e.startsWith("/") || e.startsWith(".")) } function F5(e, t) { try { return !!new URL(e).protocol } catch { } return t } function pg(e, t) { return e !== void 0 ? e ? "_blank" : void 0 : t ? void 0 : "_blank" } function hm(e, t = void 0) { let n = hg(e), r = pg(t, n); return { href: F5(e, n) ? e : `https://${e}`, target: r, rel: n ? void 0 : "noopener" } } function CC(e, t, n, r, i) { return async o => { var s, a; if (o.metaKey) return; let l = fg(o.target); if (!l || l.getAttribute("target") === "_blank") return; o.preventDefault(); let c = (s = e.getRoute) == null ? void 0 : s.call(e, t); c && dk(c?.page) && c.page.preload(), (a = e.navigate) == null || a.call(e, t, n, r, i) } } function I5(e, t, n, r) { let i = []; function o(a) { if (!a || !n) return; let l = {}; for (let c in a) { let u = a[c]; H(u, "unresolvedSlug should be defined"); let f = E5(u, n, r), d = f.preload(); if (d) i.push(d); else { let m = f.read(); m && (l[c] = m) } } return l } let s = { path: o(e), hash: o(t) }; if (i.length) throw Promise.allSettled(i); return s } function L5(e, t, n, r, i, o, s, a) { var l; let c = { ...i, ...o, ...a?.path }, u = { ...i, ...s, ...a?.hash }, f = (l = e.getRoute) == null ? void 0 : l.call(e, n), d = Xm(f, { currentRoutePath: t?.path, currentPathVariables: t?.pathVariables, hash: r, pathVariables: c, hashVariables: u, preserveQueryParams: e.preserveQueryParams }), m = d.split("#", 2)[1]; return { routeId: n, route: f, href: d, elementId: m, pathVariables: c } } function M5(e, t, n) { if (!(!e.routes || !e.getRoute || !hg(t))) try { let [i, o] = t.split("#", 2); H(i !== void 0, "A href must have a defined pathname."); let [s] = i.split("?", 2); H(s !== void 0, "A href must have a defined pathname."); let { routeId: a, pathVariables: l } = Tk(e.routes, s), c = e.getRoute(a); if (c) { let u = Object.assign({}, n, l); return { routeId: a, route: c, href: t, elementId: o, pathVariables: u } } } catch { } } function O5(e, t, n, r, i) { let { webPageId: o, hash: s, pathVariables: a, hashVariables: l, unresolvedHashSlugs: c, unresolvedPathSlugs: u } = n, f = I5(u, c, e.collectionUtils, r); return L5(e, t, o, s, i, a, l, f) } function D5(e, t, n, r, i, o) { if (!r) return hm(e, t); let s = M5(n, e, i); if (!s) return hm(e, t); let { routeId: a, route: l, elementId: c, pathVariables: u } = s; if (!l) return hm(e, t); let f = Xm(l, { currentRoutePath: r.path, currentPathVariables: r.pathVariables, hash: c, pathVariables: u, preserveQueryParams: n.preserveQueryParams }), d = pg(t, !0); return { href: f, target: d, onClick: CC(n, a, c, u, o) } } function A5(e, t, n) { var r; if (fe(e)) { let o = hg(e); if (!t.routes || !t.getRoute || !n || !o) return; let [s] = e.split("#", 2); if (s === void 0) return; let [a] = s.split("?", 2); if (a === void 0) return; let { routeId: l } = Tk(t.routes, a); return t.getRoute(l) } let { webPageId: i } = e; return (r = t.getRoute) == null ? void 0 : r.call(t, i) } var V8 = p5(Ve(({ children: e, href: t, openInNewTab: n, smoothScroll: r, ...i }, o) => { let s = Uu(), a = Qm(), l = SC(), { activeLocale: c } = HM(), u = A(null), f = ae(() => { let y, g = h => { var p; if (h === null) { y?.(), y = void 0; return } let v = VS(t) ? t : Pm(t); if (!v) return; let w = A5(v, s, a); w && (y = (p = T5) == null ? void 0 : p(w, h)) }, b = Nt(e) && "ref" in e; return b && hC(e.ref) ? LS(e.ref, g) : b && ki(e.ref) ? Q3(e.ref, g) : LS(u, g) }, [t, s, a, e]), d = pC(o), m = ae(() => { if (!t) return {}; let y = VS(t) ? t : Pm(t); if (!y) return {}; if (fe(y)) return D5(y, n, s, a, l, r); let { routeId: g, href: b, elementId: h, pathVariables: p } = O5(s, a, y, c, l), v = pg(n, !0); return { href: b, target: v, onClick: CC(s, g, h, p, r), "data-framer-page-link-current": a && kC(a, y, l) || void 0 } }, [t, s, c, l, n, a, r]); return d(e, { ...i, ...m, ref: f }) })); var V5 = x.createContext(void 0); function B5(e) { return new Promise((t, n) => { try { new URL(e); let r = new Image; r.onload = () => t(), r.onerror = n, r.src = e } catch (r) { n(r) } }) } function z5(e) { return typeof e == "object" && e !== null } function $5(e, t) { if (t === "") return e; let n = t.split(/[.[\]]+/u).filter(i => i.length > 0), r = e; for (let i of n) { if (!z5(r)) return; r = r[i] } return r } function Ia(e) { return `${e.credentials}:${e.url}` } var N5 = { status: "loading", data: void 0 }; function H5(e) { return fe(e) && !isNaN(Number(e)) } function j5(e, t) { switch (e) { case "string": return fe(t) || Ae(t); case "color": return fe(t); case "boolean": return Gu(t); case "number": return Ae(t) || H5(t); case "link": case "image": return fe(t) && _m(t); default: { let n = e; return !1 } } } function W5(e, t) { if (e.status === "loading") return t.fallbackValue; if (e.status === "error") throw e.error; let n = $5(e.data, t.resultKeyPath); if (it(n)) throw new Error(`Key '${t.resultKeyPath}' not found in response`); if (!j5(t.resultOutputType, n)) throw new Error(`Resolved value '${n}' is not valid for type '${t.resultOutputType}'`); return n } function _m(e) { try { return !!new URL(e).protocol } catch { } } function pm(e, t) { if (le.current() === le.canvas) return !1; let n = t === 0 ? 500 : t * 1e3, r = Date.now(), i = e + n; return r >= i } var BS = () => { }, Or, Fm, Xi, Yi, Ma, bi, Tu = class { constructor() { T(this, "responseValues", new Map), en(this, Or, new Map), en(this, Fm, new Set), en(this, Xi, new Map), en(this, Yi, new Map), en(this, Ma, new Map), en(this, bi, new Map), T(this, "persistCache", h3(() => { let e = {}; for (let [t, n] of this.responseValues) { if (!n || n.status !== "success") continue; let r = ue(this, Xi).get(t); if (!r || r === 0) continue; let i = ue(this, Yi).get(t); i && (i && pm(i, r) || (e[t] = [i, r, n.data])) } try { localStorage.setItem(Tu.cacheKey, JSON.stringify(e)) } catch { } }, 500)) } unmount() { for (let [e, t] of ue(this, bi)) clearInterval(t), ue(this, bi).delete(e) } stopQueryRefetching(e) { let t = Ia(e), n = ue(this, bi).get(t); n && (clearInterval(n), ue(this, bi).delete(t)) } startQueryRefetching(e) { let t = Ia(e), n = ue(this, bi).get(t), r = ue(this, Xi).get(t); if (n || !r) return; let i = ft.setInterval(() => { if (document.visibilityState === "hidden") return; let o = ue(this, Yi).get(t); !r || !o || this.fetchWithCache({ ...e, cacheDuration: r }) }, r); ue(this, bi).set(t, i) } hydrateCache() { try { let e = localStorage.getItem(Tu.cacheKey); if (!e) return; let t = JSON.parse(e); if (typeof t != "object") throw new Error("Invalid cache data"); for (let n in t) { let r = t[n]; if (!Array.isArray(r) || r.length !== 3) throw new Error("Invalid cache data"); let [i, o, s] = r; pm(i, o) || (ue(this, Yi).set(n, i), ue(this, Xi).set(n, o), this.responseValues.set(n, { status: "success", data: s })) } } catch { try { localStorage.removeItem(Tu.cacheKey) } catch { } } } setResponseValue(e, t) { this.responseValues.set(e, t), this.persistCache(); let n = ue(this, Or).get(e); if (n) for (let r of n) r() } async prefetch(e) { if (!zr() || !_m(e.url)) return; let t = Ia(e); ue(this, Fm).add(t), await this.fetchWithCache(e); let n = this.getValue(t); if (!n || n.status === "loading") throw new Error("Unexpected result status for prefetch"); let r = ue(this, Or).get(t); for (let o of r ?? []) o(); let i = W5(n, e); return e.resultOutputType === "image" && fe(i) && await B5(i).catch(BS), i } async fetchWithCache(e) { if (!zr()) return; let t = Ia(e), n = ue(this, Ma).get(t); if (n) return n; let r = ue(this, Yi).get(t), i = r && pm(r, e.cacheDuration); if (this.responseValues.has(t) && !i) return; this.responseValues.get(t) || this.setResponseValue(t, N5); let a = (async () => { try { let l = await fetch(e.url, { method: "GET", headers: { "Content-Type": "application/json" }, credentials: e.credentials }); if (!l.ok) { this.setResponseValue(t, { status: "error", error: new Error("Invalid Response Status"), data: void 0 }); return } let c = await l.json(); this.setResponseValue(t, { status: "success", data: c }), ue(this, Yi).set(t, Date.now()) } catch (l) { this.setResponseValue(t, { status: "error", error: l, data: void 0 }) } })(); return ue(this, Ma).set(t, a), a.finally(() => { ue(this, Ma).delete(t) }), a } getValue(e) { return this.responseValues.get(e) } subscribe(e, t) { let { url: n, cacheDuration: r } = e; if (!_m(n)) return BS; let i = Ia(e), o = ue(this, Xi).get(i); (!o || r < o) && ue(this, Xi).set(i, r), this.startQueryRefetching(e), this.fetchWithCache(e); let s = ue(this, Or).get(i) ?? new Set; return s.add(t), ue(this, Or).set(i, s), () => { let a = ue(this, Or).get(i); a && (a.delete(t), a.size === 0 && ue(this, Or).delete(i), ue(this, Or).size === 0 && this.stopQueryRefetching(e)) } } }, TC = Tu; Or = new WeakMap; Fm = new WeakMap; Xi = new WeakMap; Yi = new WeakMap; Ma = new WeakMap; bi = new WeakMap; T(TC, "cacheKey", "framer-fetch-client-cache"); var U5 = ke(void 0), G5 = ke(!0), q5 = ({ children: e, client: t }) => { let [n] = Qe(() => t ?? new TC), [r, i] = Qe(!0); return N(() => (n.hydrateCache(), vr(() => { i(!1) }), () => n.unmount()), [n]), k(G5.Provider, { value: r, children: k(U5.Provider, { value: n, children: e }) }) }, X5, Y5, K5; X5 = new WeakMap; Y5 = new WeakMap; K5 = new WeakMap; function j8({ RootComponent: e, isWebsite: t, routeId: n, framerSiteId: r, pathVariables: i, routes: o, collectionUtils: s, notFoundPage: a, isReducedMotion: l = !1, includeDataObserver: c = !1, localeId: u, locales: f, preserveQueryParams: d }) { let { enableAsyncURLUpdates: m } = yC(); if (x.useEffect(() => { t || Fk.start() }, []), t) return k(X0, { reducedMotion: l ? "user" : "never", children: k(a5, { children: k(V5.Provider, { value: r, children: k(q5, { children: k(UM, { initialRoute: n, initialPathVariables: i, initialLocaleId: u, routes: o, collectionUtils: s, notFoundPage: a, locales: f, defaultPageStyle: { minHeight: "100vh", width: "auto" }, preserveQueryParams: d, enableAsyncURLUpdates: m }) }) }) }) }); { let y = c ? v3 : x.Fragment; return k(y, { children: k(DM, { routes: o, children: k(d3, { children: x.isValidElement(e) ? e : x.createElement(e, { key: n }) }) }) }) } } function Q5(e, t, n) { let r = qn.map(e, i => Nt(i) ? gr(i, t) : i); return n ? r : k(He, { children: r }) } var mg = x.createContext(void 0), EC = "ssr-variant"; function zS(e, t, n, r, i, o, s, a) { let l = x.Children.toArray(t), c = l[0]; if (l.length !== 1 || !x.isValidElement(c)) return console.warn("PropertyOverrides: expected exactly one React element for a child", t), s(t, n); let u = [], f = []; for (let [g] of Object.entries(r)) { if (g === i) continue; let b = e[g]; if (!b || !J5(c.props, b)) { f.push(g); continue } let h = $S([g], o); h.length && u.push({ variants: h, propOverrides: b }) } if (u.length === 0) return s(c, n); let d = [i, ...f], m = $S(d, o); m.length && u.unshift({ variants: m }); let y = []; for (let { variants: g, propOverrides: b } of u) { if (a && !g.includes(a)) continue; let h = g.join("+"), p = k(mg.Provider, { value: new Set(g), children: s(c, b ? { ...n, ...b } : n) }, h), v = Z5(g, o, r); v.length ? (H(u.length > 1, "Must branch out when there are hiddenClassNames"), p = k("div", { className: `${EC} ${v.join(" ")}`, children: p }, h)) : H(u.length === 1, "Cannot branch out when hiddenClassNames is empty"), y.push(p) } return H(!a || y.length === 1, "Must render exactly one branch when activeVariantId is given"), y } function RC(e) { return e.split("-")[2] } function Z5(e, t, n) { let r = []; for (let [i, o] of Object.entries(n)) { let s = t && !t.has(i); e.includes(i) || s || r.push(`hidden-${RC(o)}`) } return r } function $S(e, t) { return t ? e.filter(n => t.has(n)) : e } function J5(e, t) { for (let n of Object.keys(t)) if (!qe(e[n], t[n], !0)) return !0; return !1 } function e4(e, t, n) { return !n || !e ? t : { ...t, ...n[e] } } var t4 = x.forwardRef(function ({ breakpoint: t, overrides: n, children: r, ...i }, o) { let s = pC(o), a = x.useContext(mg), l = LM(), c = Rn(() => l.current ? zr() ? 1 : 2 : 0), u = x.useContext(gC); if (!u) return console.warn("PropertyOverrides is missing GeneratedComponentContext"), s(r, i); let { primaryVariantId: f, variantClassNames: d } = u; switch (c) { case 0: return s(r, e4(t, i, n)); case 1: return zS(n, r, i, d, f, a, s, t); case 2: return zS(n, r, i, d, f, a, Q5, void 0); default: xe(c) } }), q8 = (() => mC(t4, `.${EC} { display: contents }`, "PropertyOverrides"))(); var n4 = Zn($L(), 1); function r4(e) { return { trace(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.trace(...t) }, debug(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.debug(...t) }, info(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.info(...t) }, warn(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.warn(...t) }, error(...t) { var n; return (n = ut.getLogger(e)) == null ? void 0 : n.error(...t) } } } function i4(e) { return Ja(e) && e.every(Me) } function PC(e) { return Me(e) && ki(e.read) && ki(e.preload) } function _C(e) { return i4(e) || PC(e) } function gg(e) { return Me(e) && Me(e.schema) } function FC(e) { return Me(e) && Me(e.collectionByLocaleId) } async function NS(e, t) { return PC(e) ? (await e.preload(t), e.read(t)) : e } var IC = class { constructor(e, t) { this.collection = e, this.locale = t, T(this, "schema"), T(this, "indexes", []); let n = YD(e); H(n, "Collection does not have properties"); let r = { id: { type: "string", isNullable: !1 } }, i = Object.entries(n); for (let [o, s] of i) s && (r[o] = { type: s.type, isNullable: !0 }); this.schema = r } getDatabaseItem(e, t) { let n = {}; for (let r in this.schema) { let i = e[r]; if (os(i)) continue; let o = this.schema[r]; it(o) || (H(o.type !== "unknown", "Invalid definition type"), n[r] = { type: o.type, value: i }) } return { pointer: t, data: n } } async resolveRichText(e) { if (ug.is(e)) { let t = e.preload(); return t && await t, e.read() } return e } async scanItems() { return (await NS(this.collection, this.locale)).map((t, n) => { let r = String(n); return this.getDatabaseItem(t, r) }) } async resolveItems(e) { let t = await NS(this.collection, this.locale); return e.map(n => { let r = Number(n), i = t[r]; return H(i, "Can't find collection item"), this.getDatabaseItem(i, n) }) } compareItems(e, t) { return Number(e.pointer) - Number(t.pointer) } }; function wt(e) { switch (e?.type) { case "boolean": return e.value; case "number": case "string": return !!e.value }return !1 } function o4(e) { switch (e?.type) { case "color": return e.value }return null } function vg(e) { switch (e?.type) { case "date": return e.value; case "number": case "string": { let t = new Date(e.value); return tg(t) ? t.toISOString() : null } }return null } function s4(e) { switch (e?.type) { case "enum": case "string": return e.value }return null } function a4(e) { switch (e?.type) { case "file": return e.value }return null } function l4(e) { switch (e?.type) { case "responsiveimage": return e.value }return null } function c4(e) { switch (e?.type) { case "link": return e.value; case "string": try { let { protocol: t } = new URL(e.value); return t === "http:" || t === "https:" ? e.value : null } catch { return null } }return null } function rl(e) { switch (e?.type) { case "number": case "string": { let t = Number(e.value); return Number.isFinite(t) ? t : null } }return null } function u4(e) { switch (e?.type) { case "richtext": return e.value }return null } function $r(e) { switch (e?.type) { case "string": case "number": return String(e.value) }return null } function f4(e) { switch (e?.type) { case "multicollectionreference": return e.value }return null } var Te = { cast(e, t) { switch (t.type) { case "boolean": { let n = wt(e); return oe(n) ? null : { type: "boolean", value: n } } case "color": { let n = o4(e); return oe(n) ? null : { type: "color", value: n } } case "date": { let n = vg(e); return oe(n) ? null : { type: "date", value: n } } case "enum": { let n = s4(e); return oe(n) ? null : { type: "enum", value: n } } case "file": { let n = a4(e); return oe(n) ? null : { type: "file", value: n } } case "link": { let n = c4(e); return oe(n) ? null : { type: "link", value: n } } case "number": { let n = rl(e); return oe(n) ? null : { type: "number", value: n } } case "responsiveimage": { let n = l4(e); return oe(n) ? null : { type: "responsiveimage", value: n } } case "richtext": { let n = u4(e); return oe(n) ? null : { type: "richtext", value: n } } case "string": { let n = $r(e); return oe(n) ? null : { type: "string", value: n } } case "multicollectionreference": { let n = f4(e); return oe(n) ? null : { type: "multicollectionreference", value: n } } case "unknown": return e; default: xe(t, "Unsupported cast") } }, equal(e, t, n) { return e?.type !== t?.type ? !1 : La(e, t, n) === 0 }, lessThan(e, t, n) { return e?.type !== t?.type ? !1 : La(e, t, n) < 0 }, lessThanOrEqual(e, t, n) { return e?.type !== t?.type ? !1 : La(e, t, n) <= 0 }, greaterThan(e, t, n) { return e?.type !== t?.type ? !1 : La(e, t, n) > 0 }, greaterThanOrEqual(e, t, n) { return e?.type !== t?.type ? !1 : La(e, t, n) >= 0 }, in(e, t) { return e?.type !== "string" || t?.type !== "multicollectionreference" ? !1 : t.value.includes(e.value) }, stringify(e) { if (e === null) return "null"; switch (e.type) { case "boolean": case "number": return String(e.value); case "string": return `'${e.value}'`; case "enum": return `'${e.value}' /* Enum */`; case "color": return `'${e.value}' /* Color */`; case "date": return `'${e.value}' /* Date */`; case "richtext": return "RichText"; case "responsiveimage": return "ResponsiveImage"; case "file": return "File"; case "link": return fe(e.value) ? `'${e.value}' /* Link */` : "Link"; case "multicollectionreference": return `[${e.value.map(t => `'${t}'`).join(", ")}]`; default: xe(e) } } }; function La(e, t, n) { if (oe(e) || oe(t)) return H(e === t), 0; switch (e.type) { case "boolean": return H(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "color": return H(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "date": { H(e.type === t.type); let r = new Date(e.value), i = new Date(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "enum": return H(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "file": return H(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "responsiveimage": { H(e.type === t.type); let r = JSON.stringify(e.value), i = JSON.stringify(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "link": { H(e.type === t.type); let r = JSON.stringify(e.value), i = JSON.stringify(t.value); return r < i ? -1 : r > i ? 1 : 0 } case "number": return H(e.type === t.type), e.value < t.value ? -1 : e.value > t.value ? 1 : 0; case "richtext": { H(e.type === t.type); let r = e.value, i = t.value; return r < i ? -1 : r > i ? 1 : 0 } case "string": { H(e.type === t.type); let r = e.value, i = t.value; return n.type === 0 && (r = e.value.toLowerCase(), i = t.value.toLowerCase()), r < i ? -1 : r > i ? 1 : 0 } case "multicollectionreference": { H(e.type === t.type); for (let r = 0; r < Math.max(e.value.length, t.value.length); r++) { let i = e.value[r], o = t.value[r]; if (i === void 0) return -1; if (o === void 0) return 1; if (i < o) return -1; if (i > o) return 1 } return 0 } default: xe(e) } } var Im = "index", It = class { static from(e, t) { return fr(e, t, void 0) } }, St = class extends It { constructor(e, t, n) { super(), this.schema = e, this.name = t, this.collection = n, T(this, "definition"), t === Im ? this.definition = { type: "number", isNullable: !1 } : this.definition = e[t] ?? null } stringify() { return this.name } equals(e) { return e instanceof St && qe(this.definition, e.definition) && qe(e.name, this.name) && qe(e.collection, this.collection) } evaluate(e) { let t = this.name; if (it(e) || t === Im) throw new Error(`Can't evaluate identifier: ${t}`); if (this.collection) { let n = `${this.collection}_${t}`; return e.data[n] ?? e.data[t] ?? null } return e.data[t] ?? null } canEvaluate() { return !1 } }, Pe = class extends It { constructor(e, t) { super(), this.definition = e, this.value = t } stringify() { return Te.stringify(this.value) } static fromNull() { return new Pe(null, null) } static fromBoolean(e) { return new Pe({ type: "boolean", isNullable: oe(e) }, oe(e) ? null : { type: "boolean", value: e }) } static fromDate(e) { return new Pe({ type: "date", isNullable: oe(e) }, oe(e) ? null : { type: "date", value: e }) } static fromEnum(e) { return new Pe({ type: "enum", isNullable: oe(e) }, oe(e) ? null : { type: "enum", value: e }) } static fromNumber(e) { return new Pe({ type: "number", isNullable: oe(e) }, oe(e) ? null : { type: "number", value: e }) } static fromString(e) { return new Pe({ type: "string", isNullable: oe(e) }, oe(e) ? null : { type: "string", value: e }) } static fromMultiCollectionReference(e) { return new Pe({ type: "multicollectionreference", isNullable: oe(e) }, oe(e) ? null : { type: "multicollectionreference", value: e }) } equals(e) { return e instanceof Pe && qe(this.definition, e.definition) && qe(e.value, this.value) } evaluate() { return this.value } canEvaluate() { return !0 } }, il = class extends It { constructor(e) { super(), this.argumentExpressions = e, T(this, "collation", { type: 0 }) } getArgumentExpression(e) { let t = this.argumentExpressions[e]; if (it(t)) throw new Error("Missing argument in function call"); return t } equals(e) { return e instanceof il && qe(this.constructor, e.constructor) && qe(this.argumentExpressions, e.argumentExpressions) } canEvaluate() { return this.argumentExpressions.every(e => e.canEvaluate()) } }, Qu = class extends il { constructor() { super(...arguments), T(this, "definition", Qu.getDefinition()), T(this, "sourceExpression", this.getArgumentExpression(0)), T(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `CONTAINS(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (oe(e) || e.type !== "string" || oe(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.includes(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, Zu = class extends il { constructor() { super(...arguments), T(this, "definition", Zu.getDefinition()), T(this, "sourceExpression", this.getArgumentExpression(0)), T(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `STARTS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (oe(e) || e.type !== "string" || oe(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.startsWith(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, Ju = class extends il { constructor() { super(...arguments), T(this, "definition", Ju.getDefinition()), T(this, "sourceExpression", this.getArgumentExpression(0)), T(this, "targetExpression", this.getArgumentExpression(1)) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `ENDS_WITH(${this.sourceExpression.stringify()}, ${this.targetExpression.stringify()})` } getValue(e, t) { if (oe(e) || e.type !== "string" || oe(t) || t.type !== "string") return !1; let n = e.value, r = t.value; return this.collation.type === 0 && (n = n.toLowerCase(), r = r.toLowerCase()), n.endsWith(r) } evaluate(e) { let t = this.sourceExpression.evaluate(e), n = this.targetExpression.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, Bu = class extends It { constructor(e, t, n) { super(), this.valueExpression = e, this.conditions = t, this.elseExpression = n, T(this, "definition"), T(this, "collation", { type: 0 }); let r = []; for (let { thenExpression: i } of t) r.push(i.definition); n && r.push(n.definition), this.definition = Bu.getDefinition(r) } static getDefinition(e) { let t = null, n = !1; for (let r of e) { if (t ?? (t = r), t && r && t.type !== r.type) throw new Error("Incompatible types in CASE expression"); n || (n = r?.isNullable ?? !0) } return t ? { type: t.type, isNullable: n } : null } stringify() { let e = "CASE"; this.valueExpression && (e += ` ${this.valueExpression.stringify()}`); for (let { whenExpression: t, thenExpression: n } of this.conditions) e += ` WHEN ${t.stringify()} THEN ${n.stringify()}`; return this.elseExpression && (e += ` ELSE ${this.elseExpression.stringify()}`), e += " END", e } equals(e) { return e instanceof Bu && qe(this.valueExpression, e.valueExpression) && qe(this.conditions, e.conditions) && qe(this.elseExpression, e.elseExpression) } evaluate(e) { var t, n; let r = ((t = this.valueExpression) == null ? void 0 : t.evaluate(e)) ?? null; for (let { whenExpression: i, thenExpression: o } of this.conditions) { let s = i.evaluate(e); if (this.valueExpression ? Te.equal(s, r, this.collation) : wt(s)) return o.evaluate(e) } return ((n = this.elseExpression) == null ? void 0 : n.evaluate(e)) ?? null } canEvaluate() { let e = []; this.valueExpression && e.push(this.valueExpression); for (let t of this.conditions) e.push(t.whenExpression), e.push(t.thenExpression); return this.elseExpression && e.push(this.elseExpression), e.every(t => t.canEvaluate()) } }, d4 = class { constructor(e, t) { this.whenExpression = e, this.thenExpression = t } }, LC = class extends It { constructor(e) { super(), this.valueExpression = e } equals(e) { return e instanceof LC && qe(this.constructor, e.constructor) && qe(this.valueExpression, e.valueExpression) } canEvaluate() { return this.valueExpression.canEvaluate() } }, ja = class extends LC { constructor() { super(...arguments), T(this, "definition", ja.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `NOT ${this.valueExpression.stringify()}` } evaluate(e) { let t = this.valueExpression.evaluate(e); return { type: "boolean", value: !wt(t) } } }, Wa = class extends It { constructor(e) { super(), this.operandExpressions = e, T(this, "definition", Wa.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return this.operandExpressions.map(e => e.stringify()).join(" AND ") } equals(e) { return e instanceof Wa && qe(this.constructor, e.constructor) && qe(this.operandExpressions, e.operandExpressions) } canEvaluate() { return this.operandExpressions.every(e => e.canEvaluate()) } }, Ji = class extends Wa { constructor() { super(...arguments), T(this, "operator", "AND") } evaluate(e) { return { type: "boolean", value: this.operandExpressions.every(n => { let r = n.evaluate(e); return wt(r) }) } } }, Da = class extends Wa { constructor() { super(...arguments), T(this, "operator", "OR") } evaluate(e) { return { type: "boolean", value: this.operandExpressions.some(n => { let r = n.evaluate(e); return wt(r) }) } } }, Hn = class extends It { constructor(e, t) { super(), this.leftExpression = e, this.rightExpression = t, T(this, "definition", Hn.getDefinition()), T(this, "collation", { type: 0 }) } static getDefinition() { return { type: "boolean", isNullable: !1 } } stringify() { return `${this.leftExpression.stringify()} ${this.operator} ${this.rightExpression.stringify()}` } equals(e) { return e instanceof Hn && qe(this.constructor, e.constructor) && qe(this.leftExpression, e.leftExpression) && qe(this.rightExpression, e.rightExpression) } canEvaluate() { return this.leftExpression.canEvaluate() && this.rightExpression.canEvaluate() } }, ss = class extends Hn { constructor() { super(...arguments), T(this, "operator", "=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Te.equal(t, n, this.collation) } } }, as = class extends Hn { constructor() { super(...arguments), T(this, "operator", "!=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: !Te.equal(t, n, this.collation) } } }, Ua = class extends Hn { constructor() { super(...arguments), T(this, "operator", "<") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Te.lessThan(t, n, this.collation) } } }, Ga = class extends Hn { constructor() { super(...arguments), T(this, "operator", "<=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Te.lessThanOrEqual(t, n, this.collation) } } }, qa = class extends Hn { constructor() { super(...arguments), T(this, "operator", ">") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Te.greaterThan(t, n, this.collation) } } }, Xa = class extends Hn { constructor() { super(...arguments), T(this, "operator", ">=") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Te.greaterThanOrEqual(t, n, this.collation) } } }, h4 = class extends Hn { constructor() { super(...arguments), T(this, "operator", "in") } evaluate(e) { let t = this.leftExpression.evaluate(e), n = this.rightExpression.evaluate(e); return { type: "boolean", value: Te.in(t, n) } } }, ol = class extends It { constructor(e) { super(), this.valueExpression = e } stringify() { return `CAST(${this.valueExpression.stringify()} AS ${this.dataType})` } equals(e) { return e instanceof ol && qe(this.constructor, e.constructor) && qe(this.valueExpression, e.valueExpression) } canEvaluate() { return this.valueExpression.canEvaluate() } }, ef = class extends ol { constructor() { super(...arguments), T(this, "dataType", "BOOLEAN"), T(this, "definition", ef.getDefinition()) } static getDefinition() { return { type: "boolean", isNullable: !1 } } evaluate(e) { let t = this.valueExpression.evaluate(e); return { type: "boolean", value: wt(t) } } }, yg = class extends ol { constructor() { super(...arguments), T(this, "dataType", "DATE"), T(this, "definition", yg.getDefinition()) } static getDefinition() { return { type: "date", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = vg(t); return oe(n) ? null : { type: "date", value: n } } }, bg = class extends ol { constructor() { super(...arguments), T(this, "dataType", "NUMBER"), T(this, "definition", bg.getDefinition()) } static getDefinition() { return { type: "number", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = rl(t); return oe(n) ? null : { type: "number", value: n } } }, xg = class extends ol { constructor() { super(...arguments), T(this, "dataType", "STRING"), T(this, "definition", xg.getDefinition()) } static getDefinition() { return { type: "string", isNullable: !0 } } evaluate(e) { let t = this.valueExpression.evaluate(e), n = $r(t); return oe(n) ? null : { type: "string", value: n } } }; function fr(e, t, n) { let r = p4(e, t, n), i = r instanceof Pe; if (r.canEvaluate() && !i) { let o = r.evaluate(); return new Pe(r.definition, o) } return r } function p4(e, t, n) { switch (e.type) { case "Identifier": return m4(e, t); case "LiteralValue": return g4(e, n); case "FunctionCall": return y4(e, t); case "Case": return b4(e, t, n); case "UnaryOperation": return x4(e, t); case "BinaryOperation": return S4(e, t); case "TypeCast": return L4(e, t); default: throw new Error(`Unsupported expression: ${JSON.stringify(e)}`) } } function m4(e, t) { return new St(t, e.name, e.collection) } function g4(e, t) { var n, r; let i = v4(e.value); switch (t?.type) { case "boolean": { let o = wt(i.value); return Pe.fromBoolean(o) } case "date": { let o = vg(i.value); return Pe.fromDate(o) } case "enum": return ((n = i.value) == null ? void 0 : n.type) === "string" ? Pe.fromEnum(i.value.value) : i; case "number": { let o = rl(i.value); return Pe.fromNumber(o) } case "string": { let o = $r(i.value); return Pe.fromString(o) } case "multicollectionreference": if (((r = i.value) == null ? void 0 : r.type) === "multicollectionreference") return Pe.fromMultiCollectionReference(i.value.value) }return i } function v4(e) { if (Gu(e)) return Pe.fromBoolean(e); if (tg(e)) { let t = e.toISOString(); return Pe.fromDate(t) } return Ae(e) ? Pe.fromNumber(e) : fe(e) ? Pe.fromString(e) : Ja(e) && e.every(fe) ? Pe.fromMultiCollectionReference(e) : Pe.fromNull() } function y4(e, t) { let n = e.arguments.map(r => fr(r, t, void 0)); switch (e.functionName) { case "CONTAINS": return new Qu(n); case "STARTS_WITH": return new Zu(n); case "ENDS_WITH": return new Ju(n); default: throw new Error(`Unsupported function name: ${e.functionName}`) } } function b4(e, t, n) { let r = e.value && fr(e.value, t, void 0), i = e.value && Ya(e.value, t), o = e.conditions.map(a => { let l = fr(a.when, t, i), c = fr(a.then, t, n); return new d4(l, c) }), s = e.else && fr(e.else, t, n); return new Bu(r, o, s) } function x4(e, t) { let n = fr(e.value, t, void 0); switch (e.operator) { case "not": return Lm(n); default: throw new Error(`Unsupported unary operator: ${e.operator}`) } } function Lm(e) { var t; if (e instanceof ja) { let n = e.valueExpression; return ((t = n.definition) == null ? void 0 : t.type) === "boolean" ? n : new ef(n) } if (e instanceof ss) { let { leftExpression: n, rightExpression: r } = e; return new as(n, r) } if (e instanceof as) { let { leftExpression: n, rightExpression: r } = e; return new ss(n, r) } if (e instanceof Ua) { let { leftExpression: n, rightExpression: r } = e; return new Xa(n, r) } if (e instanceof Ga) { let { leftExpression: n, rightExpression: r } = e; return new qa(n, r) } if (e instanceof qa) { let { leftExpression: n, rightExpression: r } = e; return new Ga(n, r) } if (e instanceof Xa) { let { leftExpression: n, rightExpression: r } = e; return new Ua(n, r) } if (e instanceof Ji) { let { operandExpressions: n } = e, r = n.map(Lm); return new Da(r) } if (e instanceof Ji) { let { operandExpressions: n } = e, r = n.map(Lm); return new Ji(r) } return new ja(e) } function w4(e, t) { if (e.operator !== "in" && e.operator !== "and" && e.operator !== "or") return Ya(e.left, t) || Ya(e.right, t) } function S4(e, t) { let n = w4(e, t), r = fr(e.left, t, n), i = fr(e.right, t, n); switch (e.operator) { case "and": return k4(r, i); case "or": return C4(r, i); case "==": return T4(r, i); case "!=": return E4(r, i); case "<": return R4(r, i); case "<=": return P4(r, i); case ">": return _4(r, i); case ">=": return F4(r, i); case "in": return I4(r, i); default: throw new Error(`Unsupported binary operator: ${e.operator}`) } } function k4(e, t) { let n = []; return e instanceof Ji ? n.push(...e.operandExpressions) : n.push(e), t instanceof Ji ? n.push(...t.operandExpressions) : n.push(t), new Ji(n) } function C4(e, t) { let n = []; return e instanceof Da ? n.push(...e.operandExpressions) : n.push(e), t instanceof Da ? n.push(...t.operandExpressions) : n.push(t), new Da(n) } function T4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new ss(t, e) : new ss(e, t) } function E4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new as(t, e) : new as(e, t) } function R4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new qa(t, e) : new Ua(e, t) } function P4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new Xa(t, e) : new Ga(e, t) } function _4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new Ua(t, e) : new qa(e, t) } function F4(e, t) { let n = e instanceof St; return t instanceof St && !n ? new Ga(t, e) : new Xa(e, t) } function I4(e, t) { return new h4(e, t) } function L4(e, t) { let n = fr(e.value, t, void 0); switch (e.dataType) { case "BOOLEAN": return M4(n); case "DATE": return O4(n); case "NUMBER": return D4(n); case "STRING": return A4(n); default: throw new Error(`Unsupported data type: ${e.dataType}`) } } function M4(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "boolean" ? e : new ef(e) } function O4(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "date" ? e : new yg(e) } function D4(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "number" ? e : new bg(e) } function A4(e) { var t; return ((t = e.definition) == null ? void 0 : t.type) === "string" ? e : new xg(e) } function Ya(e, t) { switch (e.type) { case "Identifier": return V4(e, t); case "LiteralValue": return; case "FunctionCall": return B4(e); case "Case": return z4(e, t); case "UnaryOperation": return $4(e); case "BinaryOperation": return N4(e); case "TypeCast": return H4(e); default: throw new Error(`Unsupported expression: ${JSON.stringify(e)}`) } } function V4(e, t) { return t[e.name] } function B4(e) { switch (e.functionName) { case "CONTAINS": return Qu.getDefinition(); case "STARTS_WITH": return Zu.getDefinition(); case "ENDS_WITH": return Ju.getDefinition(); default: throw new Error(`Unsupported function name: ${e.functionName}`) } } function z4(e, t) { let n = []; for (let r of e.conditions) { let i = Ya(r.then, t); it(i) || n.push(i) } if (e.else) { let r = Ya(e.else, t); it(r) || n.push(r) } return Bu.getDefinition(n) ?? void 0 } function $4(e) { switch (e.operator) { case "not": return ja.getDefinition(); default: throw new Error(`Unsupported unary operator: ${e.operator}`) } } function N4(e) { switch (e.operator) { case "and": case "or": return Wa.getDefinition(); case "==": case "!=": case "<": case "<=": case ">": case ">=": return Hn.getDefinition(); default: throw new Error(`Unsupported binary operator: ${e.operator}`) } } function H4(e) { switch (e.dataType) { case "BOOLEAN": return ef.getDefinition(); case "DATE": return yg.getDefinition(); case "NUMBER": return bg.getDefinition(); case "STRING": return xg.getDefinition(); default: throw new Error(`Unsupported data type: ${e.dataType}`) } } function Nr(e, t) { return `(self: ${e}ms${t ? `, total: ${t}ms` : ""})` } function jn(e) { return `(items: ${e})` } var Hr = class { constructor() { T(this, "executionTime", 0), T(this, "itemCount", 0) } async execute() { let e = performance.now(), t = await this._execute(); return this.executionTime = performance.now() - e, this.itemCount = t.length, t } }, MC = class extends Hr { constructor(e, t) { super(), this.collection = e, this.alias = t } inspect() { return { label: `ScanCollectionPlan ${Nr(this.executionTime)} ${jn(this.itemCount)}` } } async _execute() { let e = await this.collection.scanItems(); return it(this.alias) ? e : e.map(t => { let n = { ...t.data }, r = Object.entries(n); for (let [i, o] of r) n[`${this.alias}_${i}`] = o; return { pointer: t.pointer, data: n } }) } }, j4 = class extends Hr { constructor(e, t, n) { super(), this.leftPlan = e, this.rightPlan = t, this.constraint = n } inspect() { let e = Math.max(this.leftPlan.executionTime ?? 0, this.rightPlan.executionTime ?? 0); return { label: `LeftJoinPlan ${Nr(this.executionTime - e, this.executionTime)} ${jn(this.itemCount)}`, nodes: [this.leftPlan.inspect(), this.rightPlan.inspect()] } } async _execute() { var e; let t = await this.leftPlan.execute(), n = await this.rightPlan.execute(), r = []; for (let i of t) { let o = !1; for (let s of n) { let a = { pointer: i.pointer, data: { ...i.data, ...s.data } }; (e = this.constraint.evaluate(a)) != null && e.value && (r.push(a), o = !0) } o || r.push(i) } return r } }, Vr = class extends Hr { constructor(e, t) { super(), this.index = e, this.query = t } inspect() { let e = [], t = n => { switch (n.type) { case "All": return n.type; case "Equals": case "NotEquals": case "LessThan": case "GreaterThan": case "Contains": case "StartsWith": case "EndsWith": return `${n.type} ${Te.stringify(n.value)}`; default: xe(n) } }; for (let n = 0; n < this.index.fields.length; n++) { let r = this.index.fields[n], i = this.query[n]; !r || r.type !== "Identifier" || !i || i.type === "All" || e.push(`${r.name} ${t(i)}`) } return { label: `LookupIndexPlan(${e.join(", ")}) ${Nr(this.executionTime)} ${jn(this.itemCount)}` } } async _execute() { return this.index.lookupItems(this.query) } }, W4 = class extends Hr { constructor(e) { super(), this.childPlans = e } inspect() { let e = Math.max(...this.childPlans.map(t => t.executionTime ?? 0)); return { label: `UnionPlan ${Nr(this.executionTime - e, this.executionTime)} ${jn(this.itemCount)}`, nodes: this.childPlans.map(t => t.inspect()) } } async _execute() { let e = await Promise.all(this.childPlans.map(async n => { let r = await n.execute(); return new zu(r) })), t; for (let n of e) t ? t = t.union(n) : t = n; return t?.items() ?? [] } }, U4 = class extends Hr { constructor(e) { super(), this.childPlans = e } inspect() { let e = Math.max(...this.childPlans.map(t => t.executionTime ?? 0)); return { label: `IntersectionPlan ${Nr(this.executionTime - e, this.executionTime)} ${jn(this.itemCount)} ${jn(this.itemCount)}`, nodes: this.childPlans.map(t => t.inspect()) } } async _execute() { let e = await Promise.all(this.childPlans.map(async n => { let r = await n.execute(); return new zu(r) })), t; for (let n of e) t ? t = t.intersection(n) : t = n; return t?.items() ?? [] } }, G4 = class extends Hr { constructor(e, t, n, r) { super(), this.childPlan = e, this.collection = t, this.richTextResolver = n, this.select = r } inspect() { return { label: `ResolveItemsPlan ${Nr(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${jn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { let e = await this.childPlan.execute(), t = e.map(n => n.pointer); for (let n of e) for (let r of this.select) { if (r.type !== "Identifier") continue; let i = n.data[r.name]; i?.type === "richtext" && this.richTextResolver.resolve(r.name, i.value) } return this.collection.resolveItems(t) } }, OC = class extends Hr { constructor(e, t) { super(), this.childPlan = e, this.filterExpression = t } inspect() { return { label: `FilterItemsPlan(${this.filterExpression.stringify()}) ${Nr(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${jn(this.itemCount)} ${jn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { return (await this.childPlan.execute()).filter(t => { let n = this.filterExpression.evaluate(t); return wt(n) }) } }, q4 = class extends Hr { constructor(e, t, n) { super(), this.childPlan = e, this.orderExpressions = t, this.collection = n } inspect() { return { label: `SortItemsPlan(${this.orderExpressions.map(t => `${t.expression.stringify()} ${t.direction.toUpperCase()}`).join(", ")}) ${Nr(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${jn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } async _execute() { return (await this.childPlan.execute()).sort((t, n) => { let r = { ...t, data: {} }, i = { ...n, data: {} }; for (let { expression: o, direction: s, collation: a } of this.orderExpressions) { let l = s === "asc"; if (o instanceof St && o.name === Im) { let f = this.collection.compareItems(r, i); return l ? f : -f } let c = o.evaluate(t), u = o.evaluate(n); if (!Te.equal(c, u, a)) { if (Te.lessThan(c, u, a) || os(c)) return l ? -1 : 1; if (Te.greaterThan(c, u, a) || os(u)) return l ? 1 : -1; throw new Error("Invalid comparison result.") } } return this.collection.compareItems(r, i) }) } }, X4 = class { constructor(e, t, n) { this.expression = e, this.direction = t, this.collation = n } }, Y4 = class extends Hr { constructor(e, t, n) { super(), this.childPlan = e, this.offsetExpression = t, this.limitExpression = n } inspect() { var e, t; return { label: `SliceItemsPlan(LIMIT ${((e = this.limitExpression) == null ? void 0 : e.stringify()) ?? "Infinity"}, OFFSET ${((t = this.offsetExpression) == null ? void 0 : t.stringify()) ?? "0"}) ${Nr(this.executionTime - this.childPlan.executionTime, this.executionTime)} ${jn(this.itemCount)}`, nodes: [this.childPlan.inspect()] } } getOffset() { var e; let t = (e = this.offsetExpression) == null ? void 0 : e.evaluate(); if (!(os(t) || t.type !== "number")) return t.value } getLimit() { var e; let t = (e = this.limitExpression) == null ? void 0 : e.evaluate(); if (!(os(t) || t.type !== "number")) return t.value } async _execute() { let e = await this.childPlan.execute(), t = this.getOffset() ?? 0, n = this.getLimit() ?? 1 / 0; return e.slice(t, t + n) } }, zu = class extends Map { constructor(e = []) { super(); for (let t of e) this.set(t.pointer, t) } union(e) { let t = new zu; for (let [n, r] of this) t.set(n, r); for (let [n, r] of e) t.set(n, r); return t } intersection(e) { let t = new zu; for (let [n, r] of this) e.has(n) && t.set(n, r); return t } items() { return [...this.values()] } }, K4 = class { constructor(e) { this.collections = e, T(this, "cache", new Map) } resolve(e, t) { let n = this.cache.get(e) ?? new Map; this.cache.set(e, n); let r = n.get(t); if (r) return r; for (let i of this.collections) if (e in i.schema) { let o = i.resolveRichText(t); return n.set(t, o), o } throw new Error(`Rich text field not found: ${e}`) } }; function Q4(e) { return Me(e) && ki(e.getHash) } function he(e, ...t) { let n = t.map(r => Q4(r) ? r.getHash() : JSON.stringify(r)); return `${e}(${n.join(", ")})` } var wg = class { constructor(e, t) { this.data = e, this.pointer = t, T(this, "cached") } resolve() { return this.cached ?? (this.cached = this.data.resolveRichText(this.pointer)), this.cached } }, ls = "index", DC = class extends Set { merge(e) { for (let t of e) this.add(t) } equals(e) { if (this === e) return !0; if (this.size !== e.size) return !1; for (let t of this) if (!e.has(t)) return !1; return !0 } subsetOf(e) { if (this === e) return !0; if (this.size > e.size) return !1; for (let t of this) if (!e.has(t)) return !1; return !0 } getHash() { let e = []; for (let t of this) e.push(t.id); return e.sort((t, n) => t - n), he(this.name, ...e) } }; var Z4 = class { constructor(e, t, n) { this.id = e, this.name = t, this.data = n, T(this, "indexes", new eB), T(this, "fields", new de) } }; var J4 = class { constructor(e, t, n, r, i, o) { this.id = e, this.data = t, this.collection = n, this.lookupNodes = r, this.constraint = i, this.ordering = o, T(this, "resolvedFields", new de); for (let s in t.schema) for (let a of n.fields) a.name === s && this.resolvedFields.add(a) } }, eB = class extends DC { constructor() { super(...arguments), T(this, "name", "Indexes") } }; var HS = class { constructor(e, t, n, r) { this.id = e, this.name = t, this.definition = n, this.collection = r } getValue(e) { let t = e.data[this.name]; return t?.type === "richtext" ? (H(this.collection, "Rich text field must have a collection"), { type: "richtext", value: new wg(this.collection.data, t.value) }) : t ?? null } }, de = class extends DC { constructor() { super(...arguments), T(this, "name", "Fields") } }, AC = class { }, us = { type: 0 }, dt = class extends AC { constructor(e) { super(), this.referencedFields = e } }, tB = { type: 0 }, VC = class { constructor(e, t) { this.when = e, this.then = t } getHash() { return he("CaseCondition", this.when, this.then) } }, nB = class extends dt { constructor(e, t, n) { let r = new de; e && r.merge(e.referencedFields); for (let i of t) r.merge(i.when.referencedFields), r.merge(i.then.referencedFields); n && r.merge(n.referencedFields), super(r), this.input = e, this.conditions = t, this.otherwise = n, T(this, "definition", { type: "unknown", isNullable: !0 }) } getHash() { return he("ScalarCase", this.input, ...this.conditions, this.otherwise) } toString() { let e = "CASE"; this.input && (e = `${e} ${this.input}`); for (let { when: t, then: n } of this.conditions) e = `${e} WHEN ${t} THEN ${n}`; return this.otherwise && (e = `${e} ELSE ${this.otherwise}`), `${e} END` } evaluate(e) { var t, n; let r = ((t = this.input) == null ? void 0 : t.evaluate(e)) ?? null; for (let i of this.conditions) { let o = i.when.evaluate(e); if (this.input ? Te.equal(r, o, tB) : wt(o)) return i.then.evaluate(e) } return ((n = this.otherwise) == null ? void 0 : n.evaluate(e)) ?? null } }, BC = class { constructor(e, t = "asc") { this.field = e, this.direction = t } getHash() { return he("OrderingField", this.field.id, this.direction) } }, hr = class { constructor(e) { this.ordering = e, T(this, "fields", []), e && this.fields.push(...e.fields) } get length() { return this.fields.length } getHash() { return he("Ordering", ...this.fields) } push(e) { this.fields.push(e) } equals(e) { return this === e ? !0 : this.length !== e.length ? !1 : this.getHash() === e.getHash() } }, Wn = class { constructor(e, t) { this.ordering = e, this.resolvedFields = t } getHash() { return he("RequiredProps", this.ordering, this.resolvedFields) } get isMinimal() { return this.ordering.length === 0 && this.resolvedFields.size === 0 } canProvide(e) { return this.canProvideOrdering(e) && this.canProvideResolvedFields(e) } canProvideOrdering(e) { return this.ordering.length === 0 ? !0 : e.canProvideOrdering(this.ordering) } canProvideResolvedFields(e) { return this.resolvedFields.size === 0 ? !0 : e.canProvideResolvedFields(this.resolvedFields) } }, Mm = class { constructor(e) { this.parent = e, T(this, "node"), T(this, "defaultOrdering", new hr), T(this, "ordering"), T(this, "fields", []), this.defaultOrdering = new hr(e?.defaultOrdering) } takeNode() { let e = this.node; return H(e, "Node is missing"), this.node = void 0, e } setNode(e) { H(!this.node, "Node already set"), this.node = e } setOrdering(e) { this.ordering = e } push() { return new Mm(this) } replace() { return new Mm(this.parent) } addField(e) { if (this.fields.push(e), e.field.name === ls) { let t = new BC(e.field); this.defaultOrdering.push(t) } } addFieldsFromScope(e) { for (let t of e.fields) this.addField(t) } resolveField(e, t) { var n; let r = []; for (let i of this.fields) i.name === e && (t && i.collectionName !== t || r.push(i)); if (r.length === 1) return r[0]; if (r.length > 1) throw new Error("Ambiguous fields"); return (n = this.parent) == null ? void 0 : n.resolveField(e, t) } getRequiredOrdering() { let e = new hr(this.ordering); for (let t of this.defaultOrdering.fields) e.push(t); return e } getRequiredResolvedFields() { let e = new de; for (let { field: t } of this.fields) t.collection && e.add(t); return e } getRequiredProps() { let e = this.getRequiredOrdering(), t = this.getRequiredResolvedFields(); return new Wn(e, t) } getNamedFields() { let e = new Map; for (let { name: t, field: n } of this.fields) e.set(t, n); return e } }, rB = class { constructor(e, t, n) { this.normalizer = e, this.query = t, this.locale = n, T(this, "collectionId", 0), T(this, "indexId", 0), T(this, "fieldId", 0) } build() { let e = new Mm; return this.buildQuery(e, this.query) } buildQuery(e, t) { let n = { type: "Select", ...t }; return this.buildSelect(e, n) } buildSelect(e, t) { let n = this.buildFrom(e, t.from); if (t.where) { let o = n.takeNode(), s = this.buildExpression(n, t.where), a = this.normalizer.newRelationalFilter(o, s); n.setNode(a) } let r = this.buildSelectList(n, t.select); if (t.orderBy) { let o = new hr; for (let s of t.orderBy) { H(s.type === "Identifier", "Unsupported order type"); let a = n.resolveField(s.name, s.collection); if (it(a)) continue; let l = new BC(a.field, s.direction); o.push(l) } r.setOrdering(o) } let i = r.getRequiredOrdering(); if (t.offset) { let o = r.takeNode(), s = this.buildExpression(e, t.offset), a = this.normalizer.newRelationalOffset(o, s, i); r.setNode(a) } if (t.limit) { let o = r.takeNode(), s = this.buildExpression(e, t.limit), a = this.normalizer.newRelationalLimit(o, s, i); r.setNode(a) } return r } buildSelectList(e, t) { let n = e.push(), r = new de; for (let s of t) { H(s.type === "Identifier", "Unsupported select type"); let a = e.resolveField(s.name, s.collection); it(a) || (r.add(a.field), n.addField({ ...a, name: s.alias ?? a.name })) } let i = e.takeNode(), o = this.normalizer.newRelationalProject(i, [], r); return n.setNode(o), n } buildFrom(e, t) { switch (t.type) { case "Collection": return this.buildCollection(e, t); case "LeftJoin": return this.buildJoin(e, t); default: xe(t, "Unsupported from type") } } buildCollection(e, t) { let n = e.push(), r = iB(t.data, this.locale), i = t.alias, o = this.collectionId++, s = new Z4(o, i, r); for (let [l, c] of Object.entries(r.schema)) { let u = this.fieldId++, f = new HS(u, l, c, s); n.addField({ field: f, name: l, collectionName: i }), s.fields.add(f) } { let l = { type: "number", isNullable: !1 }, c = this.fieldId++, u = new HS(c, ls, l, s); n.addField({ field: u, name: ls, collectionName: i }) } for (let l of r.indexes) { let c = []; for (let y of l.fields) { let g = this.buildExpression(n, y); c.push(g) } let u; l.where && (u = this.buildExpression(n, l.where)); let f = new hr, d = this.indexId++, m = new J4(d, l, s, c, u, f); s.indexes.add(m) } let a = this.normalizer.newRelationalScan(s); return n.setNode(a), n } buildJoin(e, t) { let n = this.buildFrom(e, t.left), r = this.buildFrom(e, t.right), i = e.push(); i.addFieldsFromScope(n), i.addFieldsFromScope(r); let o = this.buildExpression(i, t.constraint), s = n.takeNode(), a = r.takeNode(), l; switch (t.type) { case "LeftJoin": l = this.normalizer.newRelationalLeftJoin(s, a, o); break; default: xe(t.type, "Unsupported join type") }return i.setNode(l), i } buildExpression(e, t) { switch (t.type) { case "Identifier": return this.buildIdentifier(e, t); case "LiteralValue": return this.buildLiteralValue(e, t); case "FunctionCall": return this.buildFunctionCall(e, t); case "Case": return this.buildCase(e, t); case "UnaryOperation": return this.buildUnaryOperation(e, t); case "BinaryOperation": return this.buildBinaryOperation(e, t); case "TypeCast": return this.buildTypeCast(e, t); default: xe(t, "Unsupported expression") } } buildIdentifier(e, t) { let n = e.resolveField(t.name, t.collection); if (n) return this.normalizer.newScalarVariable(n.field); let r = { type: "unknown", isNullable: !0 }; return this.normalizer.newScalarConstant(r, null) } buildLiteralValue(e, t) { let n = oB(t.value), r = { type: "unknown", isNullable: !0 }; return this.normalizer.newScalarConstant(r, n) } buildFunctionCall(e, t) { let n = t.arguments[0]; H(n, "Invalid arguments"); let r = this.buildExpression(e, n), i = t.arguments[1]; H(i, "Invalid arguments"); let o = this.buildExpression(e, i); switch (t.functionName) { case "CONTAINS": return this.normalizer.newScalarContains(r, o); case "STARTS_WITH": return this.normalizer.newScalarStartsWith(r, o); case "ENDS_WITH": return this.normalizer.newScalarEndsWith(r, o); default: throw new Error("Unsupported function name") } } buildCase(e, t) { let n; t.value && (n = this.buildExpression(e, t.value)); let r = t.conditions.map(o => { let s = this.buildExpression(e, o.when), a = this.buildExpression(e, o.then); return new VC(s, a) }), i; return t.else && (i = this.buildExpression(e, t.else)), this.normalizer.newScalarCase(n, r, i) } buildUnaryOperation(e, t) { let n = this.buildExpression(e, t.value); switch (t.operator) { case "not": return this.normalizer.newScalarNot(n); default: xe(t.operator, "Unsupported unary operator") } } buildBinaryOperation(e, t) { let n = this.buildExpression(e, t.left), r = this.buildExpression(e, t.right); switch (t.operator) { case "and": return this.normalizer.newScalarAnd(n, r); case "or": return this.normalizer.newScalarOr(n, r); case "==": return this.normalizer.newScalarEquals(n, r); case "!=": return this.normalizer.newScalarNotEquals(n, r); case "<": return this.normalizer.newScalarLessThan(n, r); case "<=": return this.normalizer.newScalarLessThanOrEqual(n, r); case ">": return this.normalizer.newScalarGreaterThan(n, r); case ">=": return this.normalizer.newScalarGreaterThanOrEqual(n, r); case "in": return this.normalizer.newScalarIn(n, r); default: xe(t.operator, "Unsupported binary operator") } } buildTypeCast(e, t) { let n = this.buildExpression(e, t.value); switch (t.dataType) { case "BOOLEAN": { let r = { type: "boolean", isNullable: !0 }; return this.normalizer.newScalarCast(n, r) } case "DATE": { let r = { type: "date", isNullable: !0 }; return this.normalizer.newScalarCast(n, r) } case "NUMBER": { let r = { type: "number", isNullable: !0 }; return this.normalizer.newScalarCast(n, r) } case "STRING": { let r = { type: "string", isNullable: !0 }; return this.normalizer.newScalarCast(n, r) } default: throw new Error("Unsupported data type") } } }; function iB(e, t) { if (_C(e)) return new IC(e, t); if (gg(e)) return e; if (FC(e)) { for (; t;) { let n = e.collectionByLocaleId[t.id]; if (n) return n; t = t.fallback } return e.collectionByLocaleId.default } xe(e, "Unsupported collection type") } function oB(e) { return Gu(e) ? { type: "boolean", value: e } : tg(e) ? { type: "date", value: e.toISOString() } : Ae(e) ? { type: "number", value: e } : fe(e) ? { type: "string", value: e } : Ja(e) && e.every(fe) ? { type: "multicollectionreference", value: e } : null } function sB() { return 25 } function aB() { return 100 * 125 } var $u = 1e3, kt = class { constructor(e) { this.network = e } static estimate(e, t) { let n = sB(), r = aB(), i = e * n + t / r; return new kt(i) } static max(e, t) { let n = Math.max(e.network, t.network); return new kt(n) } static compare(e, t) { return e.network < t.network ? -1 : e.network > t.network ? 1 : 0 } add(e) { return this.network += e.network, this } toString() { return `${this.network}ms` } }, Un = class extends AC { constructor() { super(...arguments), T(this, "group") } getGroup() { return H(this.group, "Node must be in a group"), this.group } setGroup(e) { H(!this.group, "Node is already in a group"), this.group = e } }, Nu = class extends Un { constructor(e, t) { super(), this.input = e, this.predicate = t, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("RelationalFilter", this.inputGroup.id, this.predicate) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering() { return !0 } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); return t.merge(this.predicate.referencedFields), new Wn(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new Nu(n, this.predicate) } async execute() { return (await this.input.execute()).filter(t => { let n = this.predicate.evaluate(t); return wt(n) }) } }, fs = class { constructor() { T(this, "pointers", new Map), T(this, "values", new Map) } getKey() { let e = this.pointers.values(); return Array.from(e).join("-") } addValue(e, t) { this.values.set(e, t) } getValue(e) { return this.values.get(e) ?? null } mergeValues(e) { for (let [t, n] of e.values) this.addValue(t, n) } addPointer(e, t) { this.pointers.set(e, t) } getPointer(e) { return this.pointers.get(e) } mergePointers(e) { for (let [t, n] of e.pointers) this.addPointer(t, n) } merge(e) { this.mergeValues(e), this.mergePointers(e) } }, ur = class { constructor(e, t = []) { this.fields = e, this.tuples = t } push(e) { this.tuples.push(e) } filter(e) { let t = this.tuples.filter(e); return new ur(this.fields, t) } map(e, t) { let n = this.tuples.map(t); return new ur(e, n) } sort(e) { let t = Array.from(this.tuples).sort(e); return new ur(this.fields, t) } slice(e, t) { let n = this.tuples.slice(e, t); return new ur(this.fields, n) } union(e) { let t = new de; for (let i of this.fields) e.fields.has(i) && t.add(i); let n = new Set, r = new ur(t); for (let i of this.tuples) { let o = i.getKey(); n.add(o), r.push(i) } for (let i of e.tuples) { let o = i.getKey(); n.has(o) || r.push(i) } return r } intersection(e) { let t = new de; for (let i of this.fields) e.fields.has(i) && t.add(i); let n = new Set, r = new ur(t); for (let i of this.tuples) { let o = i.getKey(); n.add(o) } for (let i of e.tuples) { let o = i.getKey(); n.has(o) && r.push(i) } return r } }, Cn = class extends Un { constructor(e, t) { super(), this.index = e, this.query = t } getHash() { return he("RelationalIndexLookup", this.index.id, ...this.query) } getOutputFields() { return this.index.collection.fields } canProvideOrdering(e) { return e.equals(this.index.ordering) } canProvideResolvedFields(e) { return e.subsetOf(this.index.resolvedFields) } optimize() { let e = this.query.every(t => t.type === "All"); return kt.estimate(1, e ? 100 * $u : 50 * $u) } getOptimized() { return new Cn(this.index, this.query) } async execute() { let e = this.index, t = e.collection, n = this.getOutputFields(), i = (await e.data.lookupItems(this.query)).map(o => { let s = new fs; for (let a of e.resolvedFields) { let l = a.getValue(o); s.addPointer(t, o.pointer), s.addValue(a, l) } return s }); return new ur(n, i) } }, zC = class extends Un { constructor(e, t) { super(), this.left = e, this.right = t, T(this, "leftGroup", this.left.getGroup()), T(this, "rightGroup", this.right.getGroup()) } getHash() { return he("RelationalIntersection", this.leftGroup.id, this.rightGroup.id) } getOutputFields() { let e = new de, t = this.leftGroup.relational.outputFields, n = this.rightGroup.relational.outputFields; for (let r of t) n.has(r) && e.add(r); return e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e) { let t = new hr; return new Wn(t, e.resolvedFields) } optimize(e, t) { let n = this.getChildRequiredProps(t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(t), o = e.optimizeGroup(this.rightGroup, i); return kt.max(r, o) } getOptimized(e) { let t = this.getChildRequiredProps(e), n = this.leftGroup.getOptimized(t), r = this.getChildRequiredProps(e), i = this.rightGroup.getOptimized(r); return new zC(n, i) } async execute() { let e = await this.left.execute(), t = await this.right.execute(); return e.intersection(t) } }, Hu = class extends Un { constructor(e, t, n) { super(), this.left = e, this.right = t, this.constraint = n, T(this, "leftGroup", this.left.getGroup()), T(this, "rightGroup", this.right.getGroup()) } getHash() { return he("RelationalLeftJoin", this.leftGroup.id, this.rightGroup.id, this.constraint) } getOutputFields() { let e = new de; return e.merge(this.leftGroup.relational.outputFields), e.merge(this.rightGroup.relational.outputFields), e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e, t) { let n = new de, r = e.relational.outputFields; for (let o of t.resolvedFields) r.has(o) && n.add(o); for (let o of this.constraint.referencedFields) r.has(o) && n.add(o); let i = new hr; return new Wn(i, n) } optimize(e, t) { let n = this.getChildRequiredProps(this.leftGroup, t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(this.rightGroup, t), o = e.optimizeGroup(this.rightGroup, i); return kt.max(r, o) } getOptimized(e) { let t = this.getChildRequiredProps(this.leftGroup, e), n = this.leftGroup.getOptimized(t), r = this.getChildRequiredProps(this.rightGroup, e), i = this.rightGroup.getOptimized(r); return new Hu(n, i, this.constraint) } async execute() { let e = await this.left.execute(), t = await this.right.execute(), n = this.getOutputFields(), r = new ur(n); for (let i of e.tuples) { let o = !1; for (let s of t.tuples) { let a = new fs; a.merge(i), a.merge(s); let l = this.constraint.evaluate(a); wt(l) && (r.push(a), o = !0) } o || r.push(i) } return r } }, Sg = class extends Un { constructor(e, t, n) { super(), this.left = e, this.right = t, this.constraint = n, T(this, "leftGroup", this.left.getGroup()), T(this, "rightGroup", this.right.getGroup()) } getHash() { return he("RelationalRightJoin", this.leftGroup.id, this.rightGroup.id, this.constraint) } getOutputFields() { let e = new de; return e.merge(this.leftGroup.relational.outputFields), e.merge(this.rightGroup.relational.outputFields), e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e, t) { let n = new de, r = e.relational.outputFields; for (let o of t.resolvedFields) r.has(o) && n.add(o); for (let o of this.constraint.referencedFields) r.has(o) && n.add(o); let i = new hr; return new Wn(i, n) } optimize(e, t) { let n = this.getChildRequiredProps(this.leftGroup, t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(this.rightGroup, t), o = e.optimizeGroup(this.rightGroup, i), s = kt.max(r, o); return new kt(0).add(s) } getOptimized(e) { let t = this.getChildRequiredProps(this.leftGroup, e), n = this.leftGroup.getOptimized(t), r = this.getChildRequiredProps(this.rightGroup, e), i = this.rightGroup.getOptimized(r); return new Sg(n, i, this.constraint) } async execute() { let e = await this.left.execute(), t = await this.right.execute(), n = this.getOutputFields(), r = new ur(n); for (let i of t.tuples) { let o = !1; for (let s of e.tuples) { let a = new fs; a.merge(i), a.merge(s); let l = this.constraint.evaluate(a); wt(l) && (r.push(a), o = !0) } o || r.push(i) } return r } }, ju = class extends Un { constructor(e) { super(), this.collection = e } getHash() { return he("RelationalScan", this.collection.id) } getOutputFields() { return this.collection.fields } canProvideOrdering() { return !1 } canProvideResolvedFields(e) { return e.subsetOf(this.collection.fields) } optimize() { return kt.estimate(1, 200 * $u) } getOptimized() { return new ju(this.collection) } async execute() { let e = this.collection, t = this.getOutputFields(), r = (await e.data.scanItems()).map(i => { let o = new fs; for (let s of t) { let a = s.getValue(i); o.addPointer(e, i.pointer), o.addValue(s, a) } return o }); return new ur(t, r) } }, $C = class extends Un { constructor(e, t) { super(), this.left = e, this.right = t, T(this, "leftGroup", this.left.getGroup()), T(this, "rightGroup", this.right.getGroup()) } getHash() { return he("RelationalUnion", this.leftGroup.id, this.rightGroup.id) } getOutputFields() { let e = new de, t = this.leftGroup.relational.outputFields, n = this.rightGroup.relational.outputFields; for (let r of t) n.has(r) && e.add(r); return e } canProvideOrdering() { return !1 } canProvideResolvedFields() { return !0 } getChildRequiredProps(e) { let t = new hr; return new Wn(t, e.resolvedFields) } optimize(e, t) { let n = this.getChildRequiredProps(t), r = e.optimizeGroup(this.leftGroup, n), i = this.getChildRequiredProps(t), o = e.optimizeGroup(this.rightGroup, i); return kt.max(r, o) } getOptimized(e) { let t = this.getChildRequiredProps(e), n = this.leftGroup.getOptimized(t), r = this.getChildRequiredProps(e), i = this.rightGroup.getOptimized(r); return new $C(n, i) } async execute() { let e = await this.left.execute(), t = await this.right.execute(); return e.union(t) } }, Om = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarAnd", this.left, this.right) } toString() { return `${this.left} && ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: wt(t) && wt(n) } } }, zn = class extends dt { constructor(e, t) { let n = new de; super(n), this.definition = e, this.value = t } getHash() { return he("ScalarConstant", this.definition, this.value) } toString() { return Te.stringify(this.value) } evaluate() { return this.value } }, NC = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.source = e, this.target = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarContains", this.source, this.target) } toString() { return `CONTAINS(${this.source}, ${this.target})` } getValue(e, t) { let n = $r(e), r = $r(t); if (oe(n) || oe(r)) return !1; let i = n.toLowerCase(), o = r.toLowerCase(); return i.includes(o) } evaluate(e) { let t = this.source.evaluate(e), n = this.target.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, HC = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.source = e, this.target = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarEndsWith", this.source, this.target) } toString() { return `ENDS_WITH(${this.source}, ${this.target})` } getValue(e, t) { let n = $r(e), r = $r(t); if (oe(n) || oe(r)) return !1; let i = n.toLowerCase(), o = r.toLowerCase(); return i.endsWith(o) } evaluate(e) { let t = this.source.evaluate(e), n = this.target.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, Dm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarEquals", this.left, this.right) } toString() { return `${this.left} == ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Te.equal(t, n, us) } } }, Am = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarGreaterThan", this.left, this.right) } toString() { return `${this.left} > ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Te.greaterThan(t, n, us) } } }, Vm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarGreaterThanOrEqual", this.left, this.right) } toString() { return `${this.left} >= ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Te.greaterThanOrEqual(t, n, us) } } }, Bm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarLessThan", this.left, this.right) } toString() { return `${this.left} < ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Te.lessThan(t, n, us) } } }, zm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarLessThanOrEqual", this.left, this.right) } toString() { return `${this.left} <= ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Te.lessThanOrEqual(t, n, us) } } }, $m = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarNotEquals", this.left, this.right) } toString() { return `${this.left} != ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: !Te.equal(t, n, us) } } }, Nm = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarOr", this.left, this.right) } toString() { return `${this.left} || ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: wt(t) || wt(n) } } }, jC = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.source = e, this.target = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarStartsWith", this.source, this.target) } toString() { return `STARTS_WITH(${this.source}, ${this.target})` } getValue(e, t) { let n = $r(e), r = $r(t); if (oe(n) || oe(r)) return !1; let i = n.toLowerCase(), o = r.toLowerCase(); return i.startsWith(o) } evaluate(e) { let t = this.source.evaluate(e), n = this.target.evaluate(e); return { type: "boolean", value: this.getValue(t, n) } } }, lB = class { constructor(e) { this.normalizer = e, T(this, "memo", this.normalizer.memo) } explore(e) { let t = e.getGroup(); if (e instanceof Hu) { let n = new Sg(e.left, e.right, e.constraint); this.memo.addRelational(n, t) } if (e instanceof Nu) { if (e.predicate instanceof Om) { let n = this.normalizer.newRelationalFilter(e.input, e.predicate.left), r = this.normalizer.newRelationalFilter(e.input, e.predicate.right), i = new zC(n, r); this.memo.addRelational(i, t) } if (e.predicate instanceof Nm) { let n = this.normalizer.newRelationalFilter(e.input, e.predicate.left), r = this.normalizer.newRelationalFilter(e.input, e.predicate.right), i = new $C(n, r); this.memo.addRelational(i, t) } } if (e instanceof ju) for (let n of e.collection.indexes) { if (n.constraint) continue; let r = cr(n.lookupNodes.length), i = new Cn(n, r); this.memo.addRelational(i, t) } if (e instanceof Nu) { for (let n of e.inputGroup.nodes) if (n instanceof ju) for (let r of n.collection.indexes) { if (e.predicate instanceof Dm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("Equals")) { let i = cr(r.lookupNodes.length); i[0] = { type: "Equals", value: e.predicate.right.value }; let o = new Cn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof $m && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("NotEquals")) { let i = cr(r.lookupNodes.length); i[0] = { type: "NotEquals", value: e.predicate.right.value }; let o = new Cn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof Bm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("LessThan")) { let i = cr(r.lookupNodes.length); i[0] = { type: "LessThan", value: e.predicate.right.value, inclusive: !1 }; let o = new Cn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof zm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("LessThan")) { let i = cr(r.lookupNodes.length); i[0] = { type: "LessThan", value: e.predicate.right.value, inclusive: !0 }; let o = new Cn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof Am && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("GreaterThan")) { let i = cr(r.lookupNodes.length); i[0] = { type: "GreaterThan", value: e.predicate.right.value, inclusive: !1 }; let o = new Cn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof Vm && e.predicate.left === r.lookupNodes[0] && e.predicate.right instanceof zn && r.data.supportedLookupTypes.includes("GreaterThan")) { let i = cr(r.lookupNodes.length); i[0] = { type: "GreaterThan", value: e.predicate.right.value, inclusive: !0 }; let o = new Cn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof NC && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof zn && r.data.supportedLookupTypes.includes("Contains")) { let i = cr(r.lookupNodes.length); i[0] = { type: "Contains", value: e.predicate.target.value }; let o = new Cn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof jC && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof zn && r.data.supportedLookupTypes.includes("StartsWith")) { let i = cr(r.lookupNodes.length); i[0] = { type: "StartsWith", value: e.predicate.target.value }; let o = new Cn(r, i); this.memo.addRelational(o, t) } if (e.predicate instanceof HC && e.predicate.source === r.lookupNodes[0] && e.predicate.target instanceof zn && r.data.supportedLookupTypes.includes("EndsWith")) { let i = cr(r.lookupNodes.length); i[0] = { type: "EndsWith", value: e.predicate.target.value }; let o = new Cn(r, i); this.memo.addRelational(o, t) } } } } }; function cr(e) { let t = { type: "All" }; return new Array(e).fill(t) } var cB = class { constructor(e, t) { this.id = e, this.relational = t, T(this, "nodes", []), T(this, "winners", new Map) } addNode(e) { this.nodes.push(e), e.setGroup(this) } getWinner(e) { let t = e.getHash(), n = this.winners.get(t); if (n) return n; let r = new uB; return this.winners.set(t, r), r } getOptimized(e) { let t = this.getWinner(e); H(t.node, "Group not optimized"); let n = t.node.getOptimized(e); return n.setGroup(this), n } }, uB = class { constructor() { T(this, "node"), T(this, "cost", new kt(1 / 0)) } update(e, t) { kt.compare(t, this.cost) < 0 && (this.node = e, this.cost = t) } }, fB = class { constructor(e) { this.outputFields = e } isCompatible(e) { return this.outputFields.equals(e.outputFields) } }, dB = class { constructor() { T(this, "nodes", new Map), T(this, "groups", []) } addGroup(e) { let t = this.groups.length, n = new cB(t, e); return this.groups.push(n), n } addRelational(e, t) { let n = e.getHash(), r = this.nodes.get(n); if (r) return r; this.nodes.set(n, e); let i = e.getOutputFields(), o = new fB(i); return t ?? (t = this.addGroup(o)), t.addNode(e), H(o.isCompatible(t.relational), "Group has inconsistent relational props"), e } addScalar(e) { let t = e.getHash(), n = this.nodes.get(t); return n || (this.nodes.set(t, e), e) } }, WC = class extends Un { }, UC = class extends WC { constructor(e, t) { super(), this.input = e, this.fields = t, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("EnforcerResolve", this.inputGroup.id, this.fields) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering() { return !0 } canProvideResolvedFields(e) { return e.subsetOf(this.fields) } getInputRequiredProps(e) { let t = new de; return new Wn(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return kt.estimate(0, 100 * $u).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new UC(n, this.fields) } async execute() { let e = await this.input.execute(); H(this.fields.subsetOf(e.fields), "Fields can't be resolved"); let t = new Set; for (let r of this.fields) H(r.collection, "Collection required to resolve field"), t.add(r.collection); for (let r of e.tuples) for (let i of this.fields) { let o = r.getValue(i); o?.type === "richtext" && (H(o instanceof wg, "Pointer must be wrapped"), o.resolve()) } let n = await Promise.all(Array.from(t).map(async r => { let i = e.tuples.map(s => { let a = s.getPointer(r); return H(a, "Pointer required to resolve field"), a }), o = await r.data.resolveItems(i); return H(o.length === i.length, "Invalid number of items"), [r, o] })); return e.map(e.fields, (r, i) => { let o = new fs; o.merge(r); for (let [s, a] of n) { let l = a[i]; H(l, "Item not found"); let c = r.getPointer(s); H(l.pointer === c, "Pointer mismatch"); for (let u of s.fields) { let f = u.getValue(l); o.addValue(u, f) } } return o }) } }, mm = { type: 0 }, GC = class extends WC { constructor(e, t) { super(), this.input = e, this.ordering = t, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("EnforcerSort", this.inputGroup.id, this.ordering) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); for (let { field: r } of this.ordering.fields) r.name !== ls && t.add(r); let n = new hr; return new Wn(n, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new GC(n, this.ordering) } async execute() { return (await this.input.execute()).sort((t, n) => { for (let { field: r, direction: i } of this.ordering.fields) { let o = i === "asc"; if (r.name === ls) { let l = r.collection; H(l, "Collection required for sorting"); let c = t.getPointer(l); H(c, "Pointer required for sorting"); let u = { pointer: c, data: {} }, f = n.getPointer(l); H(f, "Pointer required for sorting"); let d = { pointer: f, data: {} }, m = l.data.compareItems(u, d); return o ? m : -m } let s = t.getValue(r), a = n.getValue(r); if (!Te.equal(s, a, mm)) { if (oe(s) || Te.lessThan(s, a, mm)) return o ? -1 : 1; if (oe(a) || Te.greaterThan(s, a, mm)) return o ? 1 : -1; throw new Error("Invalid comparison") } } return 0 }) } }, qC = class extends Un { constructor(e, t, n) { super(), this.input = e, this.limit = t, this.ordering = n, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("RelationalLimit", this.inputGroup.id, this.limit) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); return t.merge(this.limit.referencedFields), new Wn(this.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new qC(n, this.limit, this.ordering) } async execute() { let e = await this.input.execute(), t = this.limit.evaluate(), n = rl(t) ?? 1 / 0; return n === 1 / 0 ? e : e.slice(0, n) } }, XC = class extends Un { constructor(e, t, n) { super(), this.input = e, this.offset = t, this.ordering = n, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("RelationalOffset", this.inputGroup.id, this.offset) } getOutputFields() { return this.inputGroup.relational.outputFields } canProvideOrdering(e) { return e.equals(this.ordering) } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); return t.merge(this.offset.referencedFields), new Wn(this.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new XC(n, this.offset, this.ordering) } async execute() { let e = await this.input.execute(), t = this.offset.evaluate(), n = rl(t) ?? 0; return n === 0 ? e : e.slice(n) } }, YC = class extends Un { constructor(e, t, n) { super(), this.input = e, this.projections = t, this.passthrough = n, T(this, "inputGroup", this.input.getGroup()) } getHash() { return he("RelationalProject", this.inputGroup.id, ...this.projections, this.passthrough) } getOutputFields() { let e = new de; e.merge(this.passthrough); for (let t of this.projections) e.add(t.field); return e } canProvideOrdering() { return !0 } canProvideResolvedFields() { return !0 } getInputRequiredProps(e) { let t = new de(e.resolvedFields); for (let n of this.projections) t.merge(n.input.referencedFields); return new Wn(e.ordering, t) } optimize(e, t) { let n = this.getInputRequiredProps(t), r = e.optimizeGroup(this.inputGroup, n); return new kt(0).add(r) } getOptimized(e) { let t = this.getInputRequiredProps(e), n = this.inputGroup.getOptimized(t); return new YC(n, this.projections, this.passthrough) } async execute() { let e = this.getOutputFields(); return (await this.input.execute()).map(e, n => { let r = new fs; r.mergePointers(n); for (let i of this.passthrough) { let o = n.getValue(i); r.addValue(i, o) } for (let i of this.projections) { let o = i.input.evaluate(n); r.addValue(i.field, o) } return r }) } }, hB = class extends dt { constructor(e, t) { super(e.referencedFields), this.input = e, this.definition = t, H(t.isNullable, "Unsupported non-nullable cast") } getHash() { return he("ScalarCast", this.input, this.definition) } toString() { return `CAST(${this.input} AS ${this.definition.type.toUpperCase()})` } evaluate(e) { let t = this.input.evaluate(e); return Te.cast(t, this.definition) } }, pB = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarIn", this.left, this.right) } toString() { return `${this.left} IN ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: Te.in(t, n) } } }, jS = class extends dt { constructor(e) { super(e.referencedFields), this.input = e, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarNot", this.input) } toString() { return `NOT ${this.input}` } evaluate(e) { let t = this.input.evaluate(e); return { type: "boolean", value: !wt(t) } } }, mB = class extends dt { constructor(e, t) { let n = new de; n.merge(e.referencedFields), n.merge(t.referencedFields), super(n), this.left = e, this.right = t, T(this, "definition", { type: "boolean", isNullable: !1 }) } getHash() { return he("ScalarNotIn", this.left, this.right) } toString() { return `${this.left} NOT IN ${this.right}` } evaluate(e) { let t = this.left.evaluate(e), n = this.right.evaluate(e); return { type: "boolean", value: !Te.in(t, n) } } }, cn = class extends dt { constructor(e) { H(e.name !== ls, "Invalid field name"); let t = new de; t.add(e), super(t), this.field = e, T(this, "definition", this.field.definition) } getHash() { return he("ScalarVariable", this.field.id) } toString() { return `"${this.field.name}" /* ${this.field.id} */` } evaluate(e) { return H(e, "Tuple must be provided"), e.getValue(this.field) } }, gB = class { constructor(e) { this.memo = e } finishRelational(e) { return this.memo.addRelational(e) } newRelationalScan(e) { let t = new ju(e); return this.finishRelational(t) } newRelationalIndexLookup(e, t) { let n = new Cn(e, t); return this.finishRelational(n) } newRelationalLeftJoin(e, t, n) { let r = new Hu(e, t, n); return this.finishRelational(r) } newRelationalRightJoin(e, t, n) { return this.newRelationalLeftJoin(t, e, n) } newRelationalFilter(e, t) { if (e instanceof Hu && t.referencedFields.subsetOf(e.leftGroup.relational.outputFields)) { let r = this.newRelationalFilter(e.left, t); return this.newRelationalLeftJoin(r, e.right, e.constraint) } if (e instanceof Sg && t.referencedFields.subsetOf(e.rightGroup.relational.outputFields)) { let r = this.newRelationalFilter(e.right, t); return this.newRelationalLeftJoin(e.left, r, e.constraint) } let n = new Nu(e, t); return this.finishRelational(n) } newRelationalProject(e, t, n) { let r = new YC(e, t, n); return this.finishRelational(r) } newRelationalLimit(e, t, n) { let r = new qC(e, t, n); return this.finishRelational(r) } newRelationalOffset(e, t, n) { let r = new XC(e, t, n); return this.finishRelational(r) } finishScalar(e) { let t = e instanceof zn; if (e.referencedFields.size === 0 && !t) { let n = e.evaluate(); return this.newScalarConstant(e.definition, n) } return this.memo.addScalar(e) } removeUnknown(e, t) { if (e.definition.type !== "unknown" || t.type === "unknown") return e; let n = { ...t, isNullable: !0 }; return this.newScalarCast(e, n) } newScalarVariable(e) { let t = new cn(e); return this.finishScalar(t) } newScalarConstant(e, t) { let n = new zn(e, t); return this.finishScalar(n) } newScalarNot(e) { if (e instanceof jS) { if (e.input.definition.type === "boolean") return e.input; let n = { type: "boolean", isNullable: !0 }; return this.newScalarCast(e.input, n) } if (e instanceof Dm) return this.newScalarNotEquals(e.left, e.right); if (e instanceof $m) return this.newScalarEquals(e.left, e.right); if (e instanceof Bm) return this.newScalarGreaterThanOrEqual(e.left, e.right); if (e instanceof zm) return this.newScalarGreaterThan(e.left, e.right); if (e instanceof Am) return this.newScalarLessThanOrEqual(e.left, e.right); if (e instanceof Vm) return this.newScalarLessThan(e.left, e.right); if (e instanceof Om) { let n = this.newScalarNot(e.left), r = this.newScalarNot(e.right); return this.newScalarOr(n, r) } if (e instanceof Nm) { let n = this.newScalarNot(e.left), r = this.newScalarNot(e.right); return this.newScalarAnd(n, r) } let t = new jS(e); return this.finishScalar(t) } newScalarAnd(e, t) { let n = new Om(e, t); return this.finishScalar(n) } newScalarOr(e, t) { let n = new Nm(e, t); return this.finishScalar(n) } newScalarEquals(e, t) { let n = e instanceof cn; if (t instanceof cn && !n) return this.newScalarEquals(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new Dm(e, t); return this.finishScalar(i) } newScalarNotEquals(e, t) { let n = e instanceof cn; if (t instanceof cn && !n) return this.newScalarNotEquals(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new $m(e, t); return this.finishScalar(i) } newScalarLessThan(e, t) { let n = e instanceof cn; if (t instanceof cn && !n) return this.newScalarGreaterThan(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new Bm(e, t); return this.finishScalar(i) } newScalarLessThanOrEqual(e, t) { let n = e instanceof cn; if (t instanceof cn && !n) return this.newScalarGreaterThanOrEqual(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new zm(e, t); return this.finishScalar(i) } newScalarGreaterThan(e, t) { let n = e instanceof cn; if (t instanceof cn && !n) return this.newScalarLessThan(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new Am(e, t); return this.finishScalar(i) } newScalarGreaterThanOrEqual(e, t) { let n = e instanceof cn; if (t instanceof cn && !n) return this.newScalarLessThanOrEqual(t, e); e = this.removeUnknown(e, t.definition), t = this.removeUnknown(t, e.definition); let i = new Vm(e, t); return this.finishScalar(i) } newScalarIn(e, t) { let n = new pB(e, t); return this.finishScalar(n) } newScalarNotIn(e, t) { let n = new mB(e, t); return this.finishScalar(n) } newScalarCase(e, t, n) { if (e) { let i = []; for (let { when: o, then: s } of t) { let a = this.removeUnknown(o, e.definition), l = new VC(a, s); i.push(l) } t = i } let r = new nB(e, t, n); return this.finishScalar(r) } newScalarContains(e, t) { let n = new NC(e, t); return this.finishScalar(n) } newScalarStartsWith(e, t) { let n = new jC(e, t); return this.finishScalar(n) } newScalarEndsWith(e, t) { let n = new HC(e, t); return this.finishScalar(n) } newScalarCast(e, t) { if (e.definition.type === t.type) return e; let n = new hB(e, t); return this.finishScalar(n) } }, vB = class { constructor(e, t) { this.query = e, this.locale = t, T(this, "memo", new dB), T(this, "normalizer", new gB(this.memo)), T(this, "explorer", new lB(this.normalizer)) } optimize() { let t = new rB(this.normalizer, this.query, this.locale).build(), r = t.takeNode().getGroup(), i = t.getRequiredProps(); this.optimizeGroup(r, i); let o = r.getOptimized(i), s = t.getNamedFields(); return [o, s] } optimizeGroup(e, t) { let n = e.getWinner(t); if (n.node) return n.cost; let r = e.nodes[0]; H(r, "Normalized node not found"), this.createEnforcer(n, r, t); for (let i of e.nodes) { if (t.canProvide(i)) { let o = i.optimize(this, t); n.update(i, o) } t.isMinimal && this.explorer.explore(i) } return n.cost } createEnforcer(e, t, n) { if (n.resolvedFields.size > 0) { let r = new UC(t, n.resolvedFields), i = r.optimize(this, n); e.update(r, i) } if (n.ordering.length > 0) { let r = new GC(t, n.ordering), i = r.optimize(this, n); e.update(r, i) } } }; function yB(e) { return e.collection ? `"${e.collection}"."${e.name}"` : `"${e.name}"` } function bB(e) { return typeof e.value == "string" ? `'${e.value}'` : e.value } function xB(e) { return `${e.functionName}(${e.arguments.map(t => zt(t)).join(", ")})` } function wB(e) { let t = "CASE"; e.value && (t += ` ${zt(e.value)}`); for (let n of e.conditions) t += ` WHEN ${zt(n.when)} THEN ${zt(n.then)}`; return e.else && (t += ` ELSE ${zt(e.else)}`), t += " END", t } function SB(e) { let t = zt(e.value); return `${e.operator.toUpperCase()} ${t}` } function kB(e) { let t = zt(e.left), n = zt(e.right), r = e.operator.toUpperCase(); return `${t} ${r} ${n}` } function CB(e) { return `CAST(${zt(e.value)} as ${e.dataType})` } function zt(e) { switch (e.type) { case "Identifier": return yB(e); case "LiteralValue": return bB(e); case "FunctionCall": return xB(e); case "Case": return wB(e); case "UnaryOperation": return SB(e); case "BinaryOperation": return kB(e); case "TypeCast": return CB(e); default: xe(e) } } function TB(e) { return gg(e.data) ? "Collection" : e.alias ? `"${e.data.displayName}" AS "${e.alias}"` : `"${e.data.displayName}"` } function EB(e) { let t = `${Hm(e.left)} LEFT JOIN ${Hm(e.right)}`; return e.constraint && (t += ` ON ${zt(e.constraint)}`), t } function Hm(e) { switch (e.type) { case "Collection": return TB(e); case "LeftJoin": return EB(e); default: xe(e) } } function RB(e) {
    let t = ""; return e.split(/\s+/u).forEach(r => {
        r !== "" && (["SELECT", "FROM", "WHERE", "ORDER", "LIMIT", "OFFSET"].includes(r) ? t += `
${r}` : ["AND", "OR"].includes(r) ? t += `
	${r}` : t += ` ${r}`)
    }), t.trim()
} function PB(e) { let t = ""; return t += `SELECT ${e.select.map(n => { let r = zt(n); return n.alias ? `${r} AS "${n.alias}"` : r }).join(", ")}`, t += ` FROM ${Hm(e.from)}`, e.where && (t += ` WHERE ${zt(e.where)}`), e.orderBy && (t += ` ORDER BY ${e.orderBy.map(n => `${zt(n)} ${n.direction ?? "asc"}`).join(", ")}`), e.limit && (t += ` LIMIT ${zt(e.limit)}`), e.offset && (t += ` OFFSET ${zt(e.offset)}`), RB(t) } var _B = r4("query-engine"); function FB({ data: e }, t) { if (_C(e)) return new IC(e, t); if (gg(e)) return e; if (FC(e)) { for (; t;) { let n = e.collectionByLocaleId[t.id]; if (n) return n; t = t.fallback } return e.collectionByLocaleId.default } xe(e, "Unsupported collection type") } var Y8 = class {
    constructor() { T(this, "useNewOptimizer", !1) } async query(e, t) { return this.useNewOptimizer || e.from.type !== "Collection" ? this.queryNew(e, t) : this.queryOld(e, t) } async queryNew(e, t) { let n = new vB(e, t), [r, i] = n.optimize(), o = await r.execute(); return await Promise.all(o.tuples.map(async a => { let l = {}; for (let [c, u] of i) { let f = a.getValue(u); l[c] = await this.resolveValue(f) } return l })) } async resolveValue(e) { return e?.type === "richtext" ? (H(e.value instanceof wg, "Pointer must be wrapped"), e.value.resolve()) : e?.value ?? null } async queryOld(e, t) {
        let [n, r, i] = this.createQueryPlan(e, t), o = await this.executeQueryPlan(r, i, e, n); return _B.debug(`Query:
${PB(e)}

${(0, n4.default)(n.inspect())}`), o
    } buildFrom(e, t, n, r) { switch (e.type) { case "Collection": { let i = FB(e, r); return n.push(i), Object.assign(t, i.schema), new MC(i, e.alias) } case "LeftJoin": { let i = this.buildFrom(e.left, t, n, r), o = this.buildFrom(e.right, t, n, r), s = It.from(e.constraint, t); return new j4(i, o, s) } default: xe(e, "Unsupported data source") } } createQueryPlan(e, t) { var n; let r = {}, i = [], o = this.buildFrom(e.from, r, i, t), [s] = i; H(s, "At least one collection must exist"); let a = new K4(i); if (e.where) { let f = It.from(e.where, r); i.length === 1 ? o = jm(s, f) : o = new OC(o, f) } let l = (n = e.orderBy) == null ? void 0 : n.map(f => new X4(It.from(f, r), f.direction ?? "asc", { type: 0 })); o = new q4(o, l ?? [], s); let c; e.offset && (c = It.from(e.offset, r)); let u; return e.limit && (u = It.from(e.limit, r)), (c || u) && (o = new Y4(o, c, u)), e.select.length > 0 && i.length === 1 && (o = new G4(o, s, a, e.select)), [o, r, a] } async executeQueryPlan(e, t, n, r) { let i = await r.execute(); return Promise.all(i.map(async o => { let s = {}; for (let a of n.select) { let l = It.from(a, e), c = IB(a), u = l.evaluate(o); s[c] = await LB(t, a.type === "Identifier" ? a.name : void 0, u) } return s })) }
}; function IB(e) { if (e.alias) return e.alias; if (e.type === "Identifier") return e.name; throw new Error("Can't serialize expression") } async function LB(e, t, n) { return os(n) ? null : n.type === "richtext" ? (H(fe(t), "Rich text field must be a string"), e.resolve(t, n.value)) : n.value } function jm(e, t) { if (t instanceof Ji) { let n = t.operandExpressions.map(r => jm(e, r)); return new U4(n) } if (t instanceof Da) { let n = t.operandExpressions.map(r => jm(e, r)); return new W4(n) } return MB(e, t) ?? DB(e, t) } function MB(e, t) { var n, r; if (t instanceof Hn) return gm(e, t); if (t instanceof il) return OB(e, t); if (t instanceof St && ((n = t.definition) == null ? void 0 : n.type) === "boolean") { let i = Pe.fromBoolean(!0), o = new ss(t, i); return gm(e, o) } if (t instanceof ja && t.valueExpression instanceof St && ((r = t.valueExpression.definition) == null ? void 0 : r.type) === "boolean") { let i = Pe.fromBoolean(!0), o = new as(t.valueExpression, i); return gm(e, o) } } function gm(e, t) { let n = t.leftExpression, r = t.rightExpression; if (r instanceof Pe) for (let i of e.indexes) { let o = i.fields[0]; if (it(o)) continue; let s = It.from(o, e.schema); if (!n.equals(s)) continue; let a = new Array(i.fields.length - 1).fill({ type: "All" }); if (t instanceof ss && i.supportedLookupTypes.includes("Equals")) return new Vr(i, [{ type: "Equals", value: r.evaluate() }, ...a]); if (t instanceof as && i.supportedLookupTypes.includes("NotEquals")) return new Vr(i, [{ type: "NotEquals", value: r.evaluate() }, ...a]); if (t instanceof Ua && i.supportedLookupTypes.includes("LessThan")) return new Vr(i, [{ type: "LessThan", value: r.evaluate(), inclusive: !1 }, ...a]); if (t instanceof Ga && i.supportedLookupTypes.includes("LessThan")) return new Vr(i, [{ type: "LessThan", value: r.evaluate(), inclusive: !0 }, ...a]); if (t instanceof qa && i.supportedLookupTypes.includes("GreaterThan")) return new Vr(i, [{ type: "GreaterThan", value: r.evaluate(), inclusive: !1 }, ...a]); if (t instanceof Xa && i.supportedLookupTypes.includes("GreaterThan")) return new Vr(i, [{ type: "GreaterThan", value: r.evaluate(), inclusive: !0 }, ...a]) } } function OB(e, t) { if (t.argumentExpressions.length !== 2) return; let n = t.argumentExpressions[0], r = t.argumentExpressions[1]; if (!it(n) && !it(r) && r instanceof Pe) for (let i of e.indexes) { let o = i.fields[0]; if (it(o)) continue; let s = It.from(o, e.schema); if (!n.equals(s)) continue; let a = new Array(i.fields.length - 1).fill({ type: "All" }); if (t instanceof Qu && i.supportedLookupTypes.includes("Contains")) return new Vr(i, [{ type: "Contains", value: r.evaluate() }, ...a]); if (t instanceof Zu && i.supportedLookupTypes.includes("StartsWith")) return new Vr(i, [{ type: "StartsWith", value: r.evaluate() }, ...a]); if (t instanceof Ju && i.supportedLookupTypes.includes("EndsWith")) return new Vr(i, [{ type: "EndsWith", value: r.evaluate() }, ...a]) } } function DB(e, t) { let n = new MC(e, void 0); return new OC(n, t) } var Eu = "default", AB = new Set([Eu]), Ru, VB = class { constructor() { T(this, "entries", new Map), en(this, Ru, {}) } set(e, t, n, r) { switch (t) { case "transformTemplate": { H(typeof n == "string", `transformTemplate must be a string, received: ${n}`), this.setHash(e, r, { transformTemplate: n, legacy: !0 }); break } case "initial": case "animate": { H(typeof n == "object", `${t} must be a valid object, received: ${n}`), this.setHash(e, r, { [t]: n, legacy: !0 }); break } default: break } } setHash(e, t = Eu, n) { let r = this.entries.get(e) ?? {}, i = r[t] ?? {}; r[t] = n === null ? null : { ...i, ...n }, this.entries.set(e, r) } variantHash(e, t) { if (e === t?.primaryVariantId) return Eu; let n = ue(this, Ru)[e]; if (n) return n; let r = t?.variantClassNames[e]; return r ? ue(this, Ru)[e] = RC(r) : Eu } setAll(e, t = AB, n, r) { var i; if (n === null) { for (let c of t) this.setHash(e, this.variantHash(c, r), null); return } let o = ki(n.transformTemplate) ? (i = n.transformTemplate) == null ? void 0 : i.call(n, {}, zB) : void 0, s = n.__framer__presenceInitial ?? n.initial, a = n.__framer__presenceAnimate ?? n.animate, l = { initial: Me(s) ? s : void 0, animate: Me(a) ? a : void 0, transformTemplate: fe(o) ? o : void 0 }; for (let c of t) this.setHash(e, this.variantHash(c, r), l) } clear() { this.entries.clear() } toObject() { return Object.fromEntries(this.entries) } }; Ru = new WeakMap; var BB = new VB; function Z8(e) { return x.forwardRef(({ optimized: t, ...n }, r) => { let i = x.useContext(gC), o = x.useContext(mg), s = n[$B]; return s && !zr() && BB.setAll(s, o, t ? n : null, i), k(e, { ref: r, ...n }) }) } var zB = "__Appear_Animation_Transform__"; var $B = "data-framer-appear-id", J8 = "data-framer-appear-animation"; function NB(e, t, n) { return x.useCallback(r => { var i, o, s; return n ? e ? t ? Object.assign({}, (i = n[e]) == null ? void 0 : i[r], (o = n[t]) == null ? void 0 : o[r]) : ((s = n[e]) == null ? void 0 : s[r]) || {} : {} : {} }, [e, t, n]) } function HB(e) { for (let [t, n] of Object.entries(e)) if (ft.matchMedia(n).matches) return t } function jB(e) { var t; for (let { hash: n, mediaQuery: r } of e) { if (!r) continue; if (ft.matchMedia(r).matches) return n } return (t = e[0]) == null ? void 0 : t.hash } function rW(e, t, n = !0) { let r = V(oC), i = A(zr() ? HB(t) ?? e : e), o = A(n && r ? e : i.current), s = Xu(), a = ub(), l = se(c => { (c !== i.current || c !== o.current) && a(() => { i.current = o.current = c, vr(() => { s() }) }) }, [a, s]); return jk(() => { !n || r !== !0 || l(i.current) }, []), N(() => { let c = []; for (let [u, f] of Object.entries(t)) { let d = ft.matchMedia(f), m = y => { y.matches && l(u) }; WB(d, m), c.push([d, m]) } return () => c.forEach(([u, f]) => UB(u, f)) }, [t, l]), [i.current, o.current] } function WB(e, t) { e.addEventListener ? e.addEventListener("change", t) : e.addListener(t) } function UB(e, t) { e.removeEventListener ? e.removeEventListener("change", t) : e.removeListener(t) } function iW(e) { var t, n; let r = jB(e); if (r) for (let i of document.querySelectorAll(".hidden-" + r)) (t = i.parentNode) == null || t.removeChild(i); for (let i of document.querySelectorAll(".ssr-variant:empty")) (n = i.parentNode) == null || n.removeChild(i) } function tf() { return le.current() === le.canvas } function WS(e, t) { return `${e}-${t}` } function GB(e, t) { let r = e.indexOf(t) + 1; r >= e.length && (r = 0); let i = e[r]; return H(i !== void 0, "nextVariant should be defined"), i } function qB(e, t) { if (e) { if (t) { let n = e[t]; if (n) return n } return e.default } } function US(e, t, n, r, i) { let { hover: o, pressed: s, loading: a, error: l } = e || {}; if (l && i) return "error"; if (a && r) return "loading"; if (s && n) return "pressed"; if (o && t) return "hover" } function XB(e, t) { let n = t[e]; return n || `framer-v-${e}` } function GS(e, t, n) { return e && n.has(e) ? e : t } var YB = Symbol("cycle"); function mW({ variant: e, defaultVariant: t, transitions: n, enabledGestures: r, cycleOrder: i = [], variantProps: o = {}, variantClassNames: s = {} }) { let a = Xu(), l = tf(), c = Rn(() => new Set(i)), u = x.useRef({ isHovered: !1, isPressed: !1, isError: !1, hasPressedVariants: !0, baseVariant: GS(e, t, c), lastVariant: e, gestureVariant: void 0, loadedBaseVariant: {}, defaultVariant: t, enabledGestures: r, cycleOrder: i, transitions: n }), f = x.useCallback(E => { let { isHovered: L, isPressed: F, isError: z, enabledGestures: D, defaultVariant: K } = u.current, U = GS(E, K, c), $ = US(D?.[U], L, F, !1, z), W = $ ? WS(U, $) : void 0; return [U, W] }, [c]), d = x.useCallback(({ isHovered: E, isPressed: L, isError: F }) => { E !== void 0 && (u.current.isHovered = E), L !== void 0 && (u.current.isPressed = L), F !== void 0 && (u.current.isError = F); let { baseVariant: z, gestureVariant: D, defaultVariant: K } = u.current, [U, $] = f(z); (U !== z || $ !== D) && (u.current.baseVariant = U || K, u.current.gestureVariant = $, a()) }, [f, a]), m = x.useCallback(E => { let { defaultVariant: L, cycleOrder: F, baseVariant: z, gestureVariant: D } = u.current, K = E === YB ? GB(F || [], z || L) : E, [U, $] = f(K); (U !== z || $ !== D) && (u.current.isError = !1, u.current.baseVariant = U || L, u.current.gestureVariant = $, a()) }, [f, a]), y = x.useCallback(() => { let { baseVariant: E } = u.current; u.current.loadedBaseVariant[E] = !0, a() }, [a]); if (e !== u.current.lastVariant) { let [E, L] = f(e); u.current.lastVariant = E, (E !== u.current.baseVariant || L !== u.current.gestureVariant) && (u.current.baseVariant = E, u.current.gestureVariant = L) } let { baseVariant: g, gestureVariant: b, defaultVariant: h, enabledGestures: p, isHovered: v, isPressed: w, isError: C, loadedBaseVariant: S } = u.current, R = NB(u.current.baseVariant, u.current.gestureVariant, o); return x.useMemo(() => { var E; let L = []; g !== h && L.push(g); let F = (E = p?.[g]) == null ? void 0 : E.loading, z = !C && !l && !!F && !S[g], D = z ? WS(g, "loading") : b; D && L.push(D); let K = p?.[g], U = { onMouseEnter: () => d({ isHovered: !0 }), onMouseLeave: () => d({ isHovered: !1 }) }; return K?.pressed && Object.assign(U, { onTapStart: () => d({ isPressed: !0 }), onTapCancel: () => d({ isPressed: !1 }), onTap: () => d({ isPressed: !1 }) }), { variants: L, baseVariant: g, gestureVariant: D, isLoading: z, transition: qB(u.current.transitions, g), setVariant: m, setGestureState: d, clearLoadingGesture: y, addVariantProps: R, gestureHandlers: U, classNames: Du(XB(g, s), US(K, v, w, z, C)) } }, [g, b, v, w, S, R, m, h, p, d, y, s]) } var KB = x.createContext(void 0), QB = () => x.useContext(KB); var ZB = { Arial: { Regular: { selector: "Arial", weight: void 0 }, Black: { selector: "Arial-Black", weight: void 0 }, Narrow: { selector: "Arial Narrow", weight: void 0 }, "Rounded Bold": { selector: "Arial Rounded MT Bold", weight: void 0 } }, Avenir: { Book: { selector: "Avenir", weight: void 0 }, Light: { selector: "Avenir-Light", weight: void 0 }, Medium: { selector: "Avenir-Medium", weight: void 0 }, Heavy: { selector: "Avenir-Heavy", weight: void 0 }, Black: { selector: "Avenir-Black", weight: void 0 } }, "Avenir Next": { Regular: { selector: "Avenir Next", weight: void 0 }, "Ultra Light": { selector: "AvenirNext-UltraLight", weight: void 0 }, Medium: { selector: "AvenirNext-Medium", weight: void 0 }, "Demi Bold": { selector: "AvenirNext-DemiBold", weight: void 0 }, Heavy: { selector: "AvenirNext-Heavy", weight: void 0 } }, "Avenir Next Condensed": { Regular: { selector: "Avenir Next Condensed", weight: void 0 }, "Ultra Light": { selector: "AvenirNextCondensed-UltraLight", weight: void 0 }, Medium: { selector: "AvenirNextCondensed-Medium", weight: void 0 }, "Demi Bold": { selector: "AvenirNextCondensed-DemiBold", weight: void 0 }, Heavy: { selector: "AvenirNextCondensed-Heavy", weight: void 0 } }, Baskerville: { Regular: { selector: "Baskerville", weight: void 0 }, "Semi Bold": { selector: "Baskerville-SemiBold", weight: void 0 } }, "Bodoni 72": { Book: { selector: "Bodoni 72", weight: void 0 }, Oldstyle: { selector: "Bodoni 72 Oldstyle", weight: void 0 }, Smallcaps: { selector: "Bodoni 72 Smallcaps", weight: void 0 } }, Courier: { Regular: { selector: "Courier", weight: void 0 } }, "Courier New": { Regular: { selector: "Courier New", weight: void 0 } }, Futura: { Medium: { selector: "Futura", weight: void 0 }, Condensed: { selector: "Futura-CondensedMedium", weight: void 0 }, "Condensed ExtraBold": { selector: "Futura-CondensedExtraBold", weight: void 0 } }, Georgia: { Regular: { selector: "Georgia", weight: void 0 } }, "Gill Sans": { Regular: { selector: "Gill Sans", weight: void 0 }, Light: { selector: "GillSans-Light", weight: void 0 }, SemiBold: { selector: "GillSans-SemiBold", weight: void 0 }, UltraBold: { selector: "GillSans-UltraBold", weight: void 0 } }, Helvetica: { Regular: { selector: "Helvetica", weight: void 0 }, Light: { selector: "Helvetica-Light", weight: void 0 }, Bold: { selector: "Helvetica-Bold", weight: void 0 }, Oblique: { selector: "Helvetica-Oblique", weight: void 0 }, "Light Oblique": { selector: "Helvetica-LightOblique", weight: void 0 }, "Bold Oblique": { selector: "Helvetica-BoldOblique", weight: void 0 } }, "Helvetica Neue": { Regular: { selector: "Helvetica Neue", weight: void 0 }, UltraLight: { selector: "HelveticaNeue-UltraLight", weight: void 0 }, Thin: { selector: "HelveticaNeue-Thin", weight: void 0 }, Light: { selector: "HelveticaNeue-Light", weight: void 0 }, Medium: { selector: "HelveticaNeue-Medium", weight: void 0 }, Bold: { selector: "HelveticaNeue-Bold", weight: void 0 }, Italic: { selector: "HelveticaNeue-Italic", weight: void 0 }, "UltraLight Italic": { selector: "HelveticaNeue-UltraLightItalic", weight: void 0 }, "Thin Italic": { selector: "HelveticaNeue-ThinItalic", weight: void 0 }, "Light Italic": { selector: "HelveticaNeue-LightItalic", weight: void 0 }, "Medium Italic": { selector: "HelveticaNeue-MediumItalic", weight: void 0 }, "Bold Italic": { selector: "HelveticaNeue-BoldItalic", weight: void 0 }, "Condensed Bold": { selector: "HelveticaNeue-CondensedBold", weight: void 0 }, "Condensed Black": { selector: "HelveticaNeue-CondensedBlack", weight: void 0 } }, "Hoefler Text": { Regular: { selector: "Hoefler Text", weight: void 0 } }, Impact: { Regular: { selector: "Impact", weight: void 0 } }, "Lucida Grande": { Regular: { selector: "Lucida Grande", weight: void 0 } }, Menlo: { Regular: { selector: "Menlo", weight: void 0 } }, Monaco: { Regular: { selector: "Monaco", weight: void 0 } }, Optima: { Regular: { selector: "Optima", weight: void 0 }, ExtraBlack: { selector: "Optima-ExtraBlack", weight: void 0 } }, Palatino: { Regular: { selector: "Palatino", weight: void 0 } }, "SF Pro Display": { Regular: { selector: "__SF-UI-Display-Regular__", weight: 400 }, Ultralight: { selector: "__SF-UI-Display-Ultralight__", weight: 100 }, Thin: { selector: "__SF-UI-Display-Thin__", weight: 200 }, Light: { selector: "__SF-UI-Display-Light__", weight: 300 }, Medium: { selector: "__SF-UI-Display-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Display-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Display-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Display-Heavy__", weight: 800 }, Black: { selector: "__SF-UI-Display-Black__", weight: 900 }, Italic: { selector: "__SF-UI-Display-Italic__", weight: 400 }, "Ultralight Italic": { selector: "__SF-UI-Display-Ultralight-Italic__", weight: 100 }, "Thin Italic": { selector: "__SF-UI-Display-Thin-Italic__", weight: 200 }, "Light Italic": { selector: "__SF-UI-Display-Light-Italic__", weight: 300 }, "Medium Italic": { selector: "__SF-UI-Display-Medium-Italic__", weight: 500 }, "Semibold Italic": { selector: "__SF-UI-Display-Semibold-Italic__", weight: 600 }, "Bold Italic": { selector: "__SF-UI-Display-Bold-Italic__", weight: 700 }, "Heavy Italic": { selector: "__SF-UI-Display-Heavy-Italic__", weight: 800 }, "Black Italic": { selector: "__SF-UI-Display-Black-Italic__", weight: 900 } }, "SF Pro Display Condensed": { Regular: { selector: "__SF-UI-Display-Condensed-Regular__", weight: 400 }, Ultralight: { selector: "__SF-UI-Display-Condensed-Ultralight__", weight: 100 }, Thin: { selector: "__SF-UI-Display-Condensed-Thin__", weight: 200 }, Light: { selector: "__SF-UI-Display-Condensed-Light__", weight: 300 }, Medium: { selector: "__SF-UI-Display-Condensed-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Display-Condensed-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Display-Condensed-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Display-Condensed-Heavy__", weight: 800 }, Black: { selector: "__SF-UI-Display-Condensed-Black__", weight: 900 } }, "SF Pro Text": { Regular: { selector: "__SF-UI-Text-Regular__", weight: 400 }, Light: { selector: "__SF-UI-Text-Light__", weight: 200 }, Medium: { selector: "__SF-UI-Text-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Text-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Text-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Text-Heavy__", weight: 800 }, Italic: { selector: "__SF-UI-Text-Italic__", weight: 400 }, "Light Italic": { selector: "__SF-UI-Text-Light-Italic__", weight: 200 }, "Medium Italic": { selector: "__SF-UI-Text-Medium-Italic__", weight: 500 }, "Semibold Italic": { selector: "__SF-UI-Text-Semibold-Italic__", weight: 600 }, "Bold Italic": { selector: "__SF-UI-Text-Bold-Italic__", weight: 700 }, "Heavy Italic": { selector: "__SF-UI-Text-Heavy-Italic__", weight: 800 } }, "SF Pro Text Condensed": { Regular: { selector: "__SF-UI-Text-Condensed-Regular__", weight: 400 }, Light: { selector: "__SF-UI-Text-Condensed-Light__", weight: 200 }, Medium: { selector: "__SF-UI-Text-Condensed-Medium__", weight: 500 }, Semibold: { selector: "__SF-UI-Text-Condensed-Semibold__", weight: 600 }, Bold: { selector: "__SF-UI-Text-Condensed-Bold__", weight: 700 }, Heavy: { selector: "__SF-UI-Text-Condensed-Heavy__", weight: 800 } }, Tahoma: { Regular: { selector: "Tahoma", weight: void 0 } }, Times: { Regular: { selector: "Times", weight: void 0 } }, "Times New Roman": { Regular: { selector: "Times New Roman", weight: void 0 } }, Trebuchet: { Regular: { selector: "Trebuchet MS", weight: void 0 } }, Verdana: { Regular: { selector: "Verdana", weight: void 0 } } }, JB = { "__SF-Compact-Display-Regular__": "SFCompactDisplay-Regular|.SFCompactDisplay-Regular", "__SF-Compact-Display-Ultralight__": "SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight", "__SF-Compact-Display-Thin__": "SFCompactDisplay-Thin|.SFCompactDisplay-Thin", "__SF-Compact-Display-Light__": "SFCompactDisplay-Light|.SFCompactDisplay-Light", "__SF-Compact-Display-Medium__": "SFCompactDisplay-Medium|.SFCompactDisplay-Medium", "__SF-Compact-Display-Semibold__": "SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold", "__SF-Compact-Display-Heavy__": "SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy", "__SF-Compact-Display-Black__": "SFCompactDisplay-Black|.SFCompactDisplay-Black", "__SF-Compact-Display-Bold__": "SFCompactDisplay-Bold|.SFCompactDisplay-Bold", "__SF-UI-Text-Regular__": ".SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText", "__SF-UI-Text-Light__": ".SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light", "__SF-UI-Text-Medium__": ".SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium", "__SF-UI-Text-Semibold__": ".SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold", "__SF-UI-Text-Bold__": ".SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold", "__SF-UI-Text-Heavy__": ".SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy", "__SF-UI-Text-Italic__": ".SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic", "__SF-UI-Text-Light-Italic__": ".SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic", "__SF-UI-Text-Medium-Italic__": ".SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic", "__SF-UI-Text-Semibold-Italic__": ".SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic", "__SF-UI-Text-Bold-Italic__": ".SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic", "__SF-UI-Text-Heavy-Italic__": ".SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic", "__SF-Compact-Text-Regular__": "SFCompactText-Regular|.SFCompactText-Regular", "__SF-Compact-Text-Light__": "SFCompactText-Light|.SFCompactText-Light", "__SF-Compact-Text-Medium__": "SFCompactText-Medium|.SFCompactText-Medium", "__SF-Compact-Text-Semibold__": "SFCompactText-Semibold|.SFCompactText-Semibold", "__SF-Compact-Text-Bold__": "SFCompactText-Bold|.SFCompactText-Bold", "__SF-Compact-Text-Heavy__": "SFCompactText-Heavy|.SFCompactText-Heavy", "__SF-Compact-Text-Italic__": "SFCompactText-Italic|.SFCompactText-Italic", "__SF-Compact-Text-Light-Italic__": "SFCompactText-LightItalic|.SFCompactText-LightItalic", "__SF-Compact-Text-Medium-Italic__": "SFCompactText-MediumItalic|.SFCompactText-MediumItalic", "__SF-Compact-Text-Semibold-Italic__": "SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic", "__SF-Compact-Text-Bold-Italic__": "SFCompactText-BoldItalic|.SFCompactText-BoldItalic", "__SF-Compact-Text-Heavy-Italic__": "SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic", "__SF-UI-Display-Condensed-Regular__": ".SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular", "__SF-UI-Display-Condensed-Ultralight__": ".SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight", "__SF-UI-Display-Condensed-Thin__": ".SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin", "__SF-UI-Display-Condensed-Light__": ".SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light", "__SF-UI-Display-Condensed-Medium__": ".SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium", "__SF-UI-Display-Condensed-Semibold__": ".SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold", "__SF-UI-Display-Condensed-Bold__": ".SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold", "__SF-UI-Display-Condensed-Heavy__": ".SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy", "__SF-UI-Display-Condensed-Black__": ".SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black", "__SF-UI-Display-Regular__": ".SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay", "__SF-UI-Display-Ultralight__": ".SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight", "__SF-UI-Display-Thin__": ".SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin", "__SF-UI-Display-Light__": ".SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light", "__SF-UI-Display-Medium__": ".SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium", "__SF-UI-Display-Semibold__": ".SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold", "__SF-UI-Display-Bold__": ".SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold", "__SF-UI-Display-Heavy__": ".SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy", "__SF-UI-Display-Black__": ".SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black", "__SF-UI-Display-Italic__": ".SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic", "__SF-UI-Display-Ultralight-Italic__": ".SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic", "__SF-UI-Display-Thin-Italic__": ".SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic", "__SF-UI-Display-Light-Italic__": ".SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic", "__SF-UI-Display-Medium-Italic__": ".SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic", "__SF-UI-Display-Semibold-Italic__": ".SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic", "__SF-UI-Display-Bold-Italic__": ".SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic", "__SF-UI-Display-Heavy-Italic__": ".SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic", "__SF-UI-Display-Black-Italic__": ".SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic", "__SF-UI-Text-Condensed-Regular__": ".SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular", "__SF-UI-Text-Condensed-Light__": ".SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light", "__SF-UI-Text-Condensed-Medium__": ".SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium", "__SF-UI-Text-Condensed-Semibold__": ".SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold", "__SF-UI-Text-Condensed-Bold__": ".SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold", "__SF-UI-Text-Condensed-Heavy__": ".SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy", "__SF-Compact-Rounded-Regular__": "SFCompactRounded-Regular|.SFCompactRounded-Regular", "__SF-Compact-Rounded-Ultralight__": "SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight", "__SF-Compact-Rounded-Thin__": "SFCompactRounded-Thin|.SFCompactRounded-Thin", "__SF-Compact-Rounded-Light__": "SFCompactRounded-Light|.SFCompactRounded-Light", "__SF-Compact-Rounded-Medium__": "SFCompactRounded-Medium|.SFCompactRounded-Medium", "__SF-Compact-Rounded-Semibold__": "SFCompactRounded-Semibold|.SFCompactRounded-Semibold", "__SF-Compact-Rounded-Bold__": "SFCompactRounded-Bold|.SFCompactRounded-Bold", "__SF-Compact-Rounded-Heavy__": "SFCompactRounded-Heavy|.SFCompactRounded-Heavy", "__SF-Compact-Rounded-Black__": "SFCompactRounded-Black|.SFCompactRounded-Black" }, qS = ZB; var ez = "System Default", tz = class { constructor() { T(this, "name", "local"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map), T(this, "fontAliasBySelector", new Map), T(this, "fontAliases", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } createFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.addFontFamily(t), t } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } importFonts() { let e = []; for (let r of Object.keys(qS)) { let i = qS[r]; if (!i) continue; let o = this.createFontFamily(r); for (let s of Object.keys(i)) { let a = i[s]; if (!a) continue; let { selector: l, weight: c } = a, u = { variant: s, selector: l, weight: c, family: o }; o.fonts.push(u) } e.push(...o.fonts) } for (let [r, i] of Object.entries(JB)) this.addFontAlias(r, i); let { fontFamily: t, aliases: n } = this.getSystemFontFamily(); this.addFontFamily(t); for (let [r, i] of n) this.addFontAlias(r, i); return e.push(...t.fonts), e } addFontAlias(e, t) { this.fontAliases.set(e, t), this.fontAliasBySelector.set(t, e) } getSystemFontFamily() { let e = "system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif", t = { name: ez, fonts: [], source: this.name }, n = new Map, r = [400, 100, 200, 300, 500, 600, 700, 800, 900], i = ["normal", "italic"]; for (let o of i) for (let s of r) { let a = nz(s, o), l = `__SystemDefault-${s}-${o}__`, c = { variant: a, selector: l, style: o, weight: s, family: t }; t.fonts.push(c), n.set(l, e) } return { fontFamily: t, aliases: n } } getFontAliasBySelector(e) { return this.fontAliasBySelector.get(e) || null } getFontSelectorByAlias(e) { return this.fontAliases.get(e) || null } isFontFamilyAlias(e) { return !!(e && /^__.*__$/u.exec(e)) } }, XS = { 100: "Thin", 200: "Extra Light", 300: "Light", 400: "Normal", 500: "Medium", 600: "Semi Bold", 700: "Bold", 800: "Extra Bold", 900: "Black" }; function nz(e, t) { let n = t === "normal" ? "Regular" : "Italic"; return e === 400 ? n : t !== "normal" ? `${XS[e]} ${n}` : `${XS[e]}` } var rz = Zn(Um(), 1), ts = "CUSTOM;"; function iz(e, t) { if (!t) return e.substring(0, e.lastIndexOf(".")); let n = t.font.preferredFamily === "" ? t.font.fontFamily : t.font.preferredFamily, r = t.font.preferredSubFamily === "" ? t.font.fontSubFamily : t.font.preferredSubFamily; return `${n} ${r}` } var oz = class { constructor() { T(this, "name", "custom"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map), T(this, "assetsByFamily", new Map) } importFonts(e) { var t, n; this.fontFamilies.length = 0, this.byFamilyName.clear(), this.assetsByFamily.clear(); let r = []; for (let i of e) { if (!this.isValidCustomFontAsset(i)) continue; let o = iz(i.name, i.properties), s = this.createFontFamily(o), a = (t = i.properties) == null ? void 0 : t.font.openTypeData, l = { family: s, selector: `${ts}${o}`, variant: this.inferVariantName(o), postscriptName: (n = i.properties) == null ? void 0 : n.font.postscriptName, file: i.url, openTypeFeatures: this.validateOpenTypeData(a) }; s.fonts.push(l), s.owner = i.ownerType === "team" ? "team" : "project", this.assetsByFamily.set(o, i), r.push(...s.fonts) } return r } isValidCustomFontAsset(e) { var t; return !e.mimeType.startsWith("font/") || ((t = e.properties) == null ? void 0 : t.kind) !== "font" || !e.properties.font ? !1 : "fontFamily" in e.properties.font } validateOpenTypeData(e) { if (e && Array.isArray(e)) return e.map(t => { if (this.isOpenTypeFeature(t)) return { tag: t.tag, coverage: t.coverage } }) } isOpenTypeFeature(e) { return !(typeof e != "object" || e === null || !("tag" in e) || typeof e.tag != "string" || "coverage" in e && typeof e.coverage < "u" && !Array.isArray(e.coverage)) } inferVariantName(e) { let t = ["thin", "ultra light", "extra light", "light", "normal", "medium", "semi bold", "bold", "extra bold", "black"], n = [...t.map(s => `${s} italic`), ...t], r = e.toLowerCase(), i = [...r.split(" "), ...r.split("-"), ...r.split("_")], o = n.find(s => i.includes(s) || i.includes(s.replace(/\s+/gu, ""))); return o ? o.replace(/^\w|\s\w/gu, s => s.toUpperCase()) : "Regular" } createFontFamily(e) { let t = this.byFamilyName.get(e); if (t) return t; let n = { source: this.name, name: e, fonts: [] }; return this.addFontFamily(n), n } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } parseSelector(e) { if (!e.startsWith(ts)) return null; let t = e.split(ts); return t[1] === void 0 ? null : { source: "custom", name: t[1] } } getFontBySelector(e, t = !0) { let n = this.parseSelector(e); if (!n || !t && !this.byFamilyName.get(n.name)) return; let r = this.getFontFamilyByName(n.name).fonts; return r.find(o => { var s; return (s = o.file) == null ? void 0 : s.endsWith(".woff2") }) || r[0] } getFontFamilyByName(e) { let t = this.byFamilyName.get(e); if (t) return t; let n = { source: "custom", name: e, fonts: [] }; return n.fonts.push({ selector: `${ts}${e}`, variant: this.inferVariantName(e), family: n }), n } }; function KC(e, t, n) { if (t.length === 0) return {}; let r = n(e); if (!r) return {}; let { weight: i, style: o } = r, s = new Map, a = new Map; t.forEach(f => { let d = fe(f) ? f : f.name.toLocaleLowerCase(), m = n(d); m && (s.set(`${m.weight}-${m.style}`, d), !(m.weight <= i) && (a.has(m.style) || a.set(m.style, d))) }); let l = a.get(o), c = a.get("italic") ?? a.get("oblique"); r.weight <= 300 ? (l = s.get(`400-${o}`) ?? l, c = s.get("400-italic") ?? s.get("400-oblique") ?? c) : r.weight <= 500 ? (l = s.get(`700-${o}`) ?? l, c = s.get("700-italic") ?? s.get("700-oblique") ?? c) : (l = s.get(`900-${o}`) ?? l, c = s.get("900-italic") ?? s.get("900-oblique") ?? c); let u = s.get(`${i}-italic`) ?? s.get(`${i}-oblique`); return { variantBold: l, variantItalic: u, variantBoldItalic: c } } var sz = ["display", "sans", "serif", "slab", "handwritten", "script"]; function az(e) { return e.split(",").map(t => t.trim().toLowerCase()).filter(lz) } function lz(e) { return sz.includes(e) } var Pu = "FS;", QC = { thin: 100, hairline: 100, extralight: 200, light: 300, regular: 400, medium: 500, semibold: 600, bold: 700, extrabold: 800, ultra: 800, black: 900, heavy: 900 }, ZC = Object.keys(QC), cz = (() => new RegExp(`^(?:${[...ZC, "italic"].join("|")})`, "u"))(), xi = class { constructor() { T(this, "name", "fontshare"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } static parseVariant(e) { let t = e.split(" "), n = ZC.find(s => t.includes(s)), r = e.includes("italic") ? "italic" : "normal"; return { weight: n && QC[n] || 400, style: r === "italic" ? r : "normal" } } parseSelector(e) { if (!e.startsWith(Pu)) return null; let t = e.split("-"); if (t.length !== 2) return null; let [n, r] = t; return !n || !r ? null : { name: n.replace(Pu, ""), variant: r, source: this.name } } static createSelector(e, t) { return `${Pu}${e}-${t.toLowerCase()}` } addFontFamily(e) { this.fontFamilies.push(e), this.byFamilyName.set(e.name, e) } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; for (let n of e) { let r = n.font_styles.filter(i => { let o = i.name.toLowerCase(); return !(!cz.exec(o) || o.endsWith("wide")) }); for (let i of r) { let { name: o } = n, s = i.name.toLowerCase(), a = this.getFontFamilyByName(o); a || (a = { name: o, fonts: [], source: this.name }, this.addFontFamily(a)); let l = xi.createSelector(o, s), c = xi.parseVariant(s) || { weight: void 0, style: void 0 }, { weight: u, style: f } = c, { variantBold: d, variantBoldItalic: m, variantItalic: y } = KC(s, r, xi.parseVariant), g = { family: a, variant: s, selector: l, selectorBold: d ? xi.createSelector(o, d) : void 0, selectorBoldItalic: m ? xi.createSelector(o, m) : void 0, selectorItalic: y ? xi.createSelector(o, y) : void 0, weight: u, style: f, file: i.file, category: uz(n.category) }; a.fonts.push(g), t.push(g) } } return t } }; function uz(e) { let t = { serif: "serif", sans: "sans-serif", slab: "slab", display: "display", handwritten: "handwriting", script: "handwriting" }, n = az(e)[0]; return n && t[n] } var fz = "Inter", dz = "FR;", hz = { Thin: 100, ExtraLight: 200, Light: 300, "": 400, Medium: 500, SemiBold: 600, Bold: 700, ExtraBold: 800, Black: 900 }, YS = class { constructor() { T(this, "name", "framer"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } addFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.fontFamilies.push(t), this.byFamilyName.set(t.name, t), t } static getDraftFontPropertiesBySelector(e) { if (!e.startsWith(dz) && !e.startsWith(fz)) return null; let t = e.split("-"), [n, r = ""] = t; if (!n) return null; let i = r.includes("Italic") ? "italic" : "normal", o = r.replace("Italic", ""), s = o && hz[o] || 400; return { family: n, style: i, weight: s, source: "framer", variant: void 0, category: "sans-serif" } } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; return e.forEach(n => { let { familyName: r, ...i } = n, o = this.getFontFamilyByName(r); o || (o = this.addFontFamily(r)); let s = { ...i, family: o }; o.fonts.push(s), t.push(s) }), t } }, _u = "GF;", wi = class { constructor() { T(this, "name", "google"), T(this, "fontFamilies", []), T(this, "byFamilyName", new Map) } getFontFamilyByName(e) { return this.byFamilyName.get(e) ?? null } static parseVariant(e) { if (e === "regular") return { style: "normal", weight: 400 }; let t = /(\d*)(normal|italic)?/.exec(e); if (!t) return null; let n = parseInt(t[1] || "400"), r = t[2] === "italic" ? "italic" : "normal"; return { weight: n, style: r } } parseSelector(e) { if (!e.startsWith(_u)) return null; let t = e.split("-"); if (t.length !== 2) return null; let [n, r] = t; return !n || !r ? null : { name: n.replace(_u, ""), variant: r, source: this.name } } static createSelector(e, t) { return `${_u}${e}-${t}` } addFontFamily(e) { let t = { name: e, fonts: [], source: this.name }; return this.fontFamilies.push(t), this.byFamilyName.set(t.name, t), t } importFonts(e) { this.fontFamilies.length = 0, this.byFamilyName.clear(); let t = []; return e.forEach(n => { n.variants.forEach(r => { var i; let o = n.family, s = this.getFontFamilyByName(o); s || (s = this.addFontFamily(o)); let a = wi.parseVariant(r) ?? {}, { weight: l, style: c } = a, u = wi.createSelector(o, r), { variantBold: f, variantItalic: d, variantBoldItalic: m } = KC(r, n.variants, wi.parseVariant), y = { family: s, variant: r, selector: u, selectorBold: f ? wi.createSelector(o, f) : void 0, selectorBoldItalic: m ? wi.createSelector(o, m) : void 0, selectorItalic: d ? wi.createSelector(o, d) : void 0, weight: l, style: c, category: pz(n.category), file: (i = n.files[r]) == null ? void 0 : i.replace("http://", "https://") }; s.fonts.push(y), t.push(y) }) }), t } }; function pz(e) { let t = { serif: "serif", "sans-serif": "sans-serif", display: "display", handwriting: "handwriting", monospace: "monospace" }; if (e) return t[e] } var mz = Zn(NL(), 1), KS = 5e3, gz = 3, JC = class extends Error { constructor(e) { super(e), this.name = "FontLoadingError" } }, vm = new Map, ym = new Map, vz = (e, t) => eT(e, t); async function eT(e, t, n = 0) { let { family: r, url: i, stretch: o, unicodeRange: s } = e, a = e.weight || 500, l = e.style || "normal", c = `${r}-${l}-${a}-${i}`; if (!vm.has(c) || n > 0) { let u = new FontFace(r, `url(${i})`, { weight: fe(a) ? a : a?.toString(), style: l, stretch: o, unicodeRange: s }), f = u.load().then(() => (t.fonts.add(u), tT(r, l, a))).catch(d => { if (d.name !== "NetworkError") throw d; if (n < gz) return eT(e, t, n + 1); throw new JC(`Font loading failed after ${n} retries due to network error: ${JSON.stringify({ family: r, style: l, weight: a, url: i, stretch: o, unicodeRange: s })}`) }); vm.set(c, f) } await vm.get(c) } async function tT(e, t, n) { let r = `${e}-${t}-${n}`; if (!ym.has(r)) { let o = new mz.default(e, { style: t, weight: n }).load(null, KS); ym.set(r, o) } try { await ym.get(r) } catch { throw new JC(`Failed to check if font is ready (${KS}ms timeout exceeded): ${JSON.stringify({ family: e, style: t, weight: n })}`) } } var yz = class { constructor() { T(this, "enabled", !1), T(this, "bySelector", new Map), T(this, "getGoogleFontsListPromise"), T(this, "getFontshareFontsListPromise"), T(this, "loadedSelectors", new Set), T(this, "local"), T(this, "google"), T(this, "fontshare"), T(this, "framer"), T(this, "custom"), this.local = new tz, this.google = new wi, this.fontshare = new xi, this.framer = new YS, this.custom = new oz, this.bySelector = new Map, this.importLocalFonts() } addFont(e) { this.bySelector.set(e.selector, e) } getAvailableFonts() { return Array.from(this.bySelector.values()) } importLocalFonts() { for (let e of this.local.importFonts()) this.addFont(e), this.loadFont(e) } async importGoogleFonts() { if (!this.getGoogleFontsListPromise) { this.getGoogleFontsListPromise = ut.fetchGoogleFontsList(); let e = await this.getGoogleFontsListPromise; for (let t of this.google.importFonts(e)) this.addFont(t) } return this.getGoogleFontsListPromise } async importFontshareFonts() { if (!this.getFontshareFontsListPromise) { this.getFontshareFontsListPromise = ut.fetchFontshareFontsList(); let e = await this.getFontshareFontsListPromise; for (let t of this.fontshare.importFonts(e)) this.addFont(t) } return this.getFontshareFontsListPromise } importFramerFonts(e) { this.framer.importFonts(e).forEach(t => { this.addFont(t) }) } importCustomFonts(e) { this.bySelector.forEach((t, n) => { n.startsWith(ts) && this.bySelector.delete(n) }); for (let t of this.custom.importFonts(e)) this.addFont(t) } getFontFamily(e) { return this[e.source].getFontFamilyByName(e.name) } getFontBySelector(e, t = !0) { if (e) return e.startsWith(ts) ? this.custom.getFontBySelector(e, t) : this.bySelector.get(e) } getDraftPropertiesBySelector(e) { let t = this.getFontBySelector(e); if (t) return { style: t.style, weight: t.weight, variant: t.variant, family: t.family.name, source: t.family.source, category: t.category }; let n = this.google.parseSelector(e); if (n) { let o = wi.parseVariant(n.variant); if (o) return { style: o.style, weight: o.weight, variant: n.variant, family: n.name, source: "google", category: void 0 } } let r = this.fontshare.parseSelector(e); if (r) { let o = xi.parseVariant(r.variant); if (o) return { style: o.style, weight: o.weight, variant: r.variant, family: r.name, source: "fontshare", category: void 0 } } let i = YS.getDraftFontPropertiesBySelector(e); return i || null } isSelectorLoaded(e) { return this.loadedSelectors.has(e) } async loadFont(e) { if (this.isSelectorLoaded(e.selector)) return 0; let t = e.family.source; switch (t) { case "local": return this.loadedSelectors.add(e.selector), 1; case "framer": return rz.default.env.NODE_ENV !== "test" && await tT(e.family.name, e.style, e.weight), this.loadedSelectors.add(e.selector), 1; case "google": case "fontshare": case "custom": return e.file ? (await vz({ family: e.family.name, url: e.file, weight: e.weight, style: e.style }, document), this.loadedSelectors.add(e.selector), 1) : Promise.reject(`Unable to load font: ${e.selector}`); default: xe(t) } } async loadFontsFromSelectors(e) { if (!this.enabled) return []; let t = e.some(i => i.startsWith(_u)), n = e.some(i => i.startsWith(Pu)); if (t || n) { try { await this.importFontshareFonts() } catch (i) { Ba("Failed to load Fontshare fonts:", i) } try { await this.importGoogleFonts() } catch (i) { Ba("Failed to load Google fonts:", i) } } let r = e.map(i => this.bySelector.get(i)).filter(i => !!i); return Promise.allSettled(r.map(i => this.loadFont(i))) } async loadFonts(e) { return { newlyLoadedFontCount: (await this.loadFontsFromSelectors(e)).filter(r => r.status === "fulfilled" && r.value === 1).length } } async loadMissingFonts(e, t) { let n = e.filter(i => !Fu.isSelectorLoaded(i)); if (n.length === 0) return; await Fu.loadWebFontsFromSelectors(n), n.every(i => Fu.isSelectorLoaded(i)) && t && t() } async loadWebFontsFromSelectors(e) { return this.loadFontsFromSelectors(e) } get defaultFont() { let e = this.getFontBySelector("Inter"); return H(e, "Can\u2019t find Inter font"), e } }, Fu = new yz; Promise.allSettled = Promise.allSettled || (e => Promise.all(e.map(t => t.then(n => ({ status: "fulfilled", value: n })).catch(n => ({ status: "rejected", reason: n }))))); var nT = (e => (e.Padding = "--framer-input-padding", e.BorderRadiusTopLeft = "--framer-input-border-radius-top-left", e.BorderRadiusTopRight = "--framer-input-border-radius-top-right", e.BorderRadiusBottomRight = "--framer-input-border-radius-bottom-right", e.BorderRadiusBottomLeft = "--framer-input-border-radius-bottom-left", e.BorderColor = "--framer-input-border-color", e.BorderTopWidth = "--framer-input-border-top-width", e.BorderRightWidth = "--framer-input-border-right-width", e.BorderBottomWidth = "--framer-input-border-bottom-width", e.BorderLeftWidth = "--framer-input-border-left-width", e.BorderStyle = "--framer-input-border-style", e.Background = "--framer-input-background", e.FontFamily = "--framer-input-font-family", e.FontWeight = "--framer-input-font-weight", e.FontSize = "--framer-input-font-size", e.FontColor = "--framer-input-font-color", e.FontStyle = "--framer-input-font-style", e.FontLetterSpacing = "--framer-input-font-letter-spacing", e.FontTextAlignment = "--framer-input-font-text-alignment", e.FontLineHeight = "--framer-input-font-line-height", e.PlaceholderColor = "--framer-input-placeholder-color", e.BoxShadow = "--framer-input-box-shadow", e.FocusedBorderColor = "--framer-input-focused-border-color", e.FocusedBorderWidth = "--framer-input-focused-border-width", e.FocusedBorderStyle = "--framer-input-focused-border-style", e.FocusedBackground = "--framer-input-focused-background", e.FocusedBoxShadow = "--framer-input-focused-box-shadow", e.FocusedTransition = "--framer-input-focused-transition", e.BooleanCheckedBackground = "--framer-input-boolean-checked-background", e.BooleanCheckedBorderColor = "--framer-input-boolean-checked-border-color", e.BooleanCheckedBorderWidth = "--framer-input-boolean-checked-border-width", e.BooleanCheckedBorderStyle = "--framer-input-boolean-checked-border-style", e.BooleanCheckedBoxShadow = "--framer-input-boolean-checked-box-shadow", e.BooleanCheckedTransition = "--framer-input-boolean-checked-transition", e.InvalidTextColor = "--framer-input-invalid-text-color", e.IconBackgroundImage = "--framer-input-icon-image", e.IconMaskImage = "--framer-input-icon-mask-image", e.IconColor = "--framer-input-icon-color", e.WrapperHeight = "--framer-input-wrapper-height", e))(nT || {}), Ce = nT, QS = "framer-form-input", bz = "framer-form-input-wrapper"; function xz(e) { return typeof e == "number" ? e : e.startsWith("--") ? xt.variable(e) : e === "" ? '""' : e } function xt(e, t) { let n = " "; for (let r in t) { let i = t[r]; n += `${r.replace(/([A-Z])/gu, "-$1").toLowerCase()}: ${xz(i)}; ` } return e + " {" + n + "}" } (e => { function t(...n) { let r = n[n.length - 1], i = r.startsWith("--") ? `var(${r})` : r; for (let o = n.length - 2; o >= 0; o--)i = `var(${n[o]}, ${i})`; return i } e.variable = t })(xt || (xt = {})); var RW = [xt(`.${QS}`, { padding: xt.variable(Ce.Padding), background: "transparent", fontFamily: xt.variable(Ce.FontFamily), fontWeight: xt.variable(Ce.FontWeight), fontSize: xt.variable(Ce.FontSize), fontStyle: xt.variable(Ce.FontStyle), color: xt.variable(Ce.FontColor), border: "none", textOverflow: "ellipsis", whiteSpace: "nowrap", overflow: "hidden", width: "100%", height: xt.variable(Ce.WrapperHeight, "100%"), letterSpacing: xt.variable(Ce.FontLetterSpacing), textAlign: xt.variable(Ce.FontTextAlignment), lineHeight: xt.variable(Ce.FontLineHeight) }), xt(`.${QS}:focus-visible`, { outline: "none" })]; var PW = `var(${Ce.BorderTopWidth}) var(${Ce.BorderRightWidth}) var(${Ce.BorderBottomWidth}) var(${Ce.BorderLeftWidth})`, _W = [`.${bz}:after {
        content: "";
        pointer-events: none;
        box-sizing: border-box;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-top-left-radius: var(${Ce.BorderRadiusTopLeft});
        border-top-right-radius: var(${Ce.BorderRadiusTopRight});
        border-bottom-right-radius: var(${Ce.BorderRadiusBottomRight});
        border-bottom-left-radius: var(${Ce.BorderRadiusBottomLeft});
        border-color: var(${Ce.BorderColor});
        border-top-width: var(${Ce.BorderTopWidth});
        border-right-width: var(${Ce.BorderRightWidth});
        border-bottom-width: var(${Ce.BorderBottomWidth});
        border-left-width: var(${Ce.BorderLeftWidth});
        border-style: var(${Ce.BorderStyle});
        transition: var(${Ce.FocusedTransition});
        transition-property: border-color, border-width, border-style, border-top-left-radius, border-top-right-radius, border-bottom-right-radius, border-bottom-left-radius;
    }`]; var bm = 16, FW = { content: "", display: "block", position: "absolute", right: 0, top: 0, bottom: 0, width: `${bm}px`, boxSizing: "content-box", padding: xt.variable(Ce.Padding), border: "none", pointerEvents: "none", backgroundRepeat: "no-repeat", backgroundSize: `${bm}px`, maskRepeat: "no-repeat", maskSize: `${bm}px`, backgroundColor: xt.variable(Ce.IconColor) }; var zW = x.forwardRef(function (t, n) { let { background: r, children: i, alt: o, ...s } = t, a = { ...s.style }; r && delete a.background; let l = el(t.as); return ce(l, { ...s, style: a, ref: n, children: [r && k(Nk, { image: r, alt: o }), i] }) }); function wz(e, t) { return e.length === t.length && e.every((n, r) => n === t[r]) } var Sz = /[^\p{Letter}\p{Number}()]+/gu, kz = /^-+|-+$/gu; function Cz(e) { return e.toLowerCase().replace(Sz, "-").replace(kz, "") } var Tz = /[&<>'"]/g, Ez = e => e.replace(Tz, t => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" })[t] || t), Rz = /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi; function Pz(e, t, n, r) { return e.replace(Rz, (i, o, s, a, l, c, u) => { var f, d; if (s.toLowerCase() !== "a") return i; let m = l || c, y = dg(m.replace(/&amp;/g, "&")); if (!y || !y.target) return i; let g = t(y.target); if (!J1(g) || !J1(n)) return i; let b = g.path, h = n.path; if (!b || !h) return i; let p = ` data-framer-page-link-target="${y.target}"`, v = Gm(g, y.element ?? void 0); v && (p += ` data-framer-page-link-element="${y.element}"`); let w = Pm(m); if (!w || fe(w)) return i; kC(n, w, r) && (p += " data-framer-page-link-current"); let C = b, S = Object.assign({}, r, (f = y.collectionItem) == null ? void 0 : f.pathVariables); if (Object.keys(S).length > 0 && (C = C.replace(wC, (R, E) => "" + S[E])), (d = y.collectionItem) != null && d.pathVariables) { let R = new URLSearchParams(y.collectionItem.pathVariables); p += ` data-framer-page-link-path-variables="${R}"` } return C = uk(h, C), o + a + `"${Ez(C + (v ? `#${v}` : ""))}"` + p + u }) } var _z = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, rT = /[&<>"']/gu, Fz = (() => new RegExp(rT.source))(); function ZS(e) { return e && Fz.test(e) ? e.replace(rT, t => _z[t] ?? "") : e || "" } var JS = "{{ text-placeholder }}", Iz = "rich-text-wrapper", Lz = Ve(function (t, n) { let { id: r, name: i, html: o, htmlFromDesign: s, text: a, textFromDesign: l, fonts: c = [], width: u, height: f, left: d, right: m, top: y, bottom: g, center: b, className: h, stylesPresetsClassName: p, visible: v = !0, opacity: w, rotation: C = 0, verticalAlignment: S = "top", isEditable: R = !1, willChangeTransform: E, environment: L = le.current, withExternalLayout: F = !1, positionSticky: z, positionStickyTop: D, positionStickyRight: K, positionStickyBottom: U, positionStickyLeft: $, __htmlStructure: W, __fromCanvasComponent: ee = !1, _forwardedOverrideId: te, _forwardedOverrides: q, _usesDOMRect: ne, children: be, ...re } = t, pe = Qa(), ie = tl(t), ht = A(null), _e = n ?? ht, { navigate: Lt, getRoute: Se } = Uu(), Qt = Qm(); ZM(t.preload ?? []), Yu(t, _e); let Pn = V(cs), _n = tf(), me = a, Gn = te ?? r; if (Gn && q) { let Xe = q[Gn]; typeof Xe == "string" && (me = Xe) } let ot = ""; if (me) { let Xe = ZS(me); ot = W ? W.replace(JS, Xe) : `<p>${Xe}</p>` } else if (o) ot = o; else if (l) { let Xe = ZS(l); ot = W ? W.replace(JS, Xe) : `<p>${Xe}</p>` } else s && (ot = s); let dn = SC(), sl = ae(() => _n || !Se || !Qt ? ot : Pz(ot, Se, Qt, dn), [_n, ot, Se, Qt, dn]); if (N(() => { let Xe = _e.current; if (Xe === null) return; function pr(Zt) { let Ci = fg(Zt.target, _e.current); if (Zt.metaKey || !Lt || !Ci || Ci.getAttribute("target") === "_blank") return; y5(Lt, Ci, dn) && Zt.preventDefault() } return Xe.addEventListener("click", pr), () => { Xe.removeEventListener("click", pr) } }, [Lt, dn]), oT(c, ee, _e), st(() => { Za() }, []), !v) return null; let P = R && L() === le.canvas, _ = { outline: "none", display: "flex", flexDirection: "column", justifyContent: iT(S), opacity: P ? 0 : w, flexShrink: 0 }, O = le.hasRestrictions(), j = za(t, pe || 0, !1), ge = ne && (u === "auto" || f === "auto"), pt = !!t.transformTemplate || !j || !O || ee || ge ? t.transformTemplate ?? qu(b) : void 0; if (!F) { if (j && O && !ge) { let Xe = rt.getNumber(C).toFixed(4); _.transform = `translate(${j.x}px, ${j.y}px) rotate(${Xe}deg)`, _.width = j.width, _.minWidth = j.width, _.height = j.height } else _.left = d, _.right = m, _.top = y, _.bottom = g, _.width = u, _.height = f, _.rotate = C; z ? (!_n || Pn) && (_.position = "sticky", _.willChange = "transform", _.zIndex = 1, _.top = D, _.right = K, _.bottom = U, _.left = $) : _n && (t.positionFixed || t.positionAbsolute) && (_.position = "absolute") } return lg(t, _), tC(t, _), E && og(_), Object.assign(_, t.style), k(gn.div, { id: r, ref: _e, ...re, style: _, layoutId: ie, "data-framer-name": i, "data-framer-component-type": "DeprecatedRichText", "data-center": b, className: Du(h, p, Iz), transformTemplate: pt, dangerouslySetInnerHTML: { __html: sl } }) }); function iT(e) { switch (e) { case "top": return "flex-start"; case "center": return "center"; case "bottom": return "flex-end" } } function oT(e, t, n) { let r = A([]); wz(r.current, e) || (r.current = e, Fu.loadFonts(e).then(({ newlyLoadedFontCount: i }) => { !t || !n.current || le.current() !== le.canvas || i > 0 && _A(n.current) })) } var sT = { opacity: 1, y: 0, x: 0, scale: 1, rotate: 0, rotateX: 0, rotateY: 0, skewX: 0, skewY: 0, filter: "none" }; function Mz(e) { return e in sT } function Oz(e) { let t = {}; for (let n in e) !Mz(n) || it(e[n]) || (t[n] = [e[n], sT[n]]); return t } var Dz = /\p{Regional_Indicator}{2}|\p{Emoji}\p{Emoji_Modifier}?\p{Variation_Selector}?(?:\u{200d}\p{Emoji}\p{Emoji_Modifier}?\p{Variation_Selector}?)*|./gu; function Az(e, t = "character", n, r) { switch (t) { case "character": case "line": { let i = e.split(" "), o = i.length - 1; return i.map((s, a) => { var l; let c = a === o, u = s.length <= 12; return ce(He, { children: [k("span", { style: { whiteSpace: u ? "nowrap" : "unset" }, children: (l = s.match(Dz)) == null ? void 0 : l.map((f, d) => { let m = oo(); return n.add(m), k("span", { ref: m, style: r, children: f }, f + d) }) }, s + a), c ? null : " "] }) }) } case "word": { let i = e.split(" "), o = i.length - 1; return i.map((s, a) => { let l = a === o, c = oo(); return n.add(c), ce(He, { children: [k("span", { ref: c, style: r, children: s }, s + a), l ? null : " "] }) }) } case "element": default: return e } } function Vz(e) { let t = e.type; switch (t) { case "appear": return e.tokenization ?? "character"; default: xe(t) } } function ek(e) { let t = []; return Ae(e.x) && t.push(`translateX(${e.x}px)`), Ae(e.y) && t.push(`translateY(${e.y}px)`), Ae(e.scale) && t.push(`scale(${e.scale})`), Ae(e.rotate) && t.push(`rotate(${e.rotate}deg)`), Ae(e.rotateX) && t.push(`rotateX(${e.rotateX}deg)`), Ae(e.rotateY) && t.push(`rotateY(${e.rotateY}deg)`), Ae(e.skewX) && t.push(`skewX(${e.skewX}deg)`), Ae(e.skewY) && t.push(`skewY(${e.skewY}deg)`), t.join(" ") } function Bz(e, t, n) { if (!n || !n.effect) return; let r = n.type; switch (r) { case "appear": switch (n.tokenization) { case "element": return !e || !t ? void 0 : { opacity: n.effect.opacity, filter: n.effect.filter, transform: ek(n.effect) }; case "line": case "word": case "character": default: return !e || !t ? { display: "inline-block" } : { display: "inline-block", opacity: n.effect.opacity, filter: n.effect.filter, transform: ek(n.effect) } }default: xe(r) } } function zz(e, t, n) { let r = Rn(() => new Set), i = tf(), o = n || !i, s = A({ hasMounted: !1, hasAnimatedOnce: !1, isAnimating: !1, effect: e }); s.current.effect = e; let a = e?.trigger ?? "onMount", l = e?.target, c = e?.threshold; N(() => { if (!o || n) return; s.current.hasMounted = !0; function d() { let { effect: m } = s.current; if (!o || !m || m?.repeat !== !0 && s.current.hasAnimatedOnce || m?.type === "appear" && s.current.isAnimating) return; Object.assign(s.current, { hasAnimatedOnce: !0, isAnimating: !0 }); let y = m.type; switch (y) { case "appear": { let { transition: g, startDelay: b, repeat: h, tokenization: p } = m; return tk(p, m.effect, r, g, b, h, () => { Object.assign(s.current, { isAnimating: !1 }) }) } default: xe(y) } } switch (a) { case "onMount": d(); return; case "onInView": { let m = t?.current; return m ? Dd(m, d, { amount: c ?? 0 }) : void 0 } case "onScrollTarget": { let m = l?.ref.current; return m ? Dd(m, d, { amount: c ?? 0, root: document, margin: l?.offset ? `${l.offset}px 0px 0px 0px` : void 0 }) : void 0 } default: xe(a) } }, [o, r, n, t, l, c, a]); let u = !!e, f = e ? Vz(e) : void 0; return ae(() => ({ getTokenizer: () => { if (r.clear(), !u) return; let { hasMounted: d, hasAnimatedOnce: m, effect: y } = s.current, g = Bz(o, n || $z(d, m, y), s.current.effect); return { text: b => Az(b, f, r, g), props: b => { if (y?.tokenization !== "element") return; let h = oo(); return r.add(h), { ref: h, style: { ...b, ...g } } } } }, play: () => { let { effect: d } = s.current; if (!d) return; let m = d.type; switch (m) { case "appear": { let { transition: y, startDelay: g } = d; tk(f, d.effect, r, y, g); break } default: xe(m) } } }), [o, u, r, n, f]) } function $z(e, t, n) { return !(e && n?.trigger === "onMount" || t && !n?.repeat && (n?.trigger === "onInView" || n?.trigger === "onScrollTarget")) } function tk(e = "character", t, n, r, i = 0, o = !1, s) { let a = Oz(t); switch (e) { case "character": case "element": case "word": { let l = Nz(n); return l.length === 0 || (tr(l, a, { ...r, restDelta: .001, delay: Bd(r?.delay ?? 0, { startDelay: i }) }).then(() => s?.()), !o) ? void 0 : () => void tr(l, t, { ...r, restDelta: .001, delay: Bd(r?.delay ?? 0, { startDelay: i }) }) } case "line": { let l; return Y.read(() => { l = Hz(n), l.length !== 0 && Y.update(() => { let c = l.map((u, f) => tr(u, a, { ...r, restDelta: .001, delay: i + f * (r?.delay ?? 0) })); Promise.all(c).then(() => s?.()) }) }), o ? () => { l.length !== 0 && l.forEach((c, u) => { tr(c, t, { ...r, restDelta: .001, delay: i + u * (r?.delay ?? 0) }) }) } : void 0 } default: xe(e) } } function Nz(e) { let t = []; for (let n of e) n.current && t.push(n.current); return t } function Hz(e) { let t = [], n = [], r = null; for (let i of e) { if (!i.current) continue; let o = i.current.offsetTop, s = i.current.offsetHeight; !s || r === null || o === r ? n.push(i.current) : (t.push(n), n = [i.current]), s && (r = o) } return t.push(n), t } var nk = Ve(({ viewBoxScale: e, viewBox: t, children: n, ...r }, i) => k(gn.svg, { ref: i, ...r, viewBox: t, children: k(gn.foreignObject, { width: "100%", height: "100%", className: "framer-fit-text", transform: `scale(${e})`, style: { overflow: "visible", transformOrigin: "center center" }, children: n }) })), jz = Ve((e, t) => { let { __fromCanvasComponent: n = !1, _forwardedOverrideId: r, _forwardedOverrides: i, _usesDOMRect: o, anchorLinkOffsetY: s, as: a, bottom: l, center: c, children: u, environment: f = le.current, fonts: d = [], height: m, isEditable: y = !1, left: g, name: b, opacity: h, positionSticky: p, positionStickyBottom: v, positionStickyLeft: w, positionStickyRight: C, positionStickyTop: S, right: R, rotation: E = 0, style: L, _initialStyle: F, stylesPresetsClassNames: z, text: D, top: K, verticalAlignment: U = "top", visible: $ = !0, width: W, willChangeTransform: ee, withExternalLayout: te = !1, viewBox: q, viewBoxScale: ne = 1, effect: be, ...re } = e, pe = Qa(), ie = tf(), ht = V(cs), _e = tl(e), Lt = A(null), Se = t ?? Lt; Yu(e, Se), oT(d, n, Se), st(() => { Za() }, []); let Qt = zz(be, Se), Pn = ae(() => { if (u) return aT(u, z, D, s, void 0, Qt.getTokenizer()) }, [u, z, D, s, Qt]); if (!$) return null; let _n = y && f() === le.canvas, me = { outline: "none", display: "flex", flexDirection: "column", justifyContent: iT(U), opacity: _n ? 0 : h, flexShrink: 0 }, Gn = le.hasRestrictions(), ot = za(e, pe || 0, !1), dn = o && (W === "auto" || m === "auto"), P = !!e.transformTemplate || !ot || !Gn || n || dn ? e.transformTemplate ?? qu(c) : void 0; te || (ot && Gn && !dn ? (me.x = ot.x, me.y = ot.y, me.rotate = rt.getNumber(E), me.width = ot.width, me.minWidth = ot.width, me.height = ot.height) : (me.left = g, me.right = R, me.top = K, me.bottom = l, me.width = W, me.height = m, me.rotate = E), p ? (!ie || ht) && (me.position = "sticky", me.willChange = "transform", me.zIndex = 1, me.top = S, me.right = C, me.bottom = v, me.left = w) : ie && (e.positionFixed || e.positionAbsolute) && (me.position = "absolute")), lg(e, me), tC(e, me), ee && og(me), Object.assign(me, F, L), _e && (re.layout = "preserve-aspect"); let _ = el(e.as); return fe(e.viewBox) ? e.as !== void 0 ? k(_, { ...re, ref: Se, style: me, layoutId: _e, transformTemplate: P, "data-framer-name": b, "data-framer-component-type": "RichTextContainer", children: k(nk, { viewBox: q, viewBoxScale: ne, style: { width: "100%", height: "100%" }, children: Pn }) }) : k(nk, { ...re, ref: Se, style: me, layoutId: _e, viewBox: q, viewBoxScale: ne, transformTemplate: P, "data-framer-name": b, "data-framer-component-type": "RichTextContainer", children: Pn }) : k(_, { ...re, ref: Se, style: me, layoutId: _e, transformTemplate: P, "data-framer-name": b, "data-framer-component-type": "RichTextContainer", children: Pn }) }); function Wz(e) { return e.type === mr } function Uz(e) { return e.type === "br" } function aT(e, t, n, r, i = {}, o, s = Wz(e) ? -1 : 0) { let a = qn.toArray(e.props.children); fe(n) && (a = a.slice(0, 1)); let l = !0; a = a.map(f => { if ((!Nt(f) || !Uz(f)) && (l = !1), Nt(f)) return aT(f, t, n, r, i, o, s + 1); let d = fe(n) ? n : f; return fe(d) && o ? o.text(d) : d }); let { ["data-preset-tag"]: c, ...u } = e.props; if (fe(e.type) || Ad(e.type)) { let f = cb(e.type) || e.type, d = c || f, m = fe(d) ? t?.[d] : void 0; u.className = Du("framer-text", u.className, m), o && s === 0 && !l && Object.assign(u, o.props(u.style)); let y = f === "h1" || f === "h2" || f === "h3" || f === "h4" || f === "h5" || f === "h6", g = t?.anchor; if (y && g) { let b = Gz(a, i); u.id = b; let h = Du("framer-text", g), p = k("a", { href: `#${b}`, className: h, children: a }); u.style = { ...u.style ?? {}, scrollMarginTop: r }, a = [p] } } return gr(e, u, ...a) } function Gz(e, t) { let n = e.map(Wm).join(""), r = Cz(n), i = t[r] ?? 0; return i > 0 && (r += `-${i}`), t[r] = i + 1, r } function Wm(e) { return fe(e) || Ae(e) ? e.toString() : Nt(e) ? Wm(e.props.children) : Array.isArray(e) ? e.map(Wm).join("") : "" } var UW = Ve(({ children: e, html: t, htmlFromDesign: n, ...r }, i) => { let o = t || e || n; if (fe(o)) { !r.stylesPresetsClassName && Me(r.stylesPresetsClassNames) && (r.stylesPresetsClassName = Object.values(r.stylesPresetsClassNames).join(" ")); let s = { [fe(t) ? "html" : "htmlFromDesign"]: o }; return k(Lz, { ...r, ...s, ref: i }) } if (!r.stylesPresetsClassNames && fe(r.stylesPresetsClassName)) { let [s, a, l, c, u] = r.stylesPresetsClassName.split(" "); s === void 0 || a === void 0 || l === void 0 || c === void 0 || u === void 0 ? console.warn(`Encountered invalid stylesPresetsClassNames: ${r.stylesPresetsClassNames}`) : r.stylesPresetsClassNames = { h1: s, h2: a, h3: l, p: c, a: u } } return k(jz, { ...r, ref: i, children: Nt(o) ? o : void 0 }) }); function qz(e) { var t, n; let r = e * Math.PI / 180, i = { x: -Math.sin(r) * 100, y: Math.cos(r) * 100 }, o = fn(i.x, i.y), s = Tn(fn(.5, .5), o), a = Z.points({ x: 0, y: 0, width: 1, height: 1 }), l = a.map(g => ({ point: g, distance: fn.distance(o, g) })).sort((g, b) => g.distance - b.distance), c = (t = l[0]) == null ? void 0 : t.point, u = (n = l[1]) == null ? void 0 : n.point; H(c && u, "linearGradientLine: Must have 2 closest points."); let [f, d] = a.filter(g => !fn.isEqual(g, c) && !fn.isEqual(g, u)); H(f && d, "linearGradientLine: Must have 2 opposing points."); let m = Tn.intersection(s, Tn(c, u)), y = Tn.intersection(s, Tn(f, d)); return H(m && y, "linearGradientLine: Must have a start and end point."), Tn(m, y) } function Xz(e, t) { var n, r; let i = qz(e.angle), o = nl(e), s = ((n = o[0]) == null ? void 0 : n.position) ?? 0, a = ((r = o[o.length - 1]) == null ? void 0 : r.position) ?? 1, l = Tn.pointAtPercentDistance(i, s), c = Tn.pointAtPercentDistance(i, a), u = xo([s, a], [0, 1]); return { id: `id${t}g${Na.hash(e)}`, x1: l.x, y1: l.y, x2: c.x, y2: c.y, stops: o.map(f => ({ color: f.value, alpha: sg.getAlpha(f.value) * e.alpha, position: u(f.position) })) } } function Yz(e, t) { return { id: `id${t}g${Ha.hash(e)}`, widthFactor: e.widthFactor, heightFactor: e.heightFactor, centerAnchorX: e.centerAnchorX, centerAnchorY: e.centerAnchorY, stops: nl(e).map(n => ({ color: n.value, alpha: sg.getAlpha(n.value) * e.alpha, position: n.position })) } } function lT(e) { if (!fe(e) || e.charAt(e.length - 1) !== "%") return !1; let n = e.slice(0, -1), r = parseFloat(n); return Ae(r) } function cT(e) { let t = e.slice(0, -1), n = parseFloat(t); return Ae(n) ? n : 50 } function rk(e) { return lT(e) ? cT(e) / 100 : e === "left" ? 0 : e === "right" ? 1 : .5 } function ik(e) { return lT(e) ? cT(e) / 100 : e === "top" ? 0 : e === "bottom" ? 1 : .5 } function Kz(e, t, n, r) { if (e = rt.get(e, "#09F"), !Ki.isImageObject(e) || !e.pixelWidth || !e.pixelHeight) return; let i = e.pixelWidth, o = e.pixelHeight, s, { fit: a } = e, l = 1, c = 1, u = 0, f = 0; if (a === "fill" || a === "fit" || a === "tile" || !a) { let m = 1, y = 1, g = i / o, b = t.height * g, h = t.width / g, p = b / t.width, v = h / t.height; if (a === "tile") { e.backgroundSize ?? (e.backgroundSize = 1), l = Math.round(e.backgroundSize * (i / 2)), c = Math.round(e.backgroundSize * (o / 2)); let w = t.x ?? 0, C = t.y ?? 0, S = 0, R = 0; r && (S = w, R = C), u = (t.width - l) * rk(e.positionX) + S, f = (t.height - c) * ik(e.positionY) + R, s = `translate(${u + w}, ${f + C})` } else (a === "fill" || !a ? v > p : v < p) ? (y = v, f = (1 - v) * ik(e.positionY)) : (m = p, u = (1 - p) * rk(e.positionX)), s = `translate(${u}, ${f}) scale(${m}, ${y})` } return { id: `id${n}g-fillImage`, path: e.src ?? "", transform: s, width: l, height: c, offsetX: u, offsetY: f } } var Qz = "framer/asset-reference,"; function Zz(e) { return e.startsWith(`data:${Qz}`) } function Jz(e, t) { if (/^\w+:/.test(e) && !Zz(e)) return e; typeof t != "number" ? t = void 0 : t <= 512 ? t = 512 : t <= 1024 ? t = 1024 : t <= 2048 ? t = 2048 : t = 4096; let n = le.current() === le.export; return ut.assetResolver(e, { pixelSize: t, isExport: n }) ?? "" } var e$ = ({ id: e, path: t, transform: n, repeat: r, width: i, height: o, offsetX: s, offsetY: a }) => { let l = Jz(t); return k("pattern", { id: e, width: r ? i : "100%", height: r ? o : "100%", patternContentUnits: r ? void 0 : "objectBoundingBox", patternUnits: r ? "userSpaceOnUse" : void 0, x: r ? s : void 0, y: r ? a : void 0, children: k("image", { width: r ? i : 1, height: r ? o : 1, href: l, preserveAspectRatio: "none", transform: r ? void 0 : n, x: r ? 0 : void 0, y: r ? 0 : void 0 }, l) }) }; var xm, t$ = (() => !yA() && typeof Document < "u" && typeof Document.parseHTMLUnsafe == "function")(); function n$(e, t) { return t$ && !t ? Document.parseHTMLUnsafe(e) : (xm ?? (xm = new DOMParser), xm.parseFromString(e, t ?? "text/html")) } var ok = zr(), r$ = class { constructor(e, t, n, r, i = 0) { this.id = e, this.svg = t, this.innerHTML = n, this.viewBox = r, this.count = i } }, sk = "position: absolute; overflow: hidden; bottom: 0; left: 0; width: 0; height: 0; z-index: 0; contain: strict", i$ = class {
    constructor() { T(this, "entries", new Map) } debugGetEntries() { return this.entries } subscribe(e, t, n) { if (!e || e === "") return ""; let r = this.entries.get(e); if (!r) { n || (n = `svg${String(Yk(e))}_${String(e.length)}`); let i = e, o, s = o$(e); s && (t && s$(s, n), s.id = n, o = u$(s), s.removeAttribute("xmlns"), s.removeAttribute("xlink"), s.removeAttribute("xmlns:xlink"), i = s.outerHTML), r = this.createDOMElementFor(i, n, o), this.entries.set(e, r) } return r.count += 1, r.innerHTML } getViewBox(e) { if (!e || e === "") return; let t = this.entries.get(e); return t?.viewBox } unsubscribe(e) { if (!e || e === "") return; let t = this.entries.get(e); t && (t.count -= 1, !(t.count > 0) && setTimeout(() => this.maybeRemoveEntry(e), 5e3)) } maybeRemoveEntry(e) { let t = this.entries.get(e); t && (t.count > 0 || (this.entries.delete(e), this.removeDOMElement(t))) } removeDOMElement(e) { if (ok) { let t = document?.getElementById(e.id); t?.remove() } } createDOMElementFor(e, t, n) { if (ok) { let s = document.getElementById("svg-templates"); if (s || (s = document.createElement("div"), s.id = "svg-templates", s.style.cssText = sk, document.body.appendChild(s)), !document.getElementById(t)) { let a = document.createElement("div"); a.innerHTML = e; let l = a.firstElementChild; l && (l.id = t, s.appendChild(l)) } } let r = n ? `0 0 ${n.width} ${n.height}` : void 0, o = `<svg style="width:100%;height:100%"${r ? ` viewBox="${r}"` : ""}><use href="#${t}"/></svg>`; return new r$(t, e, o, r) } clear() { this.entries.clear() } generateTemplates() {
        let e = []; return e.push(`<div id="svg-templates" style="${sk}">`), this.entries.forEach(t => e.push(t.svg)), e.push("</div>"), e.join(`
`)
    }
}, Jo = new i$; function o$(e) { try { let n = n$(e).getElementsByTagName("svg")[0]; if (!n) throw Error("no svg element found"); return n } catch { return } } function s$(e, t) { let n = a$(t); uT(e, n) } function a$(e) { return e.replace(/[^\w\-:.]|^[^a-z]+/gi, "") } function uT(e, t) { l$(e, t), Array.from(e.children).forEach(r => { uT(r, t) }) } function l$(e, t) { e.getAttributeNames().forEach(r => { let i = e.getAttribute(r); if (!i) return; if (r === "id" && e.setAttribute(r, `${t}_${i}`), r === "href" || r === "xlink:href") { let [s, a] = i.split("#"); if (s) return; e.setAttribute(r, `#${t}_${a}`); return } let o = "url(#"; if (i.includes(o)) { let s = i.replace(o, `${o}${t}_`); e.setAttribute(r, s) } }) } var c$ = (() => ({ cm: 96 / 2.54, mm: 96 / 2.54 / 10, Q: 96 / 2.54 / 40, in: 96, pc: 96 / 6, pt: 96 / 72, px: 1, em: 16, ex: 8, ch: 8, rem: 16 }))(); function ak(e) { var t; if (!e) return; let n = /(-?[\d.]+)([a-z%]*)/u.exec(e); if (!(n?.[1] === void 0 || n?.[2] === void 0) && !((t = n[2]) != null && t.startsWith("%"))) return Math.round(parseFloat(n[1]) * (c$[n[2]] || 1)) } function u$(e) { let t = ak(e.getAttribute("width")), n = ak(e.getAttribute("height")); if (!(typeof t != "number" || typeof n != "number") && !(t <= 0 || n <= 0)) return { width: t, height: n } } function YW(e) { let t = Qa(), n = tl(e), r = x.useRef(null), i = QB(); return Yu(e, r), k(g$, { ...e, innerRef: r, parentSize: t, layoutId: n, providedWindow: i }) } var f$ = 5e4; function d$(e) { return e.indexOf("image") >= 0 } function h$(e) { return e.indexOf("var(--") >= 0 } function p$(e) { return !!(e.borderRadius || e.borderBottomLeftRadius || e.borderBottomRightRadius || e.borderTopLeftRadius || e.borderTopRightRadius) } function lk(e, t) { var n, r; let i = e.current; if (!i) return; let o = t.providedWindow ?? ft, s = i.firstElementChild; if (!s || !(s instanceof o.SVGSVGElement)) return; if (!s.getAttribute("viewBox")) { let m = Jo.getViewBox(t.svg); m && s.setAttribute("viewBox", m) } let { withExternalLayout: a, parentSize: l } = t; if (!a && Ka(t) && l !== 1 && l !== 2) return; let { intrinsicWidth: u, intrinsicHeight: f, _constraints: d } = t; ((n = s.viewBox.baseVal) == null ? void 0 : n.width) === 0 && ((r = s.viewBox.baseVal) == null ? void 0 : r.height) === 0 && J(u) && J(f) && s.setAttribute("viewBox", `0 0 ${u} ${f}`), d && d.aspectRatio ? s.setAttribute("preserveAspectRatio", "") : s.setAttribute("preserveAspectRatio", "none"), s.setAttribute("width", "100%"), s.setAttribute("height", "100%") } function m$() { return x.useInsertionEffect(() => { Za() }, []), null } var g$ = (() => { var e; return e = class extends ku { constructor() { super(...arguments), T(this, "container", x.createRef()), T(this, "svgElement", null), T(this, "setSVGElement", t => { this.svgElement = t, this.setLayerElement(t) }), T(this, "previouslyRenderedSVG", ""), T(this, "unmountedSVG", "") } static frame(t) { return za(t, t.parentSize || 0) } get frame() { return za(this.props, this.props.parentSize || 0) } componentDidMount() { if (this.unmountedSVG) { let { svgContentId: t } = this.props, n = t ? `svg${t}` : null; Jo.subscribe(this.unmountedSVG, !t, n), this.previouslyRenderedSVG = this.unmountedSVG } this.props.svgContentId || lk(this.container, this.props) } componentWillUnmount() { Jo.unsubscribe(this.previouslyRenderedSVG), this.unmountedSVG = this.previouslyRenderedSVG, this.previouslyRenderedSVG = "" } componentDidUpdate(t) { if (super.componentDidUpdate(t), this.props.svgContentId) return; let { fill: n } = this.props; Ki.isImageObject(n) && Ki.isImageObject(t.fill) && n.src !== t.fill.src && Xk(this.svgElement, "fill", null, !1), lk(this.container, this.props) } collectLayout(t, n) { if (this.props.withExternalLayout) { n.width = "100%", n.height = "100%", n.aspectRatio = "inherit"; return } let r = this.frame, { rotation: i, intrinsicWidth: o, intrinsicHeight: s, width: a, height: l } = this.props, c = rt.getNumber(i); if (t.opacity = J(this.props.opacity) ? this.props.opacity : 1, le.hasRestrictions() && r) { Object.assign(t, { transform: `translate(${r.x}px, ${r.y}px) rotate(${c.toFixed(4)}deg)`, width: `${r.width}px`, height: `${r.height}px` }), Ka(this.props) && (t.position = "absolute"); let y = r.width / (o || 1), g = r.height / (s || 1); n.transformOrigin = "top left"; let { zoom: b, target: h } = Lu; if (h === le.export) { let p = b > 1 ? b : 1; n.transform = `scale(${y * p}, ${g * p})`, n.zoom = 1 / p } else n.transform = `scale(${y}, ${g})`; o && s && (n.width = o, n.height = s); return } let { left: u, right: f, top: d, bottom: m } = this.props; Object.assign(t, { left: u, right: f, top: d, bottom: m, width: a, height: l, rotate: c }), Object.assign(n, { left: 0, top: 0, bottom: 0, right: 0, position: "absolute" }) } render() { let { id: t, visible: n, style: r, fill: i, svg: o, intrinsicHeight: s, intrinsicWidth: a, title: l, description: c, layoutId: u, className: f, variants: d, withExternalLayout: m, innerRef: y, svgContentId: g, height: b, opacity: h, width: p, ...v } = this.props; if (!m && (!n || !t)) return null; let w = t ?? u ?? "svg", C = this.frame, S = C || { width: a || 100, height: s || 100 }, R = { ...r, imageRendering: "pixelated", flexShrink: 0 }, E = {}; this.collectLayout(R, E), kV(this.props, R), lg(this.props, R), ku.applyWillChange(this.props, R, !1); let L = null; if (typeof i == "string" || G.isColorObject(i)) { let q = G.isColorObject(i) ? i.initialValue || G.toRgbString(i) : i; R.fill = q, R.color = q } else if (Na.isLinearGradient(i)) { let q = i, ne = `${encodeURI(t || "")}g${Na.hash(q)}`; R.fill = `url(#${ne})`; let { stops: be, x1: re, x2: pe, y1: ie, y2: ht } = Xz(q, w); L = k("svg", { ref: this.setSVGElement, width: "100%", height: "100%", style: { position: "absolute" }, children: k("linearGradient", { id: ne, x1: re, x2: pe, y1: ie, y2: ht, children: be.map((_e, Lt) => k("stop", { offset: _e.position, stopColor: _e.color, stopOpacity: _e.alpha }, Lt)) }) }) } else if (Ha.isRadialGradient(i)) { let q = i, ne = `${encodeURI(t || "")}g${Ha.hash(q)}`; R.fill = `url(#${ne})`; let be = Yz(q, w); L = k("svg", { ref: this.setSVGElement, width: "100%", height: "100%", style: { position: "absolute" }, children: k("radialGradient", { id: ne, cy: q.centerAnchorY, cx: q.centerAnchorX, r: q.widthFactor, children: be.stops.map((re, pe) => k("stop", { offset: re.position, stopColor: re.color, stopOpacity: re.alpha }, pe)) }) }) } else if (Ki.isImageObject(i)) { let q = Kz(i, S, w); q && (R.fill = `url(#${q.id})`, L = k("svg", { ref: this.setSVGElement, width: "100%", height: "100%", style: { position: "absolute" }, children: k("defs", { children: k(e$, { ...q }) }) })) } let F = { "data-framer-component-type": "SVG" }, z = !C; z && Object.assign(F, Hk(this.props.center)); let D = !L && !R.fill && !R.background && !R.backgroundImage && o.length < f$ && !d$(o) && !h$(o), K = null; if (D) R.backgroundSize = "100% 100%", R.backgroundImage = `url('data:image/svg+xml;utf8,${encodeURIComponent(o)}')`, Jo.unsubscribe(this.previouslyRenderedSVG), this.previouslyRenderedSVG = ""; else { let q = g ? `svg${g}` : null, ne = Jo.subscribe(o, !g, q); Jo.unsubscribe(this.previouslyRenderedSVG), this.previouslyRenderedSVG = o, p$(R) && (R.overflow = "hidden"), K = ce(He, { children: [L, k("div", { className: "svgContainer", style: E, ref: this.container, dangerouslySetInnerHTML: { __html: ne } }, Ki.isImageObject(i) ? i.src : "")] }) } let U = el(this.props.as), { href: $, target: W, rel: ee, onClick: te } = this.props; return ce(U, { ...F, ...v, layoutId: u, transformTemplate: z ? qu(this.props.center) : void 0, id: t, ref: y, style: R, className: f, variants: d, tabIndex: this.props.tabIndex, role: l || c ? "img" : void 0, "aria-label": l, "aria-description": c, href: $, target: W, rel: ee, onClick: te, children: [K, k(m$, {})] }) } }, T(e, "supportsConstraints", !0), T(e, "defaultSVGProps", { left: void 0, right: void 0, top: void 0, bottom: void 0, style: void 0, _constraints: { enabled: !0, aspectRatio: null }, parentSize: 0, rotation: 0, visible: !0, svg: "", shadows: [] }), T(e, "defaultProps", { ...ku.defaultProps, ...e.defaultSVGProps }), e })(); function oU(e, t, n) { let r = fT(t); !n?.supportsExplicitInterCodegen && !r.some(i => i.explicitInter === !1) && r.push({ explicitInter: !1, fonts: [] }), Object.assign(e, { fonts: r }) } function sU(e) { return e.length === 0 ? [{ explicitInter: !1, fonts: [] }] : fT(e) } function fT(e) { let t = { explicitInter: !1, fonts: [] }, n = []; for (let r of e) y$(r) ? n.push(r) : t.fonts.push(b$(r)); return t.fonts.length > 0 && n.push(t), n } var v$ = "explicitInter"; function y$(e) { return v$ in e } function b$(e) { let t; return e.url.startsWith("https://fonts.gstatic.com/s/") ? t = "google" : e.url.startsWith("https://framerusercontent.com/third-party-assets/fontshare/") ? t = "fontshare" : t = "custom", { ...e, source: t } } function aU(e, t) { let n = `${e}-start`; performance.mark(n), t(); let r = `${e}-end`; performance.mark(r), performance.measure(e, n, r) } As.prototype.addChild = function ({ transformer: e = t => t }) { let t = Ue(e(this.get())); return this.onChange(n => t.set(e(n))), t };/**
 * @license Emotion v11.0.0
 * MIT License
 *
 * Copyright (c) Emotion team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *//*! Bundled license information:

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/export { x as a, mr as b, ps as c, dl as d, Ve as e, $T as f, vr as g, V as h, N as i, Ti as j, st as k, ae as l, A as m, Ct as n, k as o, ce as p, xr as q, gn as r, Q0 as s, P1 as t, OL as u, H6 as v, G6 as w, Y6 as x, K6 as y, Z6 as z, HM as A, Tk as B, wH as C, WO as D, EH as E, jD as F, RH as G, Du as H, K3 as I, c8 as J, m8 as K, w8 as L, o5 as M, mC as N, R8 as O, gC as P, M8 as Q, V8 as R, j8 as S, q8 as T, Y8 as U, BB as V, Z8 as W, zB as X, $B as Y, J8 as Z, rW as _, iW as $, mW as aa, Fu as ba, zW as ca, UW as da, Jo as ea, YW as fa, oU as ga, sU as ha, aU as ia };
//# sourceMappingURL=chunk-5THDIQFE.mjs.map
